<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Flink 源码阅读笔记（19）- Flink SQL 中流表 Join 的实现 - JR&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jrthe42" /><meta name="description" content="在使用 SQL 进行数据分析的过程中，关联查询是经常要使用到的操作。在传统的 OLTP 和 OLAP 领域中，关联查询的数据集都是有界的，因此可以依赖于缓存有界的数据集" /><meta name="keywords" content="jrthe42, Blog, Programming" />






<meta name="generator" content="Hugo 0.59.0 with theme even" />


<link rel="canonical" href="https://blog.jrwang.me/2020/2020-01-05-flink-sourcecode-sql-stream-join/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.7d171193.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Flink 源码阅读笔记（19）- Flink SQL 中流表 Join 的实现" />
<meta property="og:description" content="在使用 SQL 进行数据分析的过程中，关联查询是经常要使用到的操作。在传统的 OLTP 和 OLAP 领域中，关联查询的数据集都是有界的，因此可以依赖于缓存有界的数据集" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.jrwang.me/2020/2020-01-05-flink-sourcecode-sql-stream-join/" />
<meta property="article:published_time" content="2020-01-05T19:30:45+08:00" />
<meta property="article:modified_time" content="2020-01-09T17:57:40+08:00" />
<meta itemprop="name" content="Flink 源码阅读笔记（19）- Flink SQL 中流表 Join 的实现">
<meta itemprop="description" content="在使用 SQL 进行数据分析的过程中，关联查询是经常要使用到的操作。在传统的 OLTP 和 OLAP 领域中，关联查询的数据集都是有界的，因此可以依赖于缓存有界的数据集">


<meta itemprop="datePublished" content="2020-01-05T19:30:45&#43;08:00" />
<meta itemprop="dateModified" content="2020-01-09T17:57:40&#43;08:00" />
<meta itemprop="wordCount" content="6472">



<meta itemprop="keywords" content="Flink,实时计算,SQL," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flink 源码阅读笔记（19）- Flink SQL 中流表 Join 的实现"/>
<meta name="twitter:description" content="在使用 SQL 进行数据分析的过程中，关联查询是经常要使用到的操作。在传统的 OLTP 和 OLAP 领域中，关联查询的数据集都是有界的，因此可以依赖于缓存有界的数据集"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">JRTHE42</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">JRTHE42</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Flink 源码阅读笔记（19）- Flink SQL 中流表 Join 的实现</h1>

      <div class="post-meta">
        <span class="post-time"> 2020-01-05 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#双流-join-的挑战">双流 Join 的挑战</a></li>
<li><a href="#双流-join-的实现机制">双流 Join 的实现机制</a>
<ul>
<li><a href="#一条-join-语句的转换">一条 Join 语句的转换</a></li>
<li><a href="#两个重要的变换规则">两个重要的变换规则</a></li>
<li><a href="#物理执行计划">物理执行计划</a></li>
<li><a href="#状态存储的优化">状态存储的优化</a></li>
<li><a href="#关联处理逻辑">关联处理逻辑</a></li>
<li><a href="#semi-anti-join">SEMI/ANTI JOIN</a></li>
</ul></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>在使用 SQL 进行数据分析的过程中，关联查询是经常要使用到的操作。在传统的 OLTP 和 OLAP 领域中，关联查询的数据集都是有界的，因此可以依赖于缓存有界的数据集进行查询。但是在 Streaming SQL 中，针对 Stream Join Stream 的情况，由于关联查询的两侧都是连续无界的数据流，传统数据表中 Join 操作的实现和优化方式可能并不完全适用。在这篇文章中，我们将介绍双流 Join 面临的挑战，并对 Flink SQL 中双流 Join 的具体实现机制进行分析。</p>

<h2 id="双流-join-的挑战">双流 Join 的挑战</h2>

<p>在传统的数据库或批处理场景中 ，关联查询的数据集都是有限的，因此可以依赖于缓存有界的数据集，使用诸如 Nested-Loop Join，Sort-Merged Join 或者 Hash Join 等方法进行匹配查询。但是在 Streaming SQL 中，两个数据流的关联查询主要面临如下两个问题：一方面，数据流是无限的，缓存数据对 long-running 的任务而言会带来较高的存储和查询压力；另一方面，两侧数据流中消息到达的时间存在不一致的情况，可能造成关联结果的缺失。</p>

<p>对于上述的第一个问题，为了保证关联结果的正确性，需要将数据流中所有历史数据缓存下来。随着两个数据流中数据源源不断到来，缓存历史数据带来的开销越来越大，且每一条新到达的消息都会激发对另一侧历史数据的查询。为了解决该问题，一种方法是通过时间窗口将关联的数据范围限制在特定的时间范围内，即 Window Join（关于时间窗口可以参考之前的<a href="/2019/flink-source-code-time-and-window/">文章</a>）；另一种方法是，在存储开销和关联准确度方面做一下权衡，在缓存的历史数据上增加生存时间的限制，这样可以避免缓存的数据无限增长，但相应地可能会造成准确度的降低。</p>

<p><img src="/img/flink-sql-join/flink-sql-join-state-with-ttl.png" alt="flink-sql-join-state-with-ttl" /></p>

<p>上述第二个问题，主要针对的是外连接的情况。由于两侧数据到达时间的不确定性，对于特定消息，可能出现 t1 时刻不存在匹配记录，而 t2 (t2 &gt; t1) 时刻存在匹配记录的情况。对于外连接，要求在不存在关联结果的情况下返回 NULL 值。因此为了保证关联结果的正确性，一种方式是通过时间窗口限制关联的数据范围，但这样就要求在窗口结束时才输出结果，会导致输出延迟；另一种方式是采取“撤销-更正”的方式，先输出 NULL 值，在后续关联记录到达时再撤销已输出的记录，修正为关联的正确结果，其缺点是会造成输出记录数的放大。</p>

<p><img src="/img/flink-sql-join/flink-sql-outer-join.png" alt="flink-sql-outer-join" /></p>

<p>从上述的分析可以看出，时间窗口在关联查询中通过限制关联数据的范围，可以部分程度上解决 Streaming Join 面临的问题，其基本思路是将无限的数据流切分为有限的时间窗口。但时间窗口关联并不适合所有的情况，很多时候两个数据流的关联查询并不能限定在特定的时间窗口内；此外，时间窗口关联还存在输出延迟的情况。</p>

<p>本文的后续部分将对 Flink SQL 中普通双流 Join 的实现机制加以介绍，Window Join 的实现机制将在后续的文章中进行分析。</p>

<h2 id="双流-join-的实现机制">双流 Join 的实现机制</h2>

<h3 id="一条-join-语句的转换">一条 Join 语句的转换</h3>

<p>首先，我们以一条简单的 Join 语句为例，跟踪一条 Join 语句的变换过程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-SQL" data-lang="SQL"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">-- table A(&#39;a1, &#39;a2, &#39;a3)
</span><span class="c1">-- table B(&#39;b1, &#39;b2, &#39;b3)
</span><span class="c1"></span>
<span class="k">SELECT</span> <span class="n">a1</span><span class="p">,</span> <span class="n">b1</span> <span class="k">FROM</span> <span class="n">A</span> <span class="k">JOIN</span> <span class="n">B</span> <span class="k">ON</span> <span class="n">a1</span> <span class="o">=</span> <span class="n">b1</span> <span class="k">and</span> <span class="n">a2</span> <span class="o">&gt;</span> <span class="n">b2</span></code></pre></td></tr></table>
</div>
</div>
<p>上述的 SQL 语句在经过解析后，被转换为如下的逻辑计划：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></pre></td>
<td class="lntd">
<pre class="chroma">LogicalProject(a1=[$0], b1=[$3])
+- LogicalJoin(condition=[AND(=($0, $3), &gt;($1, $4))], joinType=[inner])
   :- LogicalTableScan(table=[[A, source: [TestTableSource(a1, a2, a3)]]])
   +- LogicalTableScan(table=[[B, source: [TestTableSource(b1, b2, b3)]]])</pre></td></tr></table>
</div>
</div>
<p>这份逻辑计划首先被转换为 Flink SQL 内部的 RelNode，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></pre></td>
<td class="lntd">
<pre class="chroma">FlinkLogicalCalc(select=[a1, b1])
+- FlinkLogicalJoin(condition=[AND(=($0, $2), &gt;($1, $3))], joinType=[inner])
   :- FlinkLogicalCalc(select=[a1, a2])
   :  +- FlinkLogicalTableSourceScan(table=[[A, source: [TestTableSource(a1, a2, a3)]]], fields=[a1, a2, a3])
   +- FlinkLogicalCalc(select=[b1, b2])
      +- FlinkLogicalTableSourceScan(table=[[B, source: [TestTableSource(b1, b2, b3)]]], fields=[b1, b2, b3])</pre></td></tr></table>
</div>
</div>
<p>此后，经过一系列优化规则被优化为最终的执行计划，如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></pre></td>
<td class="lntd">
<pre class="chroma">Calc(select=[a1, b1])
+- Join(joinType=[InnerJoin], where=[AND(=(a1, b1), &gt;(a2, b2))], select=[a1, a2, b1, b2], leftInputSpec=[NoUniqueKey], rightInputSpec=[NoUniqueKey])
   :- Exchange(distribution=[hash[a1]])
   :  +- Calc(select=[a1, a2])
   :     +- TableSourceScan(table=[[A, source: [TestTableSource(a1, a2, a3)]]], fields=[a1, a2, a3])
   +- Exchange(distribution=[hash[b1]])
      +- Calc(select=[b1, b2])
         +- TableSourceScan(table=[[B, source: [TestTableSource(b1, b2, b3)]]], fields=[b1, b2, b3])</pre></td></tr></table>
</div>
</div>
<p>至此，逻辑计划的优化阶段结束，进入物理计划生成的阶段。</p>

<p>Flink SQL 会为 <code>StreamExecJoin</code> 操作生成一个 <code>TwoInputTransformation</code> 变换，内部算子为 <code>StreamingJoinOperator</code>，用于在两个数据流中匹配关联记录；为 <code>StreamExecExchange</code> 操作生成一个 <code>PartitionTransformation</code> 变换，用来确定上游算子输出的记录转发到下游算子的分区。</p>

<h3 id="两个重要的变换规则">两个重要的变换规则</h3>

<p>在逻辑计划优化的过程中，有两个重要的规则需要关注，分别是 <code>StreamExecJoinRule</code> 和 <code>FlinkExpandConversionRule</code>。</p>

<p>顾名思义，<code>StreamExecJoinRule</code> 主要用于将 <code>FlinkLogicalJoin</code> 转换为 <code>StreamExecJoin</code>。但是这个变换是有条件限制的，即 <code>FlinkLogicalJoin</code> 的关联条件中不包含时间窗口。首先来看一下这个规则的匹配条件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">StreamExecJoinRule</span>
  <span class="k">extends</span> <span class="nc">RelOptRule</span><span class="o">(</span>
    <span class="n">operand</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">FlinkLogicalJoin</span><span class="o">],</span>
      <span class="n">operand</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">FlinkLogicalRel</span><span class="o">],</span> <span class="n">any</span><span class="o">()),</span>
      <span class="n">operand</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">FlinkLogicalRel</span><span class="o">],</span> <span class="n">any</span><span class="o">())),</span>
    <span class="s">&#34;StreamExecJoinRule&#34;</span><span class="o">)</span> <span class="o">{</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">matches</span><span class="o">(</span><span class="n">call</span><span class="k">:</span> <span class="kt">RelOptRuleCall</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">join</span><span class="k">:</span> <span class="kt">FlinkLogicalJoin</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="c1">//关联结果是否需要从右表投射数据，SEMI JOIN 和 ANTI JOIN 不需要选择右表的数据
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(!</span><span class="n">join</span><span class="o">.</span><span class="n">getJoinType</span><span class="o">.</span><span class="n">projectsRight</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// SEMI/ANTI JOIN 总是被转换为 StreamExecJoin
</span><span class="c1"></span>      <span class="k">return</span> <span class="kc">true</span>
    <span class="o">}</span>
    <span class="k">val</span> <span class="n">left</span><span class="k">:</span> <span class="kt">FlinkLogicalRel</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">FlinkLogicalRel</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">right</span><span class="k">:</span> <span class="kt">FlinkLogicalRel</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">FlinkLogicalRel</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">tableConfig</span> <span class="k">=</span> <span class="n">call</span><span class="o">.</span><span class="n">getPlanner</span><span class="o">.</span><span class="n">getContext</span><span class="o">.</span><span class="n">unwrap</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">FlinkContext</span><span class="o">]).</span><span class="n">getTableConfig</span>
    <span class="k">val</span> <span class="n">joinRowType</span> <span class="k">=</span> <span class="n">join</span><span class="o">.</span><span class="n">getRowType</span>

    <span class="c1">//左表不支持 Temporal Table
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">left</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">FlinkLogicalSnapshot</span><span class="o">])</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">TableException</span><span class="o">(</span>
        <span class="s">&#34;Temporal table join only support apply FOR SYSTEM_TIME AS OF on the right table.&#34;</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">//不支持 Temporal Table JOIN
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">right</span><span class="o">.</span><span class="n">isInstanceOf</span><span class="o">[</span><span class="kt">FlinkLogicalSnapshot</span><span class="o">]</span> <span class="o">||</span>
      <span class="nc">TemporalJoinUtil</span><span class="o">.</span><span class="n">containsTemporalJoinCondition</span><span class="o">(</span><span class="n">join</span><span class="o">.</span><span class="n">getCondition</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="o">}</span>

    <span class="c1">//从关联条件中提取 1）时间窗口边界 2）其它条件
</span><span class="c1"></span>    <span class="k">val</span> <span class="o">(</span><span class="n">windowBounds</span><span class="o">,</span> <span class="n">remainingPreds</span><span class="o">)</span> <span class="k">=</span> <span class="nc">WindowJoinUtil</span><span class="o">.</span><span class="n">extractWindowBoundsFromPredicate</span><span class="o">(</span>
      <span class="n">join</span><span class="o">.</span><span class="n">getCondition</span><span class="o">,</span>
      <span class="n">join</span><span class="o">.</span><span class="n">getLeft</span><span class="o">.</span><span class="n">getRowType</span><span class="o">.</span><span class="n">getFieldCount</span><span class="o">,</span>
      <span class="n">joinRowType</span><span class="o">,</span>
      <span class="n">join</span><span class="o">.</span><span class="n">getCluster</span><span class="o">.</span><span class="n">getRexBuilder</span><span class="o">,</span>
      <span class="n">tableConfig</span><span class="o">)</span>

    <span class="c1">//存在窗口，则不适用于该规则
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">windowBounds</span><span class="o">.</span><span class="n">isDefined</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">false</span>
    <span class="o">}</span>

    <span class="c1">//普通关联条件不能访问时间属性
</span><span class="c1"></span>    <span class="c1">// remaining predicate must not access time attributes
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">remainingPredsAccessTime</span> <span class="k">=</span> <span class="n">remainingPreds</span><span class="o">.</span><span class="n">isDefined</span> <span class="o">&amp;&amp;</span>
      <span class="nc">WindowJoinUtil</span><span class="o">.</span><span class="n">accessesTimeAttribute</span><span class="o">(</span><span class="n">remainingPreds</span><span class="o">.</span><span class="n">get</span><span class="o">,</span> <span class="n">joinRowType</span><span class="o">)</span>

    <span class="c1">//RowTime 属性不能出现在普通 join 的关联条件中
</span><span class="c1"></span>    <span class="c1">//@see https://stackoverflow.com/questions/57181771/flink-rowtime-attributes-must-not-be-in-the-input-rows-of-a-regular-join
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">rowTimeAttrInOutput</span> <span class="k">=</span> <span class="n">joinRowType</span><span class="o">.</span><span class="n">getFieldList</span>
      <span class="o">.</span><span class="n">exists</span><span class="o">(</span><span class="n">f</span> <span class="k">=&gt;</span> <span class="nc">FlinkTypeFactory</span><span class="o">.</span><span class="n">isRowtimeIndicatorType</span><span class="o">(</span><span class="n">f</span><span class="o">.</span><span class="n">getType</span><span class="o">))</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rowTimeAttrInOutput</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nc">TableException</span><span class="o">(</span>
        <span class="s">&#34;Rowtime attributes must not be in the input rows of a regular join. &#34;</span> <span class="o">+</span>
          <span class="s">&#34;As a workaround you can cast the time attributes of input tables to TIMESTAMP before.&#34;</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// joins require an equality condition
</span><span class="c1"></span>    <span class="c1">// or a conjunctive predicate with at least one equality condition
</span><span class="c1"></span>    <span class="c1">// and disable outer joins with non-equality predicates(see FLINK-5520)
</span><span class="c1"></span>    <span class="c1">// And do not accept a FlinkLogicalTemporalTableSourceScan as right input
</span><span class="c1"></span>    <span class="o">!</span><span class="n">remainingPredsAccessTime</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>其基本逻辑就是，在普通的双流 Join 中不支持 Temporal Table，不支持时间窗口，不支持访问时间属性。这里需要注意的一点是，在普通的双流 Join 中，Flink 没法保证关联结果按照时间先后顺序提交，会破坏时间属性的顺序，因此在<a href="https://stackoverflow.com/questions/57181771/flink-rowtime-attributes-must-not-be-in-the-input-rows-of-a-regular-join">普通的双流 Join 中关联条件不支持时间属性</a>。</p>

<p><code>StreamExecJoinRule</code> 会将 <code>FlinkLogicalJoin</code> 转换为 <code>StreamexecJoin</code>，但相应地，需要先对 <code>FlinkLogicalJoin</code> 的两个输入进行变换。在这里，会将 <code>FlinkRelDistribution</code> 这个 trait 下推到输入算子中。<code>FlinkRelDistribution</code> 用于确定上游算子结果转发到下游算子的分区信息。例如，如果关联条件中存在等值关联条件，那么就会按照对应的关联键进行哈希分区，确保相同键的记录被转发到相同的 Task 中，即 <code>FlinkRelDistribution.hash</code>；而如果关联条件中不存在等值条件，那么所有的记录只能被转发到同一个 Task 中，即 <code>FlinkRelDistribution.SINGLETON</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">StreamExecJoinRule</span><span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">onMatch</span><span class="o">(</span><span class="n">call</span><span class="k">:</span> <span class="kt">RelOptRuleCall</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">join</span><span class="k">:</span> <span class="kt">FlinkLogicalJoin</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">left</span> <span class="k">=</span> <span class="n">join</span><span class="o">.</span><span class="n">getLeft</span>
    <span class="k">val</span> <span class="n">right</span> <span class="k">=</span> <span class="n">join</span><span class="o">.</span><span class="n">getRight</span>

    <span class="c1">//根据是否存在等值关联条件确定 FlinkRelDistribution
</span><span class="c1"></span>    <span class="k">def</span> <span class="n">toHashTraitByColumns</span><span class="o">(</span>
        <span class="n">columns</span><span class="k">:</span> <span class="kt">util.Collection</span><span class="o">[</span><span class="k">_</span> <span class="k">&lt;:</span> <span class="kt">Number</span><span class="o">],</span>
        <span class="n">inputTraitSets</span><span class="k">:</span> <span class="kt">RelTraitSet</span><span class="o">)</span><span class="k">:</span> <span class="kt">RelTraitSet</span> <span class="o">=</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">distribution</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">columns</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">FlinkRelDistribution</span><span class="o">.</span><span class="nc">SINGLETON</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="nc">FlinkRelDistribution</span><span class="o">.</span><span class="n">hash</span><span class="o">(</span><span class="n">columns</span><span class="o">)</span>
      <span class="o">}</span>
      <span class="n">inputTraitSets</span>
        <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="nc">FlinkConventions</span><span class="o">.</span><span class="nc">STREAM_PHYSICAL</span><span class="o">)</span>
        <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="n">distribution</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="k">val</span> <span class="n">joinInfo</span> <span class="k">=</span> <span class="n">join</span><span class="o">.</span><span class="n">analyzeCondition</span><span class="o">()</span>
    <span class="k">val</span> <span class="o">(</span><span class="n">leftRequiredTrait</span><span class="o">,</span> <span class="n">rightRequiredTrait</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span>
      <span class="n">toHashTraitByColumns</span><span class="o">(</span><span class="n">joinInfo</span><span class="o">.</span><span class="n">leftKeys</span><span class="o">,</span> <span class="n">left</span><span class="o">.</span><span class="n">getTraitSet</span><span class="o">),</span>
      <span class="n">toHashTraitByColumns</span><span class="o">(</span><span class="n">joinInfo</span><span class="o">.</span><span class="n">rightKeys</span><span class="o">,</span> <span class="n">right</span><span class="o">.</span><span class="n">getTraitSet</span><span class="o">))</span>

    <span class="k">val</span> <span class="n">providedTraitSet</span> <span class="k">=</span> <span class="n">join</span><span class="o">.</span><span class="n">getTraitSet</span><span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="nc">FlinkConventions</span><span class="o">.</span><span class="nc">STREAM_PHYSICAL</span><span class="o">)</span>

    <span class="c1">//变换输入
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">newLeft</span><span class="k">:</span> <span class="kt">RelNode</span> <span class="o">=</span> <span class="nc">RelOptRule</span><span class="o">.</span><span class="n">convert</span><span class="o">(</span><span class="n">left</span><span class="o">,</span> <span class="n">leftRequiredTrait</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">newRight</span><span class="k">:</span> <span class="kt">RelNode</span> <span class="o">=</span> <span class="nc">RelOptRule</span><span class="o">.</span><span class="n">convert</span><span class="o">(</span><span class="n">right</span><span class="o">,</span> <span class="n">rightRequiredTrait</span><span class="o">)</span>

    <span class="c1">//生成 StreamExecJoin
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">newJoin</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">StreamExecJoin</span><span class="o">(</span>
      <span class="n">join</span><span class="o">.</span><span class="n">getCluster</span><span class="o">,</span>
      <span class="n">providedTraitSet</span><span class="o">,</span>
      <span class="n">newLeft</span><span class="o">,</span>
      <span class="n">newRight</span><span class="o">,</span>
      <span class="n">join</span><span class="o">.</span><span class="n">getCondition</span><span class="o">,</span>
      <span class="n">join</span><span class="o">.</span><span class="n">getJoinType</span><span class="o">)</span>
    <span class="n">call</span><span class="o">.</span><span class="n">transformTo</span><span class="o">(</span><span class="n">newJoin</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>对 <code>FlinkRelDistribution</code> 的匹配变换规则在 <code>FlinkExpandConversionRule</code> 中。<code>FlinkExpandConversionRule</code> 的作用是处理 <code>RelDistribution</code> 和 <code>RelCollation</code> 这两种 trait，其中 <code>RelDistribution</code> 描述数据的物理分布情况，<code>RelCollation</code> 描述排序情况（通常在 Batch 模式下应用在 ORDER BY 语句中）。</p>

<p>在 <code>FlinkExpandConversionRule</code> 中会为目标 trait 包含 <code>FlinkRelDistribution</code> 的变换生成一个 <code>StreamExecExchange</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">FlinkExpandConversionRule</span><span class="o">(</span><span class="n">flinkConvention</span><span class="k">:</span> <span class="kt">Convention</span><span class="o">)</span>
  <span class="k">extends</span> <span class="nc">RelOptRule</span><span class="o">(</span>
    <span class="n">operand</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">AbstractConverter</span><span class="o">],</span>
      <span class="n">operand</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">RelNode</span><span class="o">],</span> <span class="n">any</span><span class="o">)),</span>
    <span class="s">&#34;FlinkExpandConversionRule&#34;</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">override</span> <span class="k">def</span> <span class="n">matches</span><span class="o">(</span><span class="n">call</span><span class="k">:</span> <span class="kt">RelOptRuleCall</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span> <span class="o">{</span>
    <span class="c1">// from trait 和 to trait 不一致
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">toTraitSet</span> <span class="k">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">AbstractConverter</span><span class="o">].</span><span class="n">getTraitSet</span>
    <span class="k">val</span> <span class="n">fromTraitSet</span> <span class="k">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">RelNode</span><span class="o">].</span><span class="n">getTraitSet</span>
    <span class="n">toTraitSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">flinkConvention</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
      <span class="n">fromTraitSet</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="n">flinkConvention</span><span class="o">)</span> <span class="o">&amp;&amp;</span>
      <span class="o">!</span><span class="n">fromTraitSet</span><span class="o">.</span><span class="n">satisfies</span><span class="o">(</span><span class="n">toTraitSet</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">override</span> <span class="k">def</span> <span class="n">onMatch</span><span class="o">(</span><span class="n">call</span><span class="k">:</span> <span class="kt">RelOptRuleCall</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">converter</span><span class="k">:</span> <span class="kt">AbstractConverter</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">child</span><span class="k">:</span> <span class="kt">RelNode</span> <span class="o">=</span> <span class="n">call</span><span class="o">.</span><span class="n">rel</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">toTraitSet</span> <span class="k">=</span> <span class="n">converter</span><span class="o">.</span><span class="n">getTraitSet</span>
    <span class="c1">// try to satisfy required trait by itself.
</span><span class="c1"></span>    <span class="n">satisfyTraitsBySelf</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">toTraitSet</span><span class="o">,</span> <span class="n">call</span><span class="o">)</span>
    <span class="c1">// try to push down required traits to children.
</span><span class="c1"></span>    <span class="n">satisfyTraitsByInput</span><span class="o">(</span><span class="n">child</span><span class="o">,</span> <span class="n">toTraitSet</span><span class="o">,</span> <span class="n">call</span><span class="o">)</span>
  <span class="o">}</span>

  <span class="k">private</span> <span class="k">def</span> <span class="n">satisfyTraitsBySelf</span><span class="o">(</span>
      <span class="n">node</span><span class="k">:</span> <span class="kt">RelNode</span><span class="o">,</span>
      <span class="n">requiredTraits</span><span class="k">:</span> <span class="kt">RelTraitSet</span><span class="o">,</span>
      <span class="n">call</span><span class="k">:</span> <span class="kt">RelOptRuleCall</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">var</span> <span class="n">transformedNode</span> <span class="k">=</span> <span class="n">node</span>
    <span class="k">val</span> <span class="n">definedTraitDefs</span> <span class="k">=</span> <span class="n">call</span><span class="o">.</span><span class="n">getPlanner</span><span class="o">.</span><span class="n">getRelTraitDefs</span>
    <span class="c1">// 处理 FlinkRelDistribution
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">definedTraitDefs</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="nc">FlinkRelDistributionTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">toDistribution</span> <span class="k">=</span> <span class="n">requiredTraits</span><span class="o">.</span><span class="n">getTrait</span><span class="o">(</span><span class="nc">FlinkRelDistributionTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">)</span>
      <span class="n">transformedNode</span> <span class="k">=</span> <span class="n">satisfyDistribution</span><span class="o">(</span><span class="n">flinkConvention</span><span class="o">,</span> <span class="n">transformedNode</span><span class="o">,</span> <span class="n">toDistribution</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">definedTraitDefs</span><span class="o">.</span><span class="n">contains</span><span class="o">(</span><span class="nc">RelCollationTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">toCollation</span> <span class="k">=</span> <span class="n">requiredTraits</span><span class="o">.</span><span class="n">getTrait</span><span class="o">(</span><span class="nc">RelCollationTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">)</span>
      <span class="n">transformedNode</span> <span class="k">=</span> <span class="n">satisfyCollation</span><span class="o">(</span><span class="n">flinkConvention</span><span class="o">,</span> <span class="n">transformedNode</span><span class="o">,</span> <span class="n">toCollation</span><span class="o">)</span>
    <span class="o">}</span>
    <span class="n">checkSatisfyRequiredTrait</span><span class="o">(</span><span class="n">transformedNode</span><span class="o">,</span> <span class="n">requiredTraits</span><span class="o">)</span>
    <span class="n">call</span><span class="o">.</span><span class="n">transformTo</span><span class="o">(</span><span class="n">transformedNode</span><span class="o">)</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="k">object</span> <span class="nc">FlinkExpandConversionRule</span> <span class="o">{</span>
  <span class="k">def</span> <span class="n">satisfyDistribution</span><span class="o">(</span>
      <span class="n">flinkConvention</span><span class="k">:</span> <span class="kt">Convention</span><span class="o">,</span>
      <span class="n">node</span><span class="k">:</span> <span class="kt">RelNode</span><span class="o">,</span>
      <span class="n">requiredDistribution</span><span class="k">:</span> <span class="kt">FlinkRelDistribution</span><span class="o">)</span><span class="k">:</span> <span class="kt">RelNode</span> <span class="o">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">fromTraitSet</span> <span class="k">=</span> <span class="n">node</span><span class="o">.</span><span class="n">getTraitSet</span>
    <span class="k">val</span> <span class="n">fromDistribution</span> <span class="k">=</span> <span class="n">fromTraitSet</span><span class="o">.</span><span class="n">getTrait</span><span class="o">(</span><span class="nc">FlinkRelDistributionTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">)</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">fromDistribution</span><span class="o">.</span><span class="n">satisfies</span><span class="o">(</span><span class="n">requiredDistribution</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">requiredDistribution</span><span class="o">.</span><span class="n">getType</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">SINGLETON</span> <span class="o">|</span> <span class="nc">HASH_DISTRIBUTED</span> <span class="o">|</span> <span class="nc">RANGE_DISTRIBUTED</span> <span class="o">|</span>
             <span class="nc">BROADCAST_DISTRIBUTED</span> <span class="o">|</span> <span class="nc">RANDOM_DISTRIBUTED</span> <span class="k">=&gt;</span>
          <span class="n">flinkConvention</span> <span class="k">match</span> <span class="o">{</span>
            <span class="k">case</span> <span class="nc">FlinkConventions</span><span class="o">.</span><span class="nc">BATCH_PHYSICAL</span> <span class="k">=&gt;</span>
              <span class="c1">// replace collation with empty since distribution destroy collation
</span><span class="c1"></span>              <span class="o">......</span>
              <span class="k">new</span> <span class="nc">BatchExecExchange</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCluster</span><span class="o">,</span> <span class="n">traitSet</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="n">requiredDistribution</span><span class="o">)</span>
            <span class="k">case</span> <span class="nc">FlinkConventions</span><span class="o">.</span><span class="nc">STREAM_PHYSICAL</span> <span class="k">=&gt;</span>
              <span class="k">val</span> <span class="n">updateAsRetraction</span> <span class="k">=</span> <span class="n">fromTraitSet</span><span class="o">.</span><span class="n">getTrait</span><span class="o">(</span><span class="nc">UpdateAsRetractionTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">)</span>
              <span class="k">val</span> <span class="n">accMode</span> <span class="k">=</span> <span class="n">fromTraitSet</span><span class="o">.</span><span class="n">getTrait</span><span class="o">(</span><span class="nc">AccModeTraitDef</span><span class="o">.</span><span class="nc">INSTANCE</span><span class="o">)</span>
              <span class="c1">// replace collation with empty since distribution destroy collation
</span><span class="c1"></span>              <span class="k">val</span> <span class="n">traitSet</span> <span class="k">=</span> <span class="n">fromTraitSet</span>
                <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="n">requiredDistribution</span><span class="o">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="n">flinkConvention</span><span class="o">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="nc">RelCollations</span><span class="o">.</span><span class="nc">EMPTY</span><span class="o">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="n">updateAsRetraction</span><span class="o">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="o">(</span><span class="n">accMode</span><span class="o">)</span>
              <span class="c1">// 生成 StreamExecExchange
</span><span class="c1"></span>              <span class="k">new</span> <span class="nc">StreamExecExchange</span><span class="o">(</span><span class="n">node</span><span class="o">.</span><span class="n">getCluster</span><span class="o">,</span> <span class="n">traitSet</span><span class="o">,</span> <span class="n">node</span><span class="o">,</span> <span class="n">requiredDistribution</span><span class="o">)</span>
            <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">TableException</span><span class="o">(</span><span class="s">s&#34;Unsupported convention: </span><span class="si">$flinkConvention</span><span class="s">&#34;</span><span class="o">)</span>
          <span class="o">}</span>
        <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">TableException</span><span class="o">(</span><span class="s">s&#34;Unsupported type: </span><span class="si">${</span><span class="n">requiredDistribution</span><span class="o">.</span><span class="n">getType</span><span class="si">}</span><span class="s">&#34;</span><span class="o">)</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">node</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="物理执行计划">物理执行计划</h3>

<p>在得到最终的逻辑执行计划后，需要将其转换为物理执行计划，即生成 Flink 内部的 <code>Transformation</code> 算子。</p>

<p>首先，<code>StreamExecJoin</code> 的输入是两个 <code>StreamExecExchange</code> 节点，<code>StreamExecExchange</code> 会生成 <code>PartitionTransformation</code> 算子，用来决定上游数据到下游的分布情况。根据 <code>RelDistribution.Type</code> 的不同，<code>PartitionTransformation</code> 的 <code>StreamPartitioner</code> 会选择使用 <code>GlobalPartitioner</code>（对应 <code>RelDistribution.Type.SINGLETON</code>） 或是 <code>KeyGroupStreamPartitioner</code>（对应 <code>RelDistribution.Type.HASH_DISTRIBUTED</code>）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">StreamExecExchange</span> <span class="o">{</span>

  <span class="c1">//生成物理执行计划
</span><span class="c1"></span>  <span class="k">override</span> <span class="k">protected</span> <span class="k">def</span> <span class="n">translateToPlanInternal</span><span class="o">(</span>
      <span class="n">planner</span><span class="k">:</span> <span class="kt">StreamPlanner</span><span class="o">)</span><span class="k">:</span> <span class="kt">Transformation</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">inputTransform</span> <span class="k">=</span> <span class="n">getInputNodes</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">translateToPlan</span><span class="o">(</span><span class="n">planner</span><span class="o">)</span>
      <span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Transformation</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]]</span>
    <span class="k">val</span> <span class="n">inputTypeInfo</span> <span class="k">=</span> <span class="n">inputTransform</span><span class="o">.</span><span class="n">getOutputType</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">BaseRowTypeInfo</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">outputTypeInfo</span> <span class="k">=</span> <span class="nc">BaseRowTypeInfo</span><span class="o">.</span><span class="n">of</span><span class="o">(</span>
      <span class="nc">FlinkTypeFactory</span><span class="o">.</span><span class="n">toLogicalRowType</span><span class="o">(</span><span class="n">getRowType</span><span class="o">))</span>
    <span class="n">relDistribution</span><span class="o">.</span><span class="n">getType</span> <span class="k">match</span> <span class="o">{</span>
        <span class="c1">// 如果分布是 SINGLETON（不存在等值关联条件），所有记录被转发至同一个分区
</span><span class="c1"></span>      <span class="k">case</span> <span class="nc">RelDistribution</span><span class="o">.</span><span class="nc">Type</span><span class="o">.</span><span class="nc">SINGLETON</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">partitioner</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">GlobalPartitioner</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]</span>
        <span class="k">val</span> <span class="n">transformation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PartitionTransformation</span><span class="o">(</span>
          <span class="n">inputTransform</span><span class="o">,</span>
          <span class="n">partitioner</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">StreamPartitioner</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]])</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">setOutputType</span><span class="o">(</span><span class="n">outputTypeInfo</span><span class="o">)</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">setParallelism</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
        <span class="n">transformation</span>
      <span class="k">case</span> <span class="nc">RelDistribution</span><span class="o">.</span><span class="nc">Type</span><span class="o">.</span><span class="nc">HASH_DISTRIBUTED</span> <span class="k">=&gt;</span>
        <span class="k">val</span> <span class="n">selector</span> <span class="k">=</span> <span class="nc">KeySelectorUtil</span><span class="o">.</span><span class="n">getBaseRowSelector</span><span class="o">(</span>
          <span class="n">relDistribution</span><span class="o">.</span><span class="n">getKeys</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">toInt</span><span class="o">).</span><span class="n">toArray</span><span class="o">,</span> <span class="n">inputTypeInfo</span><span class="o">)</span>
        <span class="c1">// 如果分布是 HASH（存在等值关联条件），按 HASH 分区
</span><span class="c1"></span>        <span class="k">val</span> <span class="n">partitioner</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">KeyGroupStreamPartitioner</span><span class="o">(</span><span class="n">selector</span><span class="o">,</span>
          <span class="nc">DEFAULT_LOWER_BOUND_MAX_PARALLELISM</span><span class="o">)</span>
        <span class="k">val</span> <span class="n">transformation</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">PartitionTransformation</span><span class="o">(</span>
          <span class="n">inputTransform</span><span class="o">,</span>
          <span class="n">partitioner</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">StreamPartitioner</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]])</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">setOutputType</span><span class="o">(</span><span class="n">outputTypeInfo</span><span class="o">)</span>
        <span class="n">transformation</span><span class="o">.</span><span class="n">setParallelism</span><span class="o">(</span><span class="nc">ExecutionConfig</span><span class="o">.</span><span class="nc">PARALLELISM_DEFAULT</span><span class="o">)</span>
        <span class="n">transformation</span>
      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span>
        <span class="k">throw</span> <span class="k">new</span> <span class="nc">UnsupportedOperationException</span><span class="o">(</span>
          <span class="s">s&#34;not support RelDistribution: </span><span class="si">${</span><span class="n">relDistribution</span><span class="o">.</span><span class="n">getType</span><span class="si">}</span><span class="s"> now!&#34;</span><span class="o">)</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p>对于 <code>StreamExecJoin</code>，则会为其生成一个 <code>TwoInputTransformation</code>，其内部的转换代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-scala" data-lang="scala"><span class="k">class</span> <span class="nc">StreamExecJoin</span> <span class="o">{</span>
    <span class="k">override</span> <span class="k">protected</span> <span class="k">def</span> <span class="n">translateToPlanInternal</span><span class="o">(</span>
      <span class="n">planner</span><span class="k">:</span> <span class="kt">StreamPlanner</span><span class="o">)</span><span class="k">:</span> <span class="kt">Transformation</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="n">tableConfig</span> <span class="k">=</span> <span class="n">planner</span><span class="o">.</span><span class="n">getTableConfig</span>
    <span class="k">val</span> <span class="n">returnType</span> <span class="k">=</span> <span class="nc">BaseRowTypeInfo</span><span class="o">.</span><span class="n">of</span><span class="o">(</span><span class="nc">FlinkTypeFactory</span><span class="o">.</span><span class="n">toLogicalRowType</span><span class="o">(</span><span class="n">getRowType</span><span class="o">))</span>
    <span class="c1">// 对上游输入做变换
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">leftTransform</span> <span class="k">=</span> <span class="n">getInputNodes</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="n">translateToPlan</span><span class="o">(</span><span class="n">planner</span><span class="o">)</span>
      <span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Transformation</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]]</span>
    <span class="k">val</span> <span class="n">rightTransform</span> <span class="k">=</span> <span class="n">getInputNodes</span><span class="o">.</span><span class="n">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="n">translateToPlan</span><span class="o">(</span><span class="n">planner</span><span class="o">)</span>
      <span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">Transformation</span><span class="o">[</span><span class="kt">BaseRow</span><span class="o">]]</span>

    <span class="k">val</span> <span class="n">leftType</span> <span class="k">=</span> <span class="n">leftTransform</span><span class="o">.</span><span class="n">getOutputType</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">BaseRowTypeInfo</span><span class="o">]</span>
    <span class="k">val</span> <span class="n">rightType</span> <span class="k">=</span> <span class="n">rightTransform</span><span class="o">.</span><span class="n">getOutputType</span><span class="o">.</span><span class="n">asInstanceOf</span><span class="o">[</span><span class="kt">BaseRowTypeInfo</span><span class="o">]</span>

    <span class="c1">// 获取 Join Key，即 等值关联条件
</span><span class="c1"></span>    <span class="k">val</span> <span class="o">(</span><span class="n">leftJoinKey</span><span class="o">,</span> <span class="n">rightJoinKey</span><span class="o">)</span> <span class="k">=</span>
      <span class="nc">JoinUtil</span><span class="o">.</span><span class="n">checkAndGetJoinKeys</span><span class="o">(</span><span class="n">keyPairs</span><span class="o">,</span> <span class="n">getLeft</span><span class="o">,</span> <span class="n">getRight</span><span class="o">,</span> <span class="n">allowEmptyKey</span> <span class="k">=</span> <span class="kc">true</span><span class="o">)</span>

    <span class="c1">// 生成 KeySelector 的代码，用于提取 Join Key
</span><span class="c1"></span>    <span class="c1">// 如果不存在等值关联条件，返回的是 NullBinaryRowKeySelector，Join Key 为空
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">leftSelect</span> <span class="k">=</span> <span class="nc">KeySelectorUtil</span><span class="o">.</span><span class="n">getBaseRowSelector</span><span class="o">(</span><span class="n">leftJoinKey</span><span class="o">,</span> <span class="n">leftType</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">rightSelect</span> <span class="k">=</span> <span class="nc">KeySelectorUtil</span><span class="o">.</span><span class="n">getBaseRowSelector</span><span class="o">(</span><span class="n">rightJoinKey</span><span class="o">,</span> <span class="n">rightType</span><span class="o">)</span>

    <span class="c1">// 分析 Join 的输入侧，是否存在 UniqueKey， JoinKey 是否包含 UniqueKey
</span><span class="c1"></span>    <span class="c1">// 会根据 UniqueKey 优化状态的存储和查找方式
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">leftInputSpec</span> <span class="k">=</span> <span class="n">analyzeJoinInput</span><span class="o">(</span><span class="n">left</span><span class="o">)</span>
    <span class="k">val</span> <span class="n">rightInputSpec</span> <span class="k">=</span> <span class="n">analyzeJoinInput</span><span class="o">(</span><span class="n">right</span><span class="o">)</span>

    <span class="c1">// 生成比较关联条件的代码，这里只处理非等值关联条件况，等值关联的条件是通过状态隐式完成的
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">generatedCondition</span> <span class="k">=</span> <span class="nc">JoinUtil</span><span class="o">.</span><span class="n">generateConditionFunction</span><span class="o">(</span>
      <span class="n">tableConfig</span><span class="o">,</span>
      <span class="n">cluster</span><span class="o">.</span><span class="n">getRexBuilder</span><span class="o">,</span>
      <span class="n">getJoinInfo</span><span class="o">,</span>
      <span class="n">leftType</span><span class="o">.</span><span class="n">toRowType</span><span class="o">,</span>
      <span class="n">rightType</span><span class="o">.</span><span class="n">toRowType</span><span class="o">)</span>

    <span class="c1">//状态保存时间
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">minRetentionTime</span> <span class="k">=</span> <span class="n">tableConfig</span><span class="o">.</span><span class="n">getMinIdleStateRetentionTime</span>

    <span class="c1">//内部算子
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">operator</span> <span class="k">=</span> <span class="k">if</span> <span class="o">(</span><span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">ANTI</span> <span class="o">||</span> <span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">SEMI</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">new</span> <span class="nc">StreamingSemiAntiJoinOperator</span><span class="o">(</span>
        <span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">ANTI</span><span class="o">,</span>
        <span class="n">leftType</span><span class="o">,</span>
        <span class="n">rightType</span><span class="o">,</span>
        <span class="n">generatedCondition</span><span class="o">,</span>
        <span class="n">leftInputSpec</span><span class="o">,</span>
        <span class="n">rightInputSpec</span><span class="o">,</span>
        <span class="n">filterNulls</span><span class="o">,</span>
        <span class="n">minRetentionTime</span><span class="o">)</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">val</span> <span class="n">leftIsOuter</span> <span class="k">=</span> <span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">LEFT</span> <span class="o">||</span> <span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">FULL</span>
      <span class="k">val</span> <span class="n">rightIsOuter</span> <span class="k">=</span> <span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">RIGHT</span> <span class="o">||</span> <span class="n">joinType</span> <span class="o">==</span> <span class="nc">JoinRelType</span><span class="o">.</span><span class="nc">FULL</span>
      <span class="k">new</span> <span class="nc">StreamingJoinOperator</span><span class="o">(</span>
        <span class="n">leftType</span><span class="o">,</span>
        <span class="n">rightType</span><span class="o">,</span>
        <span class="n">generatedCondition</span><span class="o">,</span>
        <span class="n">leftInputSpec</span><span class="o">,</span>
        <span class="n">rightInputSpec</span><span class="o">,</span>
        <span class="n">leftIsOuter</span><span class="o">,</span>
        <span class="n">rightIsOuter</span><span class="o">,</span>
        <span class="n">filterNulls</span><span class="o">,</span>
        <span class="n">minRetentionTime</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">//变换
</span><span class="c1"></span>    <span class="k">val</span> <span class="n">ret</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TwoInputTransformation</span><span class="o">[</span><span class="kt">BaseRow</span>, <span class="kt">BaseRow</span>, <span class="kt">BaseRow</span><span class="o">](</span>
      <span class="n">leftTransform</span><span class="o">,</span>
      <span class="n">rightTransform</span><span class="o">,</span>
      <span class="n">getRelDetailedDescription</span><span class="o">,</span>
      <span class="n">operator</span><span class="o">,</span>
      <span class="n">returnType</span><span class="o">,</span>
      <span class="n">leftTransform</span><span class="o">.</span><span class="n">getParallelism</span><span class="o">)</span>

    <span class="c1">// 输入存在 RelDistribution.Type.SINGLETON（没有等值关联条件），则 Join 算子的并行度设为 1
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">inputsContainSingleton</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">ret</span><span class="o">.</span><span class="n">setParallelism</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
      <span class="n">ret</span><span class="o">.</span><span class="n">setMaxParallelism</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span>
    <span class="o">}</span>

    <span class="c1">// set KeyType and Selector for state
</span><span class="c1"></span>    <span class="c1">// 设置状态的 KeySelector，状态是 KeyedState
</span><span class="c1"></span>    <span class="n">ret</span><span class="o">.</span><span class="n">setStateKeySelectors</span><span class="o">(</span><span class="n">leftSelect</span><span class="o">,</span> <span class="n">rightSelect</span><span class="o">)</span>
    <span class="n">ret</span><span class="o">.</span><span class="n">setStateKeyType</span><span class="o">(</span><span class="n">leftSelect</span><span class="o">.</span><span class="n">getProducedType</span><span class="o">)</span>
    <span class="n">ret</span>
  <span class="o">}</span>
<span class="o">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>StreamExecJoin</code> 转换为 <code>TwoInputTransformation</code> 的过程中，首先会分析上游两个输入的特征，包括是否存在关联键（Join Key，对应等值关联条件），是否存在唯一键（Unique Key，唯一键可以用来保证上游的输出是唯一的，参考<a href="/2019/2019-10-16-flink-sourcecode-stream-and-dynamic-table/#判断唯一键">Flink 源码阅读笔记（18）- Flink SQL 中的流和动态表</a>），关联键中是否包含唯一键等。根据 Join 类型的不同， <code>TwoInputTransformation</code> 内部的算子是 <code>StreamingJoinOperator</code> 或者 <code>StreamingSemiAntiJoinOperator</code>（用于 SEMI/ANTI Join）。<code>StreamingJoinOperator</code> 内部使用 KeyedState，因此会将状态的 KeySelector 设置为关联键。</p>

<h3 id="状态存储的优化">状态存储的优化</h3>

<p>双流 Join 的情况下，为了保证关联结果的正确性，需要将历史记录保存在状态中。随着数据流中的数据源源不断到来，缓存历史数据带来的开销越来越大。为此，Flink SQL 一方面支持通过配置状态 TTL 来限制状态的保存时间，另一方面针对状态存储的结构进行了优化。</p>

<p>根据 <code>JoinInputSideSpec</code> 中输入侧的特点（是否包含唯一键、关联键是否包含唯一键），Flink SQL 设计了几种不同的状态存储结构，即 <code>JoinKeyContainsUniqueKey</code>, <code>InputSideHasUniqueKey</code> 和 <code>InputSideHasNoUniqueKey</code>，分别如下：</p>

<p><img src="/img/flink-sql-join/flink-stream-join-state.png" alt="flink-stream-join-state" /></p>

<p>上述几种不同的状态存储都实现了 <code>JoinRecordStateView</code> 接口，提供的三个方法如下，分别对应向状态中添加一条记录、撤回一条记录、查询关联记录这三种情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">JoinRecordStateView</span> <span class="p">{</span>

	<span class="cm">/**
</span><span class="cm">	 * Add a new record to the state view.
</span><span class="cm">	 */</span>
	<span class="kt">void</span> <span class="nf">addRecord</span><span class="p">(</span><span class="n">BaseRow</span> <span class="nf">record</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span><span class="p">;</span>

	<span class="cm">/**
</span><span class="cm">	 * Retract the record from the state view.
</span><span class="cm">	 */</span>
	<span class="kt">void</span> <span class="nf">retractRecord</span><span class="p">(</span><span class="n">BaseRow</span> <span class="nf">record</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span><span class="p">;</span>

	<span class="cm">/**
</span><span class="cm">	 * Gets all the records under the current context (i.e. join key).
</span><span class="cm">	 */</span>
	<span class="n">Iterable</span><span class="o">&lt;</span><span class="n">BaseRow</span><span class="o">&gt;</span> <span class="nf">getRecords</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>StreamingJoinOperator</code> 中的状态使用的是 KeyedState，key 就是当前记录的 Join Key。在不同情况下，不同状态存储的结构和访问开销如下：</p>

<table>
<thead>
<tr>
<th align="left"></th>
<th>State Structure</th>
<th>Update Row</th>
<th>Query by JK</th>
<th>Note</th>
</tr>
</thead>

<tbody>
<tr>
<td align="left"><code>JoinKeyContainsUniqueKey</code></td>
<td><code>&lt;JK,ValueState&lt;Record&gt;&gt;</code></td>
<td>O(1)</td>
<td>O(1)</td>
<td></td>
</tr>

<tr>
<td align="left"><code>InputSideHasUniqueKey</code></td>
<td><code>&lt;JK,MapState&lt;UK,Record&gt;&gt;</code></td>
<td>O(2)</td>
<td>O(N)</td>
<td>N = size of MapState</td>
</tr>

<tr>
<td align="left"><code>InputSideHasNoUniqueKey</code></td>
<td><code>&lt;JK,MapState&lt;Record, appear-times&gt;&gt;</code></td>
<td>O(2)</td>
<td>O(N)</td>
<td>N = size of MapState</td>
</tr>
</tbody>
</table>

<p>上述表格中的内容其实不难理解，根据 Join Key 和 Unique Key 的特性，状态的结构分为三种情况：</p>

<ul>
<li>如果 Join Key 包含了 Unique Key，那么一个 Join Key 只会对应一条记录，因此状态存储选择的是 <code>ValueState</code></li>
<li>如果输入存在 Unique Key，但 Join Key 不包含 Unique Key，一个 Join Key 可能会对应多条记录，但这些记录的 Unique Key 一定不同，因此选择使用 <code>MapState</code>，key 为 Unique Key， value 为对应的记录</li>
<li>如果输入不存在 Unique Key，那么状态状态只能是 <code>ListState</code> 或者 <code>MapState</code>，从 update 和 retract 的效率考虑，选择使用 <code>MapState</code>，直接使用记录本身作为 Key，value 为记录出现的次数</li>
</ul>

<p>还有一种特殊的情况，即不存在 Join Key（笛卡尔积），这种情况其实是 <code>InputSideHasNoUniqueKey</code> 的一种特例，所有记录的 Join Key 都是 <code>BinaryRowUtil.EMPTY_ROW</code>。</p>

<p>从最终的性能上来看，<code>JoinkKeyContainsUniqueKey</code> &gt; <code>InputSideHasUniqueKey</code> &gt; <code>InputSideHasNoUniqueKey</code>。</p>

<p>如果是外连接，那么作为外连接的一侧，其状态需要实现的是 <code>OuterJoinRecordStateView</code> 接口，它的具体实现也分为三种情况，如下：</p>

<p><img src="/img/flink-sql-join/flink-stream-join-state-outer.png" alt="flink-stream-join-state-outer" /></p>

<p><code>OuterJoinRecordStateView</code> 是对 <code>JoinRecordStateView</code> 的扩展，除了会将记录本身存储在状态里，还会将该条记录在另一侧关联到的记录数存储下来。之所以要将关联记录数存储在状态中，主要是为了方便 Outer Join 中处理和撤回用 NULL 值填充的结果。在下文介绍关联的具体逻辑时会进一步介绍。除此以外，<code>OuterJoinRecordStateView</code> 和 <code>JoinRecordStateView</code> 的存储结构是一致的。</p>

<h3 id="关联处理逻辑">关联处理逻辑</h3>

<p><code>StreamingJoinOperator</code> 中的主要逻辑其实就是两步：</p>

<ul>
<li>在数据到达时更新本侧的状态</li>
<li>在数据到达时根据 Join Key 去查询另一侧的状态</li>
</ul>

<p>在 Streaming SQL 中存在 ACCUMULATE 和 RETRACT 这两种类型的消息，在 Join 中需要分别考虑。如果达到的消息是 ACCUMULATE 类型的记录，那么相应的处理逻辑的伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></pre></td>
<td class="lntd">
<pre class="chroma">//record is ACC
if input side is outer //本侧是outer join
  if no matched row on the other side //另一侧没有匹配记录
    send +[record + null]
    state.add(record, 0) // 0 表示另一侧没有关联的记录
  else // other.size &gt; 0
    if other side is outer
      if (associated rows in matched rows == 0)
        //另一侧之前在本侧没有匹配的记录，所以需要撤回之前的 [null + other]
        send -[null + other]
      else
        skip
      endif
      otherState.update(other, old + 1) //另一侧关联的记录 + 1
    endif
    send +[record, other]s //另一侧有多少匹配的记录就发送多少条
    state.add(record, other.size) //更新状态
  endif
else //本侧不是 outer join
  state.add(record)
  if no matched row on the other side //另一侧没有匹配记录
    skip //无需输出
  else // other.size &gt; 0
    if other size is outer
      if (associated rows in matched rows == 0) 
        send -[null + other]
      else
        skip
      endif
      otherState.update(other, old + 1) //另一侧关联的记录 + 1
    endif
    send +[record + other]s //另一侧有多少匹配的记录就发送多少条
  endif
endif</pre></td></tr></table>
</div>
</div>
<p>Inner Join 的情况比较简单，这里需要注意的是对 Outer Join 的处理。Outer Join 要求在没有匹配记录时输出用 NULL 值填充的结果，但是后续另一侧有匹配记录到达时，就需要撤回已发送的 NULL 值填充记录，更正为正常的关联的结果。因此，在 <code>OuterJoinRecordStateView</code> 中会保存关联记录数，如果关联记录数为 0，则表明之前已经发送了 NULL 值填充的记录，那么就需要进行撤回操作，从而避免了每次重新计算已关联的记录数。</p>

<p>如果接收到的记录是一条 RETRACT 消息，那么相应处理逻辑的伪代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></pre></td>
<td class="lntd">
<pre class="chroma">//record is RETRACT
state.retract(record)
if no matched rows on the other side //另一侧没有关联记录
  if input side is outer
    send -[record + null]
  endif
else //另一侧存在关联记录
  send -[record, other]s //要撤回已发送的关联记录
  if other side is outer
    if the matched num in the matched rows == 0, this should never happen!
    if the matched num in the matched rows == 1, send +[null + other]
    if the matched num in the matched rows &gt; 1, skip
    otherState.update(other, old - 1) //另一侧关联的记录数 - 1
  endif
endif</pre></td></tr></table>
</div>
</div>
<p>下图简单给出了一个 inner join 的例子，两侧的状态都是 <code>InputSideHasNoUniqueKey</code>，上下两部分分别对应 ACCMULATE 和 RETRACT 的情形：
<img src="/img/flink-sql-join/flink-sql-inner-join-example.png" alt="flink-sql-inner-join-example" /></p>

<p>下图则是 Full outer join 的情况：
<img src="/img/flink-sql-join/flink-sql-outer-join-example.png" alt="flink-sql-outer-join-example" /></p>

<h3 id="semi-anti-join">SEMI/ANTI JOIN</h3>

<p>Flink SQL 除了支持普通的 Join 以外，还支持 SEMI JOIN（半连接） 和 ANTI JOIN（反连接）。SEMI/ANTI Join 和普通 Join 的区别在于不需要从右表获取数据,简单的例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-SQL" data-lang="SQL"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-SQL" data-lang="SQL"><span class="c1">-- SEMI JON
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">l</span> <span class="k">WHERE</span> <span class="n">a</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">d</span> <span class="k">FROM</span> <span class="n">r</span><span class="p">)</span>

<span class="c1">-- ANTI JOIN
</span><span class="c1"></span><span class="k">SELECT</span> <span class="o">*</span> <span class="k">FROM</span> <span class="n">l</span> <span class="k">WHERE</span> <span class="n">a</span> <span class="k">NOT</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">d</span> <span class="k">FROM</span> <span class="n">r</span><span class="p">)</span></code></pre></td></tr></table>
</div>
</div>
<p>SEMI/ANTI Join 最终被变换为 <code>StreamingSemiAntiJoinOperator</code> 算子，左右两侧的状态存储分别使用 <code>OuterJoinRecordStateView</code> 和 <code>JoinRecordStateView</code>。<code>StreamingSemiAntiJoinOperator</code> 和 <code>StreamingJoinOperator</code> 的逻辑非常接近，但由于不需要拼接右表的数据，因此更为简单，这里就不作进一步介绍了。</p>

<h2 id="小结">小结</h2>

<p>本文分析了 Streaming SQL 中双流 Join 面临的挑战，并对 Flink SQL 中双流 Join 的具体实现机制进行了介绍。Flink SQL 基于状态生存时间来限制无限数据流下状态的无限增长，并充分利用唯一键特性优化状态的存储形式；另外，Flink 基于 ACC/RETRACT 机制确保了关联结果的正确性。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://stackoverflow.com/questions/57181771/flink-rowtime-attributes-must-not-be-in-the-input-rows-of-a-regular-join">Rowtime attributes must not be in the input rows of a regular join</a></li>
</ul>

<p>-EOF-</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">原始链接</span>
    <span class="item-content"><a href="https://blog.jrwang.me/2020/2020-01-05-flink-sourcecode-sql-stream-join/">https://blog.jrwang.me/2020/2020-01-05-flink-sourcecode-sql-stream-join/</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2020-01-09
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flink/">Flink</a>
          <a href="/tags/%E5%AE%9E%E6%97%B6%E8%AE%A1%E7%AE%97/">实时计算</a>
          <a href="/tags/sql/">SQL</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2020/2020-12-20-flink-sourcecode-mailbox-threading-model/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Flink 源码阅读笔记（20）- Flink 基于 Mailbox 的线程模型</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/2019-10-16-flink-sourcecode-stream-and-dynamic-table/">
            <span class="next-text nav-default">Flink 源码阅读笔记（18）- Flink SQL 中的流和动态表</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="jrthe42/blog-comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jrthe42@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/jrthe42" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/jrthe42" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://blog.jrwang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.f79f403f.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-66913886-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
