<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="想入非非就是寻找神奇" />



  <meta name="keywords" content="Java,Original,Multithreading," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="在 Java 多线程编程中，sleep(), interrupt(), wait(), notify() 等方法是非常基本也很常用的方法。这些方法会改变运行中的 Java 线程的状态，正确地认识这些方法是掌握 Java 并发编程的基本要求。 Java 线程的状态先来谈一谈 Java 中线程的状态。在 Java 中，线程的状态和底层操作系统中线程的状态并不是一一对应的关系，我们所能见到的是 JVM">
<meta name="keywords" content="Java,Original,Multithreading">
<meta property="og:type" content="article">
<meta property="og:title" content="谈谈 Java 线程状态相关的几个方法">
<meta property="og:url" content="http://blog.jrwang.me/2016/java-thread-states/index.html">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="在 Java 多线程编程中，sleep(), interrupt(), wait(), notify() 等方法是非常基本也很常用的方法。这些方法会改变运行中的 Java 线程的状态，正确地认识这些方法是掌握 Java 并发编程的基本要求。 Java 线程的状态先来谈一谈 Java 中线程的状态。在 Java 中，线程的状态和底层操作系统中线程的状态并不是一一对应的关系，我们所能见到的是 JVM">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.jrwang.me/img/java-thread-states/thread-states-os.png">
<meta property="og:updated_time" content="2018-06-09T08:48:11.329Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="谈谈 Java 线程状态相关的几个方法">
<meta name="twitter:description" content="在 Java 多线程编程中，sleep(), interrupt(), wait(), notify() 等方法是非常基本也很常用的方法。这些方法会改变运行中的 Java 线程的状态，正确地认识这些方法是掌握 Java 并发编程的基本要求。 Java 线程的状态先来谈一谈 Java 中线程的状态。在 Java 中，线程的状态和底层操作系统中线程的状态并不是一一对应的关系，我们所能见到的是 JVM">
<meta name="twitter:image" content="http://blog.jrwang.me/img/java-thread-states/thread-states-os.png">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> 谈谈 Java 线程状态相关的几个方法 | JR's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66913886-2', 'auto');
  ga('send', 'pageview');
</script>




  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">JR's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              谈谈 Java 线程状态相关的几个方法
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-07-23T19:44:11+08:00" content="2016-07-23">
            2016-07-23
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>在 Java 多线程编程中，sleep(), interrupt(), wait(), notify() 等方法是非常基本也很常用的方法。这些方法会改变运行中的 Java 线程的状态，正确地认识这些方法是掌握 Java 并发编程的基本要求。</p>
<h3 id="Java-线程的状态"><a href="#Java-线程的状态" class="headerlink" title="Java 线程的状态"></a>Java 线程的状态</h3><p>先来谈一谈 Java 中线程的状态。在 Java 中，线程的状态和底层操作系统中线程的状态并不是一一对应的关系，我们所能见到的是 JVM 虚拟机层面暴露的状态。</p>
<p>Java 中线程的状态在 Thread 的内部枚举类 <code>Thread.State</code> 中定义，有 <code>NEW</code>, <code>RUNNABLE</code>, <code>BLOCKED</code>, <code>WAITING</code>, <code>TIMED_WAITING</code>, <code>TERMINATED</code> 这六类状态。</p>
<p>在 Java 的官方文档中写道：“A thread in the runnable state is executing in the Java virtual machine but it may be waiting for other resources from the operating system such as processor.” 就是说，处于 <code>RUNNABLE</code> 状态的线程在 JVM 虚拟机正在 Java 虚拟机中执行，但它可能正在等待来自于操作系统的其它资源，比如处理器。实际上，如果一个线程在等待阻塞I/O的操作时，它的状态也是 <code>RUNNABLE</code> 的。</p>
<p>如果一个线程在获取对象锁的过程中阻塞了（synchronized关键字），它就处于 <code>BLOCKED</code> 状态。Thread state for a thread blocked waiting for a monitor lock. A thread in the blocked state is waiting for a monitor lock to enter a synchronized block/method or reenter a synchronized block/method after calling Object.wait.</p>
<p>而如果是由于调用了下面这三类方法，则线程会处于 <code>WAITING</code> 状态，需要等待其他的线程将其唤醒:</p>
<ul>
<li><code>Object.wait</code> with no timeout</li>
<li><code>Thread.join</code> with no timeout</li>
<li><code>LockSupport.park</code></li>
</ul>
<p>如果是通过 <code>Lock.lock()</code> 方法等待获取锁时，也会处于 <code>WAITING</code> 状态。因为 <code>Lock</code> 接口的实现基于 AQS 实现的，而 AQS 中的阻塞操作都是基于 <code>LockSupport</code> 工具类实现的。</p>
<p><code>TIMED_WAITING</code> 状态和 <code>WAITING</code> 状态类似，只不过等待的是超时事件的发生，下面几种方法会使得线程进入该状态：</p>
<ul>
<li><code>Thread.sleep</code></li>
<li><code>Object.wait</code> with timeout</li>
<li><code>Thread.join</code> with timeout</li>
<li><code>LockSupport.parkNanos</code></li>
<li><code>LockSupport.parkUntil</code></li>
</ul>
<p>同样，带有超时的 <code>Lock.tryLock(long time, TimeUnit unit)</code> 方法在等待获取锁时也会进入该状态。</p>
<p>通常，在操作系统这一层面，线程存在五类状态，状态的转换关系可以参考下面的这张图。</p>
<p><img src="/img/java-thread-states/thread-states-os.png" alt="os-thread-state"></p>
<p>可以看到，JVM 中所说的线程状态和 OS 层面的线程状态是不太一样的。JVM 中 <code>RUNNABLE</code> 其实是包含了上图中的 <code>RUNNING</code>, <code>READY</code>， 和部分 <code>WAITING</code> 状态的；而  JVM 中 <code>WAITING</code>， <code>TIMED_WAITING</code> 和 <code>BLOCKED</code> 其实又是对上图中 <code>WAITING</code> 剩余情形的一个更细致的划分。</p>
<h3 id="sleep-vs-wait"><a href="#sleep-vs-wait" class="headerlink" title="sleep vs wait"></a><code>sleep</code> vs <code>wait</code></h3><p><code>sleep(long)</code> 和 <code>wait()</code> 方法都能让线程暂停执行，并让出当前的处理器资源。但是，这两个方法存在一些本质的区别。</p>
<p><code>sleep(long)</code> 方法是在 <code>Thread</code> 类中定义的静态方法，会使得线程睡眠（即暂时停止运行）一段指定的时间，进入 <code>TIMED_WAITING</code> 状态；当超时后重新进入 <code>RUNNABLE</code> 状态。<code>sleep()</code> 方法会保留当前线程的运行状态，线程所持有的锁资源并不会释放。</p>
<p><code>wait()</code> 方法是在 <code>Object</code> 上定义的方法，任何一个类都从 <code>Object</code> 类中继承了该方法。调用该方法(<code>obj.wait()</code>)的前提是当前线程获取了该对象(<code>obj</code>)的锁。调用该方法后，线程会进入 <code>WAITING</code> 状态，同时会释放持有的对象上的锁，JVM 会将该线程置于对象的等待队列中。<code>wait()</code> 方法需要通过 <code>obj.notify()</code> 或 <code>obj.notifyAll()</code> 来进行唤醒，<code>notify()</code>和<code>notifyAll()</code>会将对象的等待队列中的一个或全部线程移入对象的同步队列中来竞争对象的锁，当获取锁之后便从 <code>wait()</code> 方法中返回了。简单地说， <code>wait()</code> 方法会释放线程持有的锁，并等待 <code>notify()</code> 或 <code>notifyAll()</code> 唤醒，从 <code>wait()</code> 方法返回表明线程又重新获取了对象锁。</p>
<p><code>wait(long)</code> 是 <code>wait()</code> 的一个重载版本，效果基本一致，只是 <code>wait(long)</code> 进入 <code>TIMED_WAITING</code> 状态，超时也可以被唤醒。</p>
<h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a><code>interrupt</code></h3><p>很多人看到 <code>interrupt()</code> 方法，认为“中断”线程不就是让线程停止嘛。实际上， <code>interrupt()</code> 方法实现的根本就不是这个效果, <code>interrupt()</code>方法更像是发出一个信号，这个信号会改变线程的一个标识位属性（中断标识），对于这个信号如何进行响应则是无法确定的（可以有不同的处理逻辑）。很多时候调用 <code>interrupt()</code> 方法非但不是为了停止线程，反而是为了让线程继续运行下去。</p>
<p>在 Java 的文档中对 <code>interrupt()</code> 的效果列了四种情形：</p>
<blockquote>
<p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p>
</blockquote>
<blockquote>
<p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException.</p>
</blockquote>
<blockquote>
<p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p>
</blockquote>
<blockquote>
<p>If none of the previous conditions hold then this thread’s interrupt status will be set.</p>
</blockquote>
<p>前三种情形其实是描述了如果线程处于等待状态或是阻塞在某一种资源上，那么 <code>interrupt()</code> 方法会使得线程跳出这种状态继续执行下去。第四种情形则描述了如果线程正在正常执行，那么 <code>interrupt()</code> 的效果则是设置了线程的中断状态，至于怎么处理这种状态，可以选择忽略也可以按需处理。</p>
<p>可以通过 <code>isInterrupted()</code> 方法来测试当前线程的中断标识的状态；静态方法 <code>Thread.interrupted()</code> 可以判断当前线程是否处于中断状态，同时也会清除当前的中断状态。通常使用 <code>Thread.interrupted()</code> 来复位中断标识。在第一种情形的表示中我们可以看到，在抛出 <code>InterruptedException</code> 前会清除中断标识，因而在异常处理中调用 <code>isInterrupted()</code> 会返回 false。</p>
<p>如果线程调用 <code>sleep(long)</code> 方法睡眠了非常长的一段时间，现在想要将它唤醒，就可以调用 <code>interrupt()</code> 方法。注意是在 <code>wait()</code>, <code>sleep()</code>， <code>join()</code> 方法声明中的异常，可见不是调用 <code>interrupt()</code> 抛出异常，而是在 <code>wait()</code>, <code>sleep()</code>， <code>join()</code> 处于等待的过程中，调用 <code>interrupt()</code> 方法会使其从等待状态中返回，并收到 <code>InterruptedException</code> 异常，进而将控制逻辑交给异常处理语句。</p>
<p>在 <code>wait()</code> 方法中等待的线程被中断时，和使用 <code>notify()</code> 唤醒一样，必须要重新获得对象的锁才能从方法中返回，而不是立即就能返回并进入异常处理。下面这个例子简单地验证一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        WN wn = <span class="keyword">new</span> WN();</span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wn.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setName(<span class="string">"thread 1"</span>);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                wn.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t2.setName(<span class="string">"thread 2"</span>);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        System.out.println(<span class="string">"call interrupt @"</span> + System.currentTimeMillis());</span><br><span class="line">        t1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WN</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object o = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get lock @"</span></span><br><span class="line">                        + System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    o.wait();</span><br><span class="line">                    System.out.println(<span class="string">"return from wait() @"</span> + System.currentTimeMillis());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"interrupted during obj.wait() @"</span> + System</span><br><span class="line">                            .currentTimeMillis());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" get lock @"</span></span><br><span class="line">                        + System.currentTimeMillis());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">10000L</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" release lock @"</span> +</span><br><span class="line">                            System.currentTimeMillis());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">thread 1 get lock @1471189560880</span><br><span class="line">thread 2 get lock @1471189560880</span><br><span class="line">call interrupt @1471189561880</span><br><span class="line">thread 2 release lock @1471189570881</span><br><span class="line">interrupted during obj.wait() @1471189570881</span><br></pre></td></tr></table></figure>
<p>可以看到，只有在线程2释放了锁之后（只有线程2释放了线程1才能重新获取），才能从<code>wait()</code>方法中返回。</p>
<h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><code>yield()</code> 方法是 <code>Thread</code> 类的静态方法，也用于出让当前线程占用的CPU资源。和 <code>sleep(long)</code> 方法不同的是， <code>sleep(long)</code>会使得线程进入 <code>WAITING</code> 状态并且至少会等待超时时间到达后才会再次执行；而 <code>yield()</code> 方法则是从 <code>RUNNING</code> 进入 <code>READY</code> 状态（这里指的是操作系统层面，在 JVM 暴露出来的都是 <code>RUNNABLE</code> 状态），因而极有可能马上又被调度选中继续运行。</p>
<blockquote>
<p>A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.</p>
</blockquote>
<p>从文档中的表述来看，<code>yield()</code> 方法相比于 <code>sleep(long)</code> 方法更依赖与系统的调度。该方法并不经常用到。</p>
<p>-EOF-</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag">#Java</a>
          
            <a href="/tags/Original/" rel="tag">#Original</a>
          
            <a href="/tags/Multithreading/" rel="tag">#Multithreading</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/grpc-at-first-view/" rel="prev">Google 开源 RPC 框架 gRPC 初探</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/java-simpledateformat-multithread-threadlocal/" rel="next">SimpleDateFormat 的线程安全问题与 ThreadLocal</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.png" alt="JR" itemprop="image"/>
          <p class="site-author-name" itemprop="name">JR</p>
        </div>
        <p class="site-description motion-element" itemprop="description">想入非非就是寻找神奇</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">23</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">13</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jrthe42" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jrthe42" target="_blank">Weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://music.jrwang.me" target="_blank">Music</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://wiki.jrwang.me" target="_blank">Wiki</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jrwang.me" target="_blank">Site</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Java-线程的状态"><span class="nav-number">1.</span> <span class="nav-text">Java 线程的状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#sleep-vs-wait"><span class="nav-number">2.</span> <span class="nav-text">sleep vs wait</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#interrupt"><span class="nav-number">3.</span> <span class="nav-text">interrupt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#yield"><span class="nav-number">4.</span> <span class="nav-text">yield</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JR</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="powered-by">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  Modified By <a class="theme-link" href="http://jrwang.me">JR</a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
