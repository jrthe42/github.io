<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Flink 源码阅读笔记（11）- Checkpoint 机制和状态恢复 - JR&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jrthe42" /><meta name="description" content="在上一篇文章中，我们对 Flink 状态管理相关的代码逻辑进行了分析，但为了实现任务的故障恢复以及数据一致性的效果，还需要借助于检查点（Checkpoi" /><meta name="keywords" content="jrthe42, Blog, Programming" />






<meta name="generator" content="Hugo 0.59.0 with theme even" />


<link rel="canonical" href="https://blog.jrwang.me/2019/flink-source-code-checkpoint/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.7d171193.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Flink 源码阅读笔记（11）- Checkpoint 机制和状态恢复" />
<meta property="og:description" content="在上一篇文章中，我们对 Flink 状态管理相关的代码逻辑进行了分析，但为了实现任务的故障恢复以及数据一致性的效果，还需要借助于检查点（Checkpoi" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.jrwang.me/2019/flink-source-code-checkpoint/" />
<meta property="article:published_time" content="2019-06-22T19:58:33+00:00" />
<meta property="article:modified_time" content="2019-09-12T16:20:41+08:00" />
<meta itemprop="name" content="Flink 源码阅读笔记（11）- Checkpoint 机制和状态恢复">
<meta itemprop="description" content="在上一篇文章中，我们对 Flink 状态管理相关的代码逻辑进行了分析，但为了实现任务的故障恢复以及数据一致性的效果，还需要借助于检查点（Checkpoi">


<meta itemprop="datePublished" content="2019-06-22T19:58:33&#43;00:00" />
<meta itemprop="dateModified" content="2019-09-12T16:20:41&#43;08:00" />
<meta itemprop="wordCount" content="12470">



<meta itemprop="keywords" content="Flink," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flink 源码阅读笔记（11）- Checkpoint 机制和状态恢复"/>
<meta name="twitter:description" content="在上一篇文章中，我们对 Flink 状态管理相关的代码逻辑进行了分析，但为了实现任务的故障恢复以及数据一致性的效果，还需要借助于检查点（Checkpoi"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">JRTHE42</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">JRTHE42</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Flink 源码阅读笔记（11）- Checkpoint 机制和状态恢复</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-06-22 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#概述">概述</a></li>
<li><a href="#checkpoint-的发起流程">Checkpoint 的发起流程</a></li>
<li><a href="#checkpoint-的执行">Checkpoint 的执行</a>
<ul>
<li><a href="#barrier-的流动">barrier 的流动</a></li>
<li><a href="#存储检查点状态快照">存储检查点状态快照</a></li>
<li><a href="#本地状态存储">本地状态存储</a></li>
</ul></li>
<li><a href="#对-checkpoint-的确认">对 Checkpoint 的确认</a>
<ul>
<li><a href="#确认完成">确认完成</a></li>
<li><a href="#拒绝">拒绝</a></li>
</ul></li>
<li><a href="#状态恢复">状态恢复</a>
<ul>
<li><a href="#状态分配">状态分配</a></li>
<li><a href="#task-状态初始化">Task 状态初始化</a></li>
</ul></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>在上一篇文章中，我们对 Flink 状态管理相关的代码逻辑进行了分析，但为了实现任务的故障恢复以及数据一致性的效果，还需要借助于检查点（Checkpoint）机制。</p>

<p>简单地说，Checkpoint 是一种分布式快照：在某一时刻，对一个 Flink 作业所有的 task 做一个快照（snapshot），并且将快照保存在 memory / file system 等存储系统中。这样，在任务进行故障恢复的时候，就可以还原到任务故障前最近一次检查点的状态，从而保证数据的一致性。当然，为了保证 exactly-once / at-least-once 的特性，还需要数据源支持数据回放。</p>

<h2 id="概述">概述</h2>

<p>Flink 的 checkpoint 机制基于 chandy-lamda 算法，具体的实现可以参考 Flink 官方的<a href="https://ci.apache.org/projects/flink/flink-docs-release-1.8/internals/stream_checkpointing.html">文档</a>以及 Flink 团队发表的论文 <a href="http://www.vldb.org%2Fpvldb%2Fvol10%2Fp1718-carbone.pdf">State Management in Apache Flink</a>。这里先做一下概要性的介绍。</p>

<p>Flink 分布式快照的核心在与 stream barrier，barrier 是一种特殊的标记消息，会和正常的消息记录一起在数据流中向前流动。Checkpoint Coordinator 在需要触发检查点的时候要求数据源向数据流中注入 barrie， barrier 和正常的数据流中的消息一起向前流动，相当于将数据流中的消息切分到了不同的检查点中。当一个 operator 从它所有的 input channel 中都收到了 barrier，则会触发当前 operator 的快照操作，并向其下游 channel 中发射 barrier。当所有的 sink 都反馈完成了快照之后，Checkpoint Coordinator 认为检查点创建完毕。</p>

<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.8/fig/stream_barriers.svg" alt="stream_barriers.svg" /></p>

<p><img src="https://ci.apache.org/projects/flink/flink-docs-release-1.8/fig/checkpointing.svg" alt="checkpointing.svg" /></p>

<h2 id="checkpoint-的发起流程">Checkpoint 的发起流程</h2>

<p><code>CheckpointCoordinator</code> 是 Flink 分布式快照流程的“协调者”，它主要负责：</p>

<ul>
<li>发起 checkpoint 触发的消息，并接收不同 task 对 checkpoint 的响应信息（Ack）</li>
<li>维护 Ack 中附带的状态句柄（state-handle）的全局视图</li>
</ul>

<p>在 <code>StreamingJobGraphGenerator</code> 中，生成 JobGraph 之后会调用 <code>configureCheckpointing</code> 方法进行 Checkpoint 相关的配置。</p>

<p>这其中会有三个列表：</p>

<ul>
<li><code>List&lt;JobVertexID&gt; triggerVertices</code></li>
<li><code>List&lt;JobVertexID&gt; ackVertices</code></li>
<li><code>List&lt;JobVertexID&gt; commitVertices</code></li>
</ul>

<p>其中， <code>triggerVertices</code> 只包含那些作为 source 的节点，<code>ackVertices</code> 和 <code>commitVertices</code> 均包含所有的节点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">StreamingJobGraphGenerator</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">void</span> <span class="n">configureCheckpointing</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//  .........
</span><span class="c1"></span>
		<span class="c1">// collect the vertices that receive &#34;trigger checkpoint&#34; messages.
</span><span class="c1"></span>		<span class="c1">// currently, these are all the sources
</span><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">&gt;</span> <span class="nf">triggerVertices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

		<span class="c1">// collect the vertices that need to acknowledge the checkpoint
</span><span class="c1"></span>		<span class="c1">// currently, these are all vertices
</span><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">&gt;</span> <span class="nf">ackVertices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">jobVertices</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>

		<span class="c1">// collect the vertices that receive &#34;commit checkpoint&#34; messages
</span><span class="c1"></span>		<span class="c1">// currently, these are all vertices
</span><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">&gt;</span> <span class="nf">commitVertices</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">jobVertices</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">JobVertex</span> <span class="nf">vertex</span> <span class="o">:</span> <span class="n">jobVertices</span><span class="p">.</span><span class="na">values</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="na">isInputVertex</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">triggerVertices</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="na">getID</span><span class="p">());</span>
			<span class="p">}</span>
			<span class="n">commitVertices</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="na">getID</span><span class="p">());</span>
			<span class="n">ackVertices</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">.</span><span class="na">getID</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="c1">//...............
</span><span class="c1"></span><span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <code>ExecutionGraphBuilder#buildGraph</code> 中，如果作业开启了 checkpoint，则会调用 <code>ExecutionGraph.enableCheckpointing()</code> 方法, 这里会创建 <code>CheckpointCoordinator</code> 对象，并注册一个作业状态的监听 <code>CheckpointCoordinatorDeActivator</code>, <code>CheckpointCoordinatorDeActivator</code> 会在作业状态发生改变时得到通知。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">ExecutionGraph</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">enableCheckpointing</span><span class="p">(</span>
			<span class="kt">long</span> <span class="nf">interval</span><span class="p">,</span>
			<span class="kt">long</span> <span class="nf">checkpointTimeout</span><span class="p">,</span>
			<span class="kt">long</span> <span class="nf">minPauseBetweenCheckpoints</span><span class="p">,</span>
			<span class="kt">int</span> <span class="nf">maxConcurrentCheckpoints</span><span class="p">,</span>
			<span class="n">CheckpointRetentionPolicy</span> <span class="nf">retentionPolicy</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="nf">verticesToTrigger</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="nf">verticesToWaitFor</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="nf">verticesToCommitTo</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">MasterTriggerRestoreHook</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">masterHooks</span><span class="p">,</span>
			<span class="n">CheckpointIDCounter</span> <span class="nf">checkpointIDCounter</span><span class="p">,</span>
			<span class="n">CompletedCheckpointStore</span> <span class="nf">checkpointStore</span><span class="p">,</span>
			<span class="n">StateBackend</span> <span class="nf">checkpointStateBackend</span><span class="p">,</span>
			<span class="n">CheckpointStatsTracker</span> <span class="nf">statsTracker</span><span class="p">)</span> <span class="p">{</span>

		<span class="c1">// simple sanity checks
</span><span class="c1"></span>
		<span class="n">ExecutionVertex</span><span class="p">[]</span> <span class="nf">tasksToTrigger</span> <span class="o">=</span> <span class="n">collectExecutionVertices</span><span class="p">(</span><span class="n">verticesToTrigger</span><span class="p">);</span>
		<span class="n">ExecutionVertex</span><span class="p">[]</span> <span class="nf">tasksToWaitFor</span> <span class="o">=</span> <span class="n">collectExecutionVertices</span><span class="p">(</span><span class="n">verticesToWaitFor</span><span class="p">);</span>
		<span class="n">ExecutionVertex</span><span class="p">[]</span> <span class="nf">tasksToCommitTo</span> <span class="o">=</span> <span class="n">collectExecutionVertices</span><span class="p">(</span><span class="n">verticesToCommitTo</span><span class="p">);</span>

		<span class="c1">// create the coordinator that triggers and commits checkpoints and holds the state
</span><span class="c1"></span>		<span class="n">checkpointCoordinator</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckpointCoordinator</span><span class="p">(</span>
			<span class="n">jobInformation</span><span class="p">.</span><span class="na">getJobId</span><span class="p">(),</span>
			<span class="n">interval</span><span class="p">,</span>
			<span class="n">checkpointTimeout</span><span class="p">,</span>
			<span class="n">minPauseBetweenCheckpoints</span><span class="p">,</span>
			<span class="n">maxConcurrentCheckpoints</span><span class="p">,</span>
			<span class="n">retentionPolicy</span><span class="p">,</span>
			<span class="n">tasksToTrigger</span><span class="p">,</span>
			<span class="n">tasksToWaitFor</span><span class="p">,</span>
			<span class="n">tasksToCommitTo</span><span class="p">,</span>
			<span class="n">checkpointIDCounter</span><span class="p">,</span>
			<span class="n">checkpointStore</span><span class="p">,</span>
			<span class="n">checkpointStateBackend</span><span class="p">,</span>
			<span class="n">ioExecutor</span><span class="p">,</span>
			<span class="n">SharedStateRegistry</span><span class="p">.</span><span class="na">DEFAULT_FACTORY</span><span class="p">);</span>

		<span class="c1">// register the master hooks on the checkpoint coordinator
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">MasterTriggerRestoreHook</span><span class="o">&lt;?&gt;</span> <span class="n">hook</span> <span class="o">:</span> <span class="n">masterHooks</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">checkpointCoordinator</span><span class="p">.</span><span class="na">addMasterHook</span><span class="p">(</span><span class="n">hook</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;Trying to register multiple checkpoint hooks with the name: {}&#34;</span><span class="p">,</span> <span class="n">hook</span><span class="p">.</span><span class="na">getIdentifier</span><span class="p">());</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">checkpointCoordinator</span><span class="p">.</span><span class="na">setCheckpointStatsTracker</span><span class="p">(</span><span class="n">checkpointStatsTracker</span><span class="p">);</span>

		<span class="c1">// interval of max long value indicates disable periodic checkpoint,
</span><span class="c1"></span>		<span class="c1">// the CheckpointActivatorDeactivator should be created only if the interval is not max value
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">interval</span> <span class="o">!=</span> <span class="n">Long</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// the periodic checkpoint scheduler is activated and deactivated as a result of
</span><span class="c1"></span>			<span class="c1">// job status changes (running -&gt; on, all other states -&gt; off)
</span><span class="c1"></span>			<span class="n">registerJobStatusListener</span><span class="p">(</span><span class="n">checkpointCoordinator</span><span class="p">.</span><span class="na">createActivatorDeactivator</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当状态变为 RUNNING 时，<code>CheckpointCoordinatorDeActivator</code>会得到通知，并且通过 <code>CheckpointCoordinator.startCheckpointScheduler</code> 启动 checkpoint 的定时器。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">CheckpointCoordinatorDeActivator</span> <span class="kd">implements</span> <span class="nf">JobStatusListener</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">jobStatusChanges</span><span class="p">(</span><span class="n">JobID</span> <span class="nf">jobId</span><span class="p">,</span> <span class="n">JobStatus</span> <span class="nf">newJobStatus</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">timestamp</span><span class="p">,</span> <span class="n">Throwable</span> <span class="nf">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newJobStatus</span> <span class="o">==</span> <span class="n">JobStatus</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// start the checkpoint scheduler
</span><span class="c1"></span>			<span class="n">coordinator</span><span class="p">.</span><span class="na">startCheckpointScheduler</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// anything else should stop the trigger for now
</span><span class="c1"></span>			<span class="n">coordinator</span><span class="p">.</span><span class="na">stopCheckpointScheduler</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>定时任务被封装为 <code>ScheduledTrigger</code>, 运行时会调用 <code>CheckpointCoordinator.triggerCheckpoint()</code> 触发一次 checkpoint。<code>CheckpointCoordinator.triggerCheckpoint</code> 方法代码逻辑很长，概括地说，包括以下几个步骤：</p>

<ul>
<li>检查是否可以触发 checkpoint，包括是否需要强制进行 checkpoint，当前正在排队的并发 checkpoint 的数目是否超过阈值，距离上一次成功 checkpoint 的间隔时间是否过小等，如果这些条件不满足，则当前检查点的触发请求不会执行</li>
<li>检查是否所有需要触发 checkpoint 的 Execution 都是 <code>RUNNING</code> 状态</li>
<li>生成此次 checkpoint 的 checkpointID（id 是严格自增的），并初始化 <code>CheckpointStorageLocation</code>，<code>CheckpointStorageLocation</code> 是此次 checkpoint 存储位置的抽象，通过 <code>CheckpointStorage.initializeLocationForCheckpoint()</code> 创建（<code>CheckpointStorage</code> 目前有两个具体实现，分别为 <code>FsCheckpointStorage</code> 和 <code>MemoryBackendCheckpointStorage</code>），<code>CheckpointStorage</code> 则是从 <code>StateBackend</code> 中创建</li>
<li>生成 <code>PendingCheckpoint</code>，这表示一个处于中间状态的 checkpoint，并保存在 <code>checkpointId -&gt; PendingCheckpoint</code> 这样的映射关系中</li>
<li>注册一个调度任务，在 checkpoint 超时后取消此次 checkpoint，并重新触发一次新的 checkpoint</li>
<li>调用 <code>Execution.triggerCheckpoint()</code> 方法向所有需要 trigger 的 task 发起 checkpoint 请求</li>
</ul>

<p>savepoint 和 checkpoint 的处理逻辑基本一致，只是 savepoint 是强制触发的，需要调用 <code>Execution.triggerSynchronousSavepoint()</code> 进行触发。</p>

<p>在CheckpointCoordinator 内部也有三个列表：</p>

<ul>
<li><code>ExecutionVertex[] tasksToTrigger</code>;</li>
<li><code>ExecutionVertex[] tasksToWaitFor</code>;</li>
<li><code>ExecutionVertex[] tasksToCommitTo</code>;</li>
</ul>

<p>这就对应了前面 <code>JobGraph</code> 中的三个列表，在触发 checkpoint 的时候，只有作为 source 的 Execution 会调用 <code>Execution.triggerCheckpoint()</code> 方法。会通过 RPC 调用通知对应的 <code>RpcTaskManagerGateway</code> 调用 <code>triggerCheckpoint</code>。</p>

<h2 id="checkpoint-的执行">Checkpoint 的执行</h2>

<h3 id="barrier-的流动">barrier 的流动</h3>

<p><code>CheckpointCoordinator</code> 发出触发 checkpoint 的消息，最终通过 RPC 调用 <code>TaskExecutorGateway.triggerCheckpoint</code>，即请求执行 <code>TaskExecutor.triggerCheckpoin()</code>。 因为一个 <code>TaskExecutor</code> 中可能有多个 <code>Task</code> 正在运行，因而要根据触发 checkpoint 的 <code>ExecutionAttemptID</code> 找到对应的 <code>Task</code>，然后调用 <code>Task.triggerCheckpointBarrier()</code> 方法。只有作为 source 的 Task 才会触发 <code>triggerCheckpointBarrier()</code> 方法的调用。</p>

<p>在 <code>Task</code> 中，checkpoint 的触发被封装为一个异步任务执行，</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">Task</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">triggerCheckpointBarrier</span><span class="p">(</span>
			<span class="kd">final</span> <span class="nf">long</span> <span class="n">checkpointID</span><span class="p">,</span>
			<span class="kd">final</span> <span class="nf">long</span> <span class="n">checkpointTimestamp</span><span class="p">,</span>
			<span class="kd">final</span> <span class="nf">CheckpointOptions</span> <span class="n">checkpointOptions</span><span class="p">,</span>
			<span class="kd">final</span> <span class="nf">boolean</span> <span class="n">advanceToEndOfEventTime</span><span class="p">)</span> <span class="p">{</span>
		<span class="p">......</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">executionState</span> <span class="o">==</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">invokable</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// build a local closure
</span><span class="c1"></span>			<span class="kd">final</span> <span class="nf">String</span> <span class="n">taskName</span> <span class="o">=</span> <span class="n">taskNameWithSubtask</span><span class="p">;</span>
			<span class="kd">final</span> <span class="nf">SafetyNetCloseableRegistry</span> <span class="n">safetyNetCloseableRegistry</span> <span class="o">=</span>
				<span class="n">FileSystemSafetyNet</span><span class="p">.</span><span class="na">getSafetyNetCloseableRegistryForThread</span><span class="p">();</span>

			<span class="n">Runnable</span> <span class="nf">runnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="nf">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// set safety net from the task&#39;s context for checkpointing thread
</span><span class="c1"></span>					<span class="n">FileSystemSafetyNet</span><span class="p">.</span><span class="na">setSafetyNetCloseableRegistryForThread</span><span class="p">(</span><span class="n">safetyNetCloseableRegistry</span><span class="p">);</span>
					<span class="k">try</span> <span class="p">{</span>
						<span class="c1">//真正的调用逻辑
</span><span class="c1"></span>						<span class="kt">boolean</span> <span class="nf">success</span> <span class="o">=</span> <span class="n">invokable</span><span class="p">.</span><span class="na">triggerCheckpoint</span><span class="p">(</span><span class="n">checkpointMetaData</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">,</span> <span class="n">advanceToEndOfEventTime</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">checkpointResponder</span><span class="p">.</span><span class="na">declineCheckpoint</span><span class="p">(</span>
									<span class="n">getJobID</span><span class="p">(),</span> <span class="n">getExecutionId</span><span class="p">(),</span> <span class="n">checkpointID</span><span class="p">,</span>
									<span class="k">new</span> <span class="n">CheckpointDeclineTaskNotReadyException</span><span class="p">(</span><span class="n">taskName</span><span class="p">));</span>
						<span class="p">}</span>
					<span class="p">}</span>
					<span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">getExecutionState</span><span class="p">()</span> <span class="o">==</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">failExternally</span><span class="p">(</span><span class="k">new</span> <span class="n">Exception</span><span class="p">(</span>
								<span class="s">&#34;Error while triggering checkpoint &#34;</span> <span class="o">+</span> <span class="n">checkpointID</span> <span class="o">+</span> <span class="s">&#34; for &#34;</span> <span class="o">+</span>
									<span class="n">taskNameWithSubtask</span><span class="p">,</span> <span class="n">t</span><span class="p">));</span>
						<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
							<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Encountered error while triggering checkpoint {} for &#34;</span> <span class="o">+</span>
								<span class="s">&#34;{} ({}) while being not in state running.&#34;</span><span class="p">,</span> <span class="n">checkpointID</span><span class="p">,</span>
								<span class="n">taskNameWithSubtask</span><span class="p">,</span> <span class="n">executionId</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
						<span class="p">}</span>
					<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
						<span class="n">FileSystemSafetyNet</span><span class="p">.</span><span class="na">setSafetyNetCloseableRegistryForThread</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">};</span>
			<span class="c1">//异步执行
</span><span class="c1"></span>			<span class="n">executeAsyncCallRunnable</span><span class="p">(</span>
					<span class="n">runnable</span><span class="p">,</span>
					<span class="n">String</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;Checkpoint Trigger for %s (%s).&#34;</span><span class="p">,</span> <span class="n">taskNameWithSubtask</span><span class="p">,</span> <span class="n">executionId</span><span class="p">),</span>
					<span class="n">checkpointOptions</span><span class="p">.</span><span class="na">getCheckpointType</span><span class="p">().</span><span class="na">isSynchronous</span><span class="p">());</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// send back a message that we did not do the checkpoint
</span><span class="c1"></span>			<span class="n">checkpointResponder</span><span class="p">.</span><span class="na">declineCheckpoint</span><span class="p">(</span><span class="n">jobId</span><span class="p">,</span> <span class="n">executionId</span><span class="p">,</span> <span class="n">checkpointID</span><span class="p">,</span>
					<span class="k">new</span> <span class="n">CheckpointDeclineTaskNotReadyException</span><span class="p">(</span><span class="n">taskNameWithSubtask</span><span class="p">));</span>
		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Task</code> 执行 checkpoint 的真正逻辑被封装在 <code>AbstractInvokable.triggerCheckpoint(...)</code> 中，<code>AbstractInvokable</code> 中有两个触发 checkpoint 的方法：</p>

<ul>
<li><code>triggerCheckpoint</code></li>
<li><code>triggerCheckpointOnBarrier</code></li>
</ul>

<p>其中 <code>triggerCheckpoint</code> 是触发 checkpoint 的源头，会向下游注入 <code>CheckpointBarrier</code>；而下游的其他任务在收到 <code>CheckpointBarrier</code> 后调用 <code>triggerCheckpointOnBarrier</code> 方法。这两个方法的具体实现有一些细微的差异，但主要的逻辑是一致的，在 <code>StreamTask.performCheckpoint()</code> 方法中： 1）先向下游发送 barrier， 2）存储检查点快照。</p>

<p>一旦 <code>StreamTask.triggerCheckpoint()</code> 或 <code>StreamTask.triggerCheckpointOnBarrier()</code> b被调用，就会通过 <code>OperatorChain.broadcastCheckpointBarrier()</code> 向下游发送 barrier：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">OperatorChain</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">broadcastCheckpointBarrier</span><span class="p">(</span><span class="kt">long</span> <span class="nf">id</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">timestamp</span><span class="p">,</span> <span class="n">CheckpointOptions</span> <span class="nf">checkpointOptions</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="c1">//创建一个 CheckpointBarrier
</span><span class="c1"></span>		<span class="n">CheckpointBarrier</span> <span class="nf">barrier</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckpointBarrier</span><span class="p">(</span><span class="n">id</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">);</span>
		<span class="c1">//向所有的下游发送
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;</span> <span class="n">streamOutput</span> <span class="o">:</span> <span class="n">streamOutputs</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">streamOutput</span><span class="p">.</span><span class="na">broadcastEvent</span><span class="p">(</span><span class="n">barrier</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>我们已经知道，每一个 Task 的通过 <code>InputGate</code> 消费上游 Task 产生的数据，而实际上在 <code>StreamInputProcessor</code> 和 <code>StreamTwoInputProcessor</code> 中会创建 <code>CheckpointBarrierHandler</code>, <code>CheckpointBarrierHandler</code> 是对 <code>InputGate</code> 的一层封装，增加了对 <code>CheckpointBarrier</code> 等事件的处理。<code>CheckpointBarrierHandler</code> 有两个具体的实现，即 <code>BarrierTracker</code> 和 <code>BarrierBuffer</code>，分别对应 AT_LEAST_ONCE 和 EXACTLY_ONCE 这两种模式。</p>

<p><code>StreamInputProcessor</code> 和 <code>StreamTwoInputProcessor</code> 循环调用 <code>CheckpointBarrierHandler.getNextNonBlocked()</code> 获取新数据，因而在 <code>CheckpointBarrierHandler</code> 获得 <code>CheckpointBarrier</code> 后可以及时地进行 checkpoint 相关的操作。</p>

<p>我们先来看一下 AT_LEAST_ONCE 模式下的 <code>BarrierTracker</code>，它仅仅追踪从每一个 input channel 接收到的 barrier，当所有 input channel 的 barrier 都被接收时，就可以触发 checkpoint 了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">BarrierTracker</span> <span class="nf">implements</span> <span class="n">CheckpointBarrierHandler</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">BufferOrEvent</span> <span class="n">getNextNonBlocked</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">next</span> <span class="o">=</span> <span class="n">inputGate</span><span class="p">.</span><span class="na">getNextBufferOrEvent</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">.</span><span class="na">isPresent</span><span class="p">())</span> <span class="p">{</span>
				<span class="c1">// buffer or input exhausted
</span><span class="c1"></span>				<span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">BufferOrEvent</span> <span class="nf">bufferOrEvent</span> <span class="o">=</span> <span class="n">next</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">isBuffer</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">bufferOrEvent</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">().</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">CheckpointBarrier</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 接收到 CheckpointBarrier
</span><span class="c1"></span>				<span class="n">processBarrier</span><span class="p">((</span><span class="n">CheckpointBarrier</span><span class="p">)</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">(),</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">().</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">CancelCheckpointMarker</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 接收到 CancelCheckpointMarker
</span><span class="c1"></span>				<span class="n">processCheckpointAbortBarrier</span><span class="p">((</span><span class="n">CancelCheckpointMarker</span><span class="p">)</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">(),</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="c1">// some other event
</span><span class="c1"></span>				<span class="k">return</span> <span class="n">bufferOrEvent</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">processBarrier</span><span class="p">(</span><span class="n">CheckpointBarrier</span> <span class="nf">receivedBarrier</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">channelIndex</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">long</span> <span class="n">barrierId</span> <span class="o">=</span> <span class="n">receivedBarrier</span><span class="p">.</span><span class="na">getId</span><span class="p">();</span>
		<span class="c1">// fast path for single channel trackers
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">totalNumberOfInputChannels</span> <span class="o">==</span> <span class="n">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">notifyCheckpoint</span><span class="p">(</span><span class="n">barrierId</span><span class="p">,</span> <span class="n">receivedBarrier</span><span class="p">.</span><span class="na">getTimestamp</span><span class="p">(),</span> <span class="n">receivedBarrier</span><span class="p">.</span><span class="na">getCheckpointOptions</span><span class="p">());</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// find the checkpoint barrier in the queue of pending barriers
</span><span class="c1"></span>		<span class="n">CheckpointBarrierCount</span> <span class="nf">cbc</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="kt">int</span> <span class="nf">pos</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">CheckpointBarrierCount</span> <span class="nf">next</span> <span class="o">:</span> <span class="n">pendingCheckpoints</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="na">checkpointId</span> <span class="o">==</span> <span class="n">barrierId</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cbc</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">pos</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cbc</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// add one to the count to that barrier and check for completion
</span><span class="c1"></span>			<span class="kt">int</span> <span class="nf">numBarriersNew</span> <span class="o">=</span> <span class="n">cbc</span><span class="p">.</span><span class="na">incrementBarrierCount</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">numBarriersNew</span> <span class="o">==</span> <span class="n">totalNumberOfInputChannels</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// checkpoint can be triggered (or is aborted and all barriers have been seen)
</span><span class="c1"></span>				<span class="c1">// first, remove this checkpoint and all all prior pending
</span><span class="c1"></span>				<span class="c1">// checkpoints (which are now subsumed)
</span><span class="c1"></span>				<span class="c1">// 在当前 barrierId 前面的所有未完成的 checkpoint 都可以丢弃了
</span><span class="c1"></span>				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pendingCheckpoints</span><span class="p">.</span><span class="na">pollFirst</span><span class="p">();</span>
				<span class="p">}</span>

				<span class="c1">// notify the listener
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cbc</span><span class="p">.</span><span class="na">isAborted</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//通知进行 checkpoint
</span><span class="c1"></span>					<span class="n">notifyCheckpoint</span><span class="p">(</span><span class="n">receivedBarrier</span><span class="p">.</span><span class="na">getId</span><span class="p">(),</span> <span class="n">receivedBarrier</span><span class="p">.</span><span class="na">getTimestamp</span><span class="p">(),</span> <span class="n">receivedBarrier</span><span class="p">.</span><span class="na">getCheckpointOptions</span><span class="p">());</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="c1">// first barrier for that checkpoint ID
</span><span class="c1"></span>			<span class="c1">// add it only if it is newer than the latest checkpoint.
</span><span class="c1"></span>			<span class="c1">// if it is not newer than the latest checkpoint ID, then there cannot be a
</span><span class="c1"></span>			<span class="c1">// successful checkpoint for that ID anyways
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">barrierId</span> <span class="o">&gt;</span> <span class="n">latestPendingCheckpointID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">latestPendingCheckpointID</span> <span class="o">=</span> <span class="n">barrierId</span><span class="p">;</span>
				<span class="n">pendingCheckpoints</span><span class="p">.</span><span class="na">addLast</span><span class="p">(</span><span class="k">new</span> <span class="n">CheckpointBarrierCount</span><span class="p">(</span><span class="n">barrierId</span><span class="p">));</span>

				<span class="c1">// make sure we do not track too many checkpoints
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">pendingCheckpoints</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">MAX_CHECKPOINTS_TO_TRACK</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">pendingCheckpoints</span><span class="p">.</span><span class="na">pollFirst</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>而对于 EXACTLY_ONCE 模式下的 <code>BarrierBuffer</code>，它除了要追踪每一个 input channel 接收到的 barrier 之外，在接收到所有的 barrier 之前，先收到 barrier 的 channel 要进入阻塞状态。当然为了避免进入“反压”状态，<code>BarrierBuffer</code> 会继续接收数据，但会对接收到的数据进行缓存，直到所有的 barrier 都到达。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">BarrierBuffer</span> <span class="nf">implements</span> <span class="n">CheckpointBarrierHandler</span> <span class="p">{</span>
	<span class="cm">/** To utility to write blocked data to a file channel. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">BufferBlocker</span> <span class="nf">bufferBlocker</span><span class="p">;</span> <span class="c1">//用于缓存被阻塞的channel接收的数据
</span><span class="c1"></span>
	<span class="cm">/**
</span><span class="cm">	 * The sequence of buffers/events that has been unblocked and must now be consumed before
</span><span class="cm">	 * requesting further data from the input gate.
</span><span class="cm">	 */</span>
	<span class="kd">private</span> <span class="nf">BufferOrEventSequence</span> <span class="n">currentBuffered</span><span class="p">;</span> <span class="c1">//当前缓存的数据
</span><span class="c1"></span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">BufferOrEvent</span> <span class="n">getNextNonBlocked</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// process buffered BufferOrEvents before grabbing new ones
</span><span class="c1"></span>			<span class="c1">// 先处理缓存的数据
</span><span class="c1"></span>			<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">next</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currentBuffered</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">inputGate</span><span class="p">.</span><span class="na">getNextBufferOrEvent</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">ofNullable</span><span class="p">(</span><span class="n">currentBuffered</span><span class="p">.</span><span class="na">getNext</span><span class="p">());</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">.</span><span class="na">isPresent</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">completeBufferedSequence</span><span class="p">();</span>
					<span class="k">return</span> <span class="n">getNextNonBlocked</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">.</span><span class="na">isPresent</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">endOfStream</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// end of input stream. stream continues with the buffered data
</span><span class="c1"></span>					<span class="n">endOfStream</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
					<span class="n">releaseBlocksAndResetBarriers</span><span class="p">();</span>
					<span class="k">return</span> <span class="n">getNextNonBlocked</span><span class="p">();</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="c1">// final end of both input and buffered data
</span><span class="c1"></span>					<span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">BufferOrEvent</span> <span class="nf">bufferOrEvent</span> <span class="o">=</span> <span class="n">next</span><span class="p">.</span><span class="na">get</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isBlocked</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">()))</span> <span class="p">{</span>
				<span class="c1">// 如果当前 channel 是 block 状态，先写入缓存
</span><span class="c1"></span>				<span class="c1">// if the channel is blocked, we just store the BufferOrEvent
</span><span class="c1"></span>				<span class="n">bufferBlocker</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">);</span>
				<span class="n">checkSizeLimit</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">isBuffer</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">bufferOrEvent</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">().</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">CheckpointBarrier</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">endOfStream</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// process barriers only if there is a chance of the checkpoint completing
</span><span class="c1"></span>					<span class="n">processBarrier</span><span class="p">((</span><span class="n">CheckpointBarrier</span><span class="p">)</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">(),</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">().</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">CancelCheckpointMarker</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">processCancellationBarrier</span><span class="p">((</span><span class="n">CancelCheckpointMarker</span><span class="p">)</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">());</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">().</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">EndOfPartitionEvent</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">processEndOfPartition</span><span class="p">();</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="n">bufferOrEvent</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="p">.......</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>除了 <code>CheckpointBarrier</code> 消息以外，在 checkpoint 发生异常或取消 checkpoint 的时候，会向下游发送 <code>CancelCheckpointMarker</code> 消息。</p>

<h3 id="存储检查点状态快照">存储检查点状态快照</h3>

<p>在触发了 checkpoint 之后，对于一个 Task 而言，最重要的就是将当前 Task 中所有算子的状态快照（state snapshot）储存到外部存储系统的。外部存储系统可能是一个分布式文件系统，也可能是 JobManager 内存中。</p>

<p>在 <code>StreamTask.performCheckpoint</code> 方法中，开始进行 checkpoint 操作，这里主要分为三部分：1）checkpoint的准备操作，这里通常不进行太多操作；2）发送 CheckpointBarrier；3）存储检查点快照：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">StreamTask</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">boolean</span> <span class="n">performCheckpoint</span><span class="p">(</span>
			<span class="n">CheckpointMetaData</span> <span class="nf">checkpointMetaData</span><span class="p">,</span>
			<span class="n">CheckpointOptions</span> <span class="nf">checkpointOptions</span><span class="p">,</span>
			<span class="n">CheckpointMetrics</span> <span class="nf">checkpointMetrics</span><span class="p">,</span>
			<span class="kt">boolean</span> <span class="nf">advanceToEndOfTime</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">long</span> <span class="n">checkpointId</span> <span class="o">=</span> <span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">();</span>
		<span class="kd">final</span> <span class="nf">boolean</span> <span class="n">result</span><span class="p">;</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isRunning</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">checkpointOptions</span><span class="p">.</span><span class="na">getCheckpointType</span><span class="p">().</span><span class="na">isSynchronous</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">syncSavepointLatch</span><span class="p">.</span><span class="na">setCheckpointId</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">advanceToEndOfTime</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">advanceToEndOfEventTime</span><span class="p">();</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="c1">// All of the following steps happen as an atomic step from the perspective of barriers and
</span><span class="c1"></span>				<span class="c1">// records/watermarks/timers/callbacks.
</span><span class="c1"></span>				<span class="c1">// We generally try to emit the checkpoint barrier as soon as possible to not affect downstream
</span><span class="c1"></span>				<span class="c1">// checkpoint alignments
</span><span class="c1"></span>
				<span class="c1">// Step (1): Prepare the checkpoint, allow operators to do some pre-barrier work.
</span><span class="c1"></span>				<span class="c1">//           The pre-barrier work should be nothing or minimal in the common case.
</span><span class="c1"></span>				<span class="n">operatorChain</span><span class="p">.</span><span class="na">prepareSnapshotPreBarrier</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">);</span>

				<span class="c1">// Step (2): Send the checkpoint barrier downstream
</span><span class="c1"></span>				<span class="n">operatorChain</span><span class="p">.</span><span class="na">broadcastCheckpointBarrier</span><span class="p">(</span>
						<span class="n">checkpointId</span><span class="p">,</span>
						<span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getTimestamp</span><span class="p">(),</span>
						<span class="n">checkpointOptions</span><span class="p">);</span>

				<span class="c1">// Step (3): Take the state snapshot. This should be largely asynchronous, to not
</span><span class="c1"></span>				<span class="c1">//           impact progress of the streaming topology
</span><span class="c1"></span>				<span class="n">checkpointState</span><span class="p">(</span><span class="n">checkpointMetaData</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">,</span> <span class="n">checkpointMetrics</span><span class="p">);</span>
				<span class="n">result</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="c1">// we cannot perform our checkpoint - let the downstream operators know that they
</span><span class="c1"></span>				<span class="c1">// should not wait for any input from this operator
</span><span class="c1"></span>				<span class="c1">// we cannot broadcast the cancellation markers on the &#39;operator chain&#39;, because it may not
</span><span class="c1"></span>				<span class="c1">// yet be created
</span><span class="c1"></span>				<span class="kd">final</span> <span class="nf">CancelCheckpointMarker</span> <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CancelCheckpointMarker</span><span class="p">(</span><span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">());</span>
				<span class="n">Exception</span> <span class="nf">exception</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">RecordWriter</span><span class="o">&lt;</span><span class="n">SerializationDelegate</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">recordWriter</span> <span class="o">:</span> <span class="n">recordWriters</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">try</span> <span class="p">{</span>
						<span class="n">recordWriter</span><span class="p">.</span><span class="na">broadcastEvent</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">exception</span> <span class="o">=</span> <span class="n">ExceptionUtils</span><span class="p">.</span><span class="na">firstOrSuppressed</span><span class="p">(</span>
							<span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;Could not send cancel checkpoint marker to downstream tasks.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">),</span>
							<span class="n">exception</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">exception</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">throw</span> <span class="n">exception</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">result</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isRunning</span> <span class="o">&amp;&amp;</span> <span class="n">syncSavepointLatch</span><span class="p">.</span><span class="na">isSet</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//保存 savepoint，等待 checkpoint 确认完成
</span><span class="c1"></span>			<span class="kd">final</span> <span class="nf">boolean</span> <span class="n">checkpointWasAcked</span> <span class="o">=</span>
					<span class="n">syncSavepointLatch</span><span class="p">.</span><span class="na">blockUntilCheckpointIsAcknowledged</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">checkpointWasAcked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">finishTask</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在介绍如何存储检查点快照之前，先简单了解一下和 checkpoint 存储相关的一些类。简单地来说，<code>CheckpointStorage</code> 是对状态存储系统的抽象，它有两个不同的实现，分别是 <code>MemoryBackendCheckpointStorage</code> 和 <code>FsCheckpointStorage</code>。<code>MemoryBackendCheckpointStorage</code> 会将所有算子的检查点状态存储在 JobManager 的内存中，通常不适合在生产环境中使用；而 <code>FsCheckpointStorage</code> 则会把所有算子的检查点状态持久化存储在文件系统中。<code>CheckpointStorageLocation</code> 是对检查点状态存储位置的一个抽象，它能够提供获取检查点输出流的方法，通过输出流将状态和元数据写入到存储系统中。输出流关闭时可以获得状态句柄（StateHandle），后面可以使用句柄重新读取写入的状态。</p>

<p><img src="/img/flink/checkpoint-storage.svg" alt="checkpoint storage" /></p>

<p>接着我们来看看进行快照操作的主要逻辑。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">StreamTask</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">void</span> <span class="n">checkpointState</span><span class="p">(</span>
			<span class="n">CheckpointMetaData</span> <span class="nf">checkpointMetaData</span><span class="p">,</span>
			<span class="n">CheckpointOptions</span> <span class="nf">checkpointOptions</span><span class="p">,</span>
			<span class="n">CheckpointMetrics</span> <span class="nf">checkpointMetrics</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>

		<span class="c1">//1. 解析得到 CheckpointStorageLocation
</span><span class="c1"></span>		<span class="n">CheckpointStreamFactory</span> <span class="nf">storage</span> <span class="o">=</span> <span class="n">checkpointStorage</span><span class="p">.</span><span class="na">resolveCheckpointStorageLocation</span><span class="p">(</span>
				<span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span>
				<span class="n">checkpointOptions</span><span class="p">.</span><span class="na">getTargetLocation</span><span class="p">());</span>

		<span class="c1">//2. 将存储过程封装为 CheckpointingOperation，开始进行检查点存储操作
</span><span class="c1"></span>		<span class="n">CheckpointingOperation</span> <span class="nf">checkpointingOperation</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckpointingOperation</span><span class="p">(</span>
			<span class="k">this</span><span class="p">,</span>
			<span class="n">checkpointMetaData</span><span class="p">,</span>
			<span class="n">checkpointOptions</span><span class="p">,</span>
			<span class="n">storage</span><span class="p">,</span>
			<span class="n">checkpointMetrics</span><span class="p">);</span>
		<span class="n">checkpointingOperation</span><span class="p">.</span><span class="na">executeCheckpointing</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>每一个算子的快照被抽象为 <code>OperatorSnapshotFutures</code>，包含了 operator state 和 keyed state 的快照结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">OperatorSnapshotFutures</span> <span class="p">{</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">RunnableFuture</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">keyedStateManagedFuture</span><span class="p">;</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">RunnableFuture</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">keyedStateRawFuture</span><span class="p">;</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">RunnableFuture</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">operatorStateManagedFuture</span><span class="p">;</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">RunnableFuture</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">operatorStateRawFuture</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>检查点快照的过程被封装为 <code>CheckpointingOperation</code>，由于每一个 <code>StreamTask</code> 可能包含多个算子，因而内部使用一个 Map 维护 <code>OperatorID -&gt; OperatorSnapshotFutures</code> 的关系。<code>CheckpointingOperation</code> 中，快照操作分为两个阶段，第一阶段是同步执行的，第二阶段是异步执行的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">StreamTask</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">static</span> <span class="kd">final</span> <span class="nf">class</span> <span class="n">CheckpointingOperation</span> <span class="p">{</span>
		<span class="c1">//OperatorID -&gt; OperatorSnapshotFutures
</span><span class="c1"></span>		<span class="kd">private</span> <span class="nf">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="p">,</span> <span class="n">OperatorSnapshotFutures</span><span class="o">&gt;</span> <span class="nf">operatorSnapshotsInProgress</span><span class="p">;</span>

		<span class="c1">//执行检查点快照
</span><span class="c1"></span>		<span class="kd">public</span> <span class="nf">void</span> <span class="n">executeCheckpointing</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
			<span class="n">startSyncPartNano</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">nanoTime</span><span class="p">();</span>

			<span class="k">try</span> <span class="p">{</span>
				<span class="c1">//1. 同步执行的部分
</span><span class="c1"></span>				<span class="k">for</span> <span class="p">(</span><span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">op</span> <span class="o">:</span> <span class="n">allOperators</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">checkpointStreamOperator</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="c1">//2. 异步执行的部分
</span><span class="c1"></span>				<span class="c1">// checkpoint 可以配置成同步执行，也可以配置成异步执行的
</span><span class="c1"></span>				<span class="c1">// 如果是同步执行的，在这里实际上所有的 runnable future 都是已经完成的状态
</span><span class="c1"></span>				<span class="n">AsyncCheckpointRunnable</span> <span class="nf">asyncCheckpointRunnable</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AsyncCheckpointRunnable</span><span class="p">(</span>
					<span class="n">owner</span><span class="p">,</span>
					<span class="n">operatorSnapshotsInProgress</span><span class="p">,</span>
					<span class="n">checkpointMetaData</span><span class="p">,</span>
					<span class="n">checkpointMetrics</span><span class="p">,</span>
					<span class="n">startAsyncPartNano</span><span class="p">);</span>
				<span class="n">owner</span><span class="p">.</span><span class="na">cancelables</span><span class="p">.</span><span class="na">registerCloseable</span><span class="p">(</span><span class="n">asyncCheckpointRunnable</span><span class="p">);</span>
				<span class="n">owner</span><span class="p">.</span><span class="na">asyncOperationsThreadPool</span><span class="p">.</span><span class="na">submit</span><span class="p">(</span><span class="n">asyncCheckpointRunnable</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">ex</span><span class="p">)</span> <span class="p">{</span>
				<span class="p">........</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&#34;deprecation&#34;</span><span class="p">)</span>
		<span class="kd">private</span> <span class="nf">void</span> <span class="n">checkpointStreamOperator</span><span class="p">(</span><span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">op</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">op</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// 调用 StreamOperator.snapshotState 方法进行快照
</span><span class="c1"></span>				<span class="c1">// 返回的结果是 runnable future，可能是已经执行完了，也可能没有执行完
</span><span class="c1"></span>				<span class="n">OperatorSnapshotFutures</span> <span class="nf">snapshotInProgress</span> <span class="o">=</span> <span class="n">op</span><span class="p">.</span><span class="na">snapshotState</span><span class="p">(</span>
						<span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span>
						<span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getTimestamp</span><span class="p">(),</span>
						<span class="n">checkpointOptions</span><span class="p">,</span>
						<span class="n">storageLocation</span><span class="p">);</span>
				<span class="n">operatorSnapshotsInProgress</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">op</span><span class="p">.</span><span class="na">getOperatorID</span><span class="p">(),</span> <span class="n">snapshotInProgress</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在同步执行阶段，会依次调用每一个算子的 <code>StreamOperator.snapshotState</code>，返回结果是一个 runnable future。根据 checkpoint 配置成同步模式和异步模式的区别，这个 future 可能处于完成状态，也可能处于未完成状态：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">interface</span> <span class="nf">StreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cm">/**
</span><span class="cm">	 * Called to draw a state snapshot from the operator.
</span><span class="cm">	 *
</span><span class="cm">	 * @return a runnable future to the state handle that points to the snapshotted state. For synchronous implementations,
</span><span class="cm">	 * the runnable might already be finished.
</span><span class="cm">	 *
</span><span class="cm">	 * @throws Exception exception that happened during snapshotting.
</span><span class="cm">	 */</span>
	<span class="n">OperatorSnapshotFutures</span> <span class="nf">snapshotState</span><span class="p">(</span>
		<span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">,</span>
		<span class="kt">long</span> <span class="nf">timestamp</span><span class="p">,</span>
		<span class="n">CheckpointOptions</span> <span class="nf">checkpointOptions</span><span class="p">,</span>
		<span class="n">CheckpointStreamFactory</span> <span class="nf">storageLocation</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">AbstractStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span>
		<span class="nf">implements</span> <span class="n">StreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Serializable</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">final</span> <span class="n">OperatorSnapshotFutures</span> <span class="nf">snapshotState</span><span class="p">(</span><span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">timestamp</span><span class="p">,</span> <span class="n">CheckpointOptions</span> <span class="nf">checkpointOptions</span><span class="p">,</span>
			<span class="n">CheckpointStreamFactory</span> <span class="nf">factory</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="n">KeyGroupRange</span> <span class="nf">keyGroupRange</span> <span class="o">=</span> <span class="kc">null</span> <span class="o">!=</span> <span class="n">keyedStateBackend</span> <span class="o">?</span>
				<span class="n">keyedStateBackend</span><span class="p">.</span><span class="na">getKeyGroupRange</span><span class="p">()</span> <span class="o">:</span> <span class="n">KeyGroupRange</span><span class="p">.</span><span class="na">EMPTY_KEY_GROUP_RANGE</span><span class="p">;</span>

		<span class="n">OperatorSnapshotFutures</span> <span class="nf">snapshotInProgress</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperatorSnapshotFutures</span><span class="p">();</span>

		<span class="k">try</span> <span class="p">(</span><span class="n">StateSnapshotContextSynchronousImpl</span> <span class="nf">snapshotContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateSnapshotContextSynchronousImpl</span><span class="p">(</span>
				<span class="n">checkpointId</span><span class="p">,</span>
				<span class="n">timestamp</span><span class="p">,</span>
				<span class="n">factory</span><span class="p">,</span>
				<span class="n">keyGroupRange</span><span class="p">,</span>
				<span class="n">getContainingTask</span><span class="p">().</span><span class="na">getCancelables</span><span class="p">()))</span> <span class="p">{</span>

			<span class="c1">//对状态进行快照
</span><span class="c1"></span>			<span class="n">snapshotState</span><span class="p">(</span><span class="n">snapshotContext</span><span class="p">);</span>
			<span class="c1">//raw state，要在子类中自己实现 raw state 的快照写入
</span><span class="c1"></span>			<span class="c1">//timer 是作为 raw keyed state 写入的
</span><span class="c1"></span>			<span class="n">snapshotInProgress</span><span class="p">.</span><span class="na">setKeyedStateRawFuture</span><span class="p">(</span><span class="n">snapshotContext</span><span class="p">.</span><span class="na">getKeyedStateStreamFuture</span><span class="p">());</span>
			<span class="n">snapshotInProgress</span><span class="p">.</span><span class="na">setOperatorStateRawFuture</span><span class="p">(</span><span class="n">snapshotContext</span><span class="p">.</span><span class="na">getOperatorStateStreamFuture</span><span class="p">());</span>

			<span class="c1">//写入 managed state 快照
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">operatorStateBackend</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snapshotInProgress</span><span class="p">.</span><span class="na">setOperatorStateManagedFuture</span><span class="p">(</span>
					<span class="n">operatorStateBackend</span><span class="p">.</span><span class="na">snapshot</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="c1">//写入 managed keyed state 快照
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">keyedStateBackend</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snapshotInProgress</span><span class="p">.</span><span class="na">setKeyedStateManagedFuture</span><span class="p">(</span>
					<span class="n">keyedStateBackend</span><span class="p">.</span><span class="na">snapshot</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">snapshotException</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="n">snapshotInProgress</span><span class="p">.</span><span class="na">cancel</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">snapshotException</span><span class="p">.</span><span class="na">addSuppressed</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">String</span> <span class="nf">snapshotFailMessage</span> <span class="o">=</span> <span class="s">&#34;Could not complete snapshot &#34;</span> <span class="o">+</span> <span class="n">checkpointId</span> <span class="o">+</span> <span class="s">&#34; for operator &#34;</span> <span class="o">+</span>
				<span class="n">getOperatorName</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getContainingTask</span><span class="p">().</span><span class="na">isCanceled</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">LOG</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="n">snapshotFailMessage</span><span class="p">,</span> <span class="n">snapshotException</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="n">snapshotFailMessage</span><span class="p">,</span> <span class="n">snapshotException</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">snapshotInProgress</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/**
</span><span class="cm">	 * Stream operators with state, which want to participate in a snapshot need to override this hook method.
</span><span class="cm">	 *
</span><span class="cm">	 * @param context context that provides information and means required for taking a snapshot
</span><span class="cm">	 */</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">snapshotState</span><span class="p">(</span><span class="n">StateSnapshotContext</span> <span class="nf">context</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">KeyedStateBackend</span><span class="o">&lt;?&gt;</span> <span class="n">keyedStateBackend</span> <span class="o">=</span> <span class="n">getKeyedStateBackend</span><span class="p">();</span>
		<span class="c1">//TODO all of this can be removed once heap-based timers are integrated with RocksDB incremental snapshots
</span><span class="c1"></span>		<span class="c1">// 所有的 timer 都作为 raw keyed state 写入
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">keyedStateBackend</span> <span class="nf">instanceof</span> <span class="n">AbstractKeyedStateBackend</span> <span class="o">&amp;&amp;</span>
			<span class="p">((</span><span class="n">AbstractKeyedStateBackend</span><span class="o">&lt;?&gt;</span><span class="p">)</span> <span class="n">keyedStateBackend</span><span class="p">).</span><span class="na">requiresLegacySynchronousTimerSnapshots</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">KeyedStateCheckpointOutputStream</span> <span class="nf">out</span><span class="p">;</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="n">out</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="na">getRawKeyedOperatorStateOutput</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">exception</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;Could not open raw keyed operator state stream for &#34;</span> <span class="o">+</span>
					<span class="n">getOperatorName</span><span class="p">()</span> <span class="o">+</span> <span class="sc">&#39;.&#39;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="n">KeyGroupsList</span> <span class="nf">allKeyGroups</span> <span class="o">=</span> <span class="n">out</span><span class="p">.</span><span class="na">getKeyGroupList</span><span class="p">();</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">keyGroupIdx</span> <span class="o">:</span> <span class="n">allKeyGroups</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">out</span><span class="p">.</span><span class="na">startNewKeyGroup</span><span class="p">(</span><span class="n">keyGroupIdx</span><span class="p">);</span>

					<span class="n">timeServiceManager</span><span class="p">.</span><span class="na">snapshotStateForKeyGroup</span><span class="p">(</span>
						<span class="k">new</span> <span class="n">DataOutputViewStreamWrapper</span><span class="p">(</span><span class="n">out</span><span class="p">),</span> <span class="n">keyGroupIdx</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">exception</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;Could not write timer service of &#34;</span> <span class="o">+</span> <span class="n">getOperatorName</span><span class="p">()</span> <span class="o">+</span>
					<span class="s">&#34; to checkpoint state stream.&#34;</span><span class="p">,</span> <span class="n">exception</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
				<span class="k">try</span> <span class="p">{</span>
					<span class="n">out</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
				<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">closeException</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;Could not close raw keyed operator state stream for {}. This &#34;</span> <span class="o">+</span>
						<span class="s">&#34;might have prevented deleting some state data.&#34;</span><span class="p">,</span> <span class="n">getOperatorName</span><span class="p">(),</span> <span class="n">closeException</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">AbstractUdfStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">F</span> <span class="nf">extends</span> <span class="n">Function</span><span class="o">&gt;</span>
		<span class="nf">extends</span> <span class="n">AbstractStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span>
		<span class="nf">implements</span> <span class="n">OutputTypeConfigurable</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="p">{</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">snapshotState</span><span class="p">(</span><span class="n">StateSnapshotContext</span> <span class="nf">context</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">super</span><span class="p">.</span><span class="na">snapshotState</span><span class="p">(</span><span class="n">context</span><span class="p">);</span> <span class="c1">//先调用父类方法，写入timer
</span><span class="c1"></span>		<span class="c1">//通过反射调用用户函数中的快照操作
</span><span class="c1"></span>		<span class="n">StreamingFunctionUtils</span><span class="p">.</span><span class="na">snapshotFunctionState</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">getOperatorStateBackend</span><span class="p">(),</span> <span class="n">userFunction</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">final</span> <span class="kd">class</span> <span class="nf">StreamingFunctionUtils</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">static</span> <span class="kt">void</span> <span class="nf">snapshotFunctionState</span><span class="p">(</span>
			<span class="n">StateSnapshotContext</span> <span class="nf">context</span><span class="p">,</span>
			<span class="n">OperatorStateBackend</span> <span class="nf">backend</span><span class="p">,</span>
			<span class="n">Function</span> <span class="nf">userFunction</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">trySnapshotFunctionState</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">backend</span><span class="p">,</span> <span class="n">userFunction</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">// inspect if the user function is wrapped, then unwrap and try again if we can snapshot the inner function
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">userFunction</span> <span class="nf">instanceof</span> <span class="n">WrappingFunction</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">userFunction</span> <span class="o">=</span> <span class="p">((</span><span class="n">WrappingFunction</span><span class="o">&lt;?&gt;</span><span class="p">)</span> <span class="n">userFunction</span><span class="p">).</span><span class="na">getWrappedFunction</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">static</span> <span class="kt">boolean</span> <span class="nf">trySnapshotFunctionState</span><span class="p">(</span>
			<span class="n">StateSnapshotContext</span> <span class="nf">context</span><span class="p">,</span>
			<span class="n">OperatorStateBackend</span> <span class="nf">backend</span><span class="p">,</span>
			<span class="n">Function</span> <span class="nf">userFunction</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>

		<span class="c1">// 如果用户函数实现了 CheckpointedFunction 接口，调用 snapshotState 创建快照
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">userFunction</span> <span class="nf">instanceof</span> <span class="n">CheckpointedFunction</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">((</span><span class="n">CheckpointedFunction</span><span class="p">)</span> <span class="n">userFunction</span><span class="p">).</span><span class="na">snapshotState</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
			<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">// 如果用户函数实现了 ListCheckpointed
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">userFunction</span> <span class="nf">instanceof</span> <span class="n">ListCheckpointed</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//先调用 snapshotState 方法获取当前状态
</span><span class="c1"></span>			<span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&#34;unchecked&#34;</span><span class="p">)</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">Serializable</span><span class="o">&gt;</span> <span class="nf">partitionableState</span> <span class="o">=</span> <span class="p">((</span><span class="n">ListCheckpointed</span><span class="o">&lt;</span><span class="n">Serializable</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">userFunction</span><span class="p">).</span>
					<span class="n">snapshotState</span><span class="p">(</span><span class="n">context</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span> <span class="n">context</span><span class="p">.</span><span class="na">getCheckpointTimestamp</span><span class="p">());</span>
			<span class="c1">//获取后端存储的状态的引用
</span><span class="c1"></span>			<span class="n">ListState</span><span class="o">&lt;</span><span class="n">Serializable</span><span class="o">&gt;</span> <span class="nf">listState</span> <span class="o">=</span> <span class="n">backend</span><span class="p">.</span>
					<span class="nf">getSerializableListState</span><span class="p">(</span><span class="n">DefaultOperatorStateBackend</span><span class="p">.</span><span class="na">DEFAULT_OPERATOR_STATE_NAME</span><span class="p">);</span>
			<span class="c1">//清空当前后端存储的 ListState
</span><span class="c1"></span>			<span class="n">listState</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span>

			<span class="c1">//将当前状态依次加入后端存储
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">partitionableState</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">try</span> <span class="p">{</span>
					<span class="k">for</span> <span class="p">(</span><span class="n">Serializable</span> <span class="nf">statePartition</span> <span class="o">:</span> <span class="n">partitionableState</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">listState</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">statePartition</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">listState</span><span class="p">.</span><span class="na">clear</span><span class="p">();</span>

					<span class="k">throw</span> <span class="k">new</span> <span class="n">Exception</span><span class="p">(</span><span class="s">&#34;Could not write partitionable state to operator &#34;</span> <span class="o">+</span>
						<span class="s">&#34;state backend.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>现在我们已经看到 checkpoint 操作是如何同用户自定义函数建立关联的了，接下来我们来看看由 Flink 托管的状态是如何写入存储系统的，即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="n">operatorStateBackend</span><span class="p">.</span><span class="na">snapshot</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">);</span> <span class="c1">//写入 operator state
</span><span class="c1"></span><span class="n">keyedStateBackend</span><span class="p">.</span><span class="na">snapshot</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">,</span> <span class="n">factory</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">);</span> <span class="o">//</span><span class="n">写入</span> <span class="nf">keyed</span> <span class="n">state</span></code></pre></td></tr></table>
</div>
</div>
<p>首先来看看 operator state。<code>DefaultOperatorStateBackend</code> 将实际的工作交给 <code>DefaultOperatorStateBackendSnapshotStrategy</code> 完成。首先，会为对当前注册的所有 operator state（包含 list state 和 broadcast state）做深度拷贝，然后将实际的写入操作封装在一个异步的 FutureTask 中，这个 FutureTask 的主要任务包括： 1）打开输出流 2）写入状态元数据信息 3）写入状态 4）关闭输出流，获得状态句柄。如果不启用异步checkpoint模式，那么这个 FutureTask 在同步阶段就会立刻执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">DefaultOperatorStateBackendSnapshotStrategy</span> <span class="kd">extends</span> <span class="nf">AbstractSnapshotStrategy</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">RunnableFuture</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">snapshot</span><span class="p">(</span>
		<span class="kd">final</span> <span class="nf">long</span> <span class="n">checkpointId</span><span class="p">,</span>
		<span class="kd">final</span> <span class="nf">long</span> <span class="n">timestamp</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="kd">final</span> <span class="nf">CheckpointStreamFactory</span> <span class="n">streamFactory</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="kd">final</span> <span class="nf">CheckpointOptions</span> <span class="n">checkpointOptions</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">registeredOperatorStates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">registeredBroadcastStates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">DoneFuture</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">SnapshotResult</span><span class="p">.</span><span class="na">empty</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="kd">final</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">PartitionableListState</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">registeredOperatorStatesDeepCopies</span> <span class="o">=</span>
			<span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">registeredOperatorStates</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>
		<span class="kd">final</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">BackendWritableBroadcastState</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;&gt;</span> <span class="n">registeredBroadcastStatesDeepCopies</span> <span class="o">=</span>
			<span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">registeredBroadcastStates</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>

		<span class="c1">//获得已注册的所有 list state 和 broadcast state 的深拷贝
</span><span class="c1"></span>		<span class="n">ClassLoader</span> <span class="nf">snapshotClassLoader</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">getContextClassLoader</span><span class="p">();</span>
		<span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">setContextClassLoader</span><span class="p">(</span><span class="n">userClassLoader</span><span class="p">);</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">// eagerly create deep copies of the list and the broadcast states (if any)
</span><span class="c1"></span>			<span class="c1">// in the synchronous phase, so that we can use them in the async writing.
</span><span class="c1"></span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">registeredOperatorStates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">PartitionableListState</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">registeredOperatorStates</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">PartitionableListState</span><span class="o">&lt;?&gt;</span> <span class="n">listState</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
					<span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">listState</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">listState</span> <span class="o">=</span> <span class="n">listState</span><span class="p">.</span><span class="na">deepCopy</span><span class="p">();</span>
					<span class="p">}</span>
					<span class="n">registeredOperatorStatesDeepCopies</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">(),</span> <span class="n">listState</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">registeredBroadcastStates</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">BackendWritableBroadcastState</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">registeredBroadcastStates</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">BackendWritableBroadcastState</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="n">broadcastState</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
					<span class="k">if</span> <span class="p">(</span><span class="kc">null</span> <span class="o">!=</span> <span class="n">broadcastState</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">broadcastState</span> <span class="o">=</span> <span class="n">broadcastState</span><span class="p">.</span><span class="na">deepCopy</span><span class="p">();</span>
					<span class="p">}</span>
					<span class="n">registeredBroadcastStatesDeepCopies</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">(),</span> <span class="n">broadcastState</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
			<span class="n">Thread</span><span class="p">.</span><span class="na">currentThread</span><span class="p">().</span><span class="na">setContextClassLoader</span><span class="p">(</span><span class="n">snapshotClassLoader</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">//将主要写入操作封装为一个异步的FutureTask
</span><span class="c1"></span>		<span class="n">AsyncSnapshotCallable</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">snapshotCallable</span> <span class="o">=</span>
			<span class="k">new</span> <span class="n">AsyncSnapshotCallable</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span><span class="p">()</span> <span class="p">{</span>

				<span class="nd">@Override</span>
				<span class="kd">protected</span> <span class="nf">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="nf">callInternal</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>

					<span class="c1">// 创建状态输出流
</span><span class="c1"></span>					<span class="n">CheckpointStreamFactory</span><span class="p">.</span><span class="na">CheckpointStateOutputStream</span> <span class="nf">localOut</span> <span class="o">=</span>
						<span class="n">streamFactory</span><span class="p">.</span><span class="na">createCheckpointStateOutputStream</span><span class="p">(</span><span class="n">CheckpointedStateScope</span><span class="p">.</span><span class="na">EXCLUSIVE</span><span class="p">);</span>
					<span class="n">snapshotCloseableRegistry</span><span class="p">.</span><span class="na">registerCloseable</span><span class="p">(</span><span class="n">localOut</span><span class="p">);</span>

					<span class="c1">// 收集元数据
</span><span class="c1"></span>					<span class="c1">// get the registered operator state infos ...
</span><span class="c1"></span>					<span class="n">List</span><span class="o">&lt;</span><span class="n">StateMetaInfoSnapshot</span><span class="o">&gt;</span> <span class="nf">operatorMetaInfoSnapshots</span> <span class="o">=</span>
						<span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">registeredOperatorStatesDeepCopies</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>

					<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">PartitionableListState</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span>
						<span class="n">registeredOperatorStatesDeepCopies</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
						<span class="n">operatorMetaInfoSnapshots</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">().</span><span class="na">getStateMetaInfo</span><span class="p">().</span><span class="na">snapshot</span><span class="p">());</span>
					<span class="p">}</span>

					<span class="c1">// ... get the registered broadcast operator state infos ...
</span><span class="c1"></span>					<span class="n">List</span><span class="o">&lt;</span><span class="n">StateMetaInfoSnapshot</span><span class="o">&gt;</span> <span class="nf">broadcastMetaInfoSnapshots</span> <span class="o">=</span>
						<span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">registeredBroadcastStatesDeepCopies</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>

					<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">BackendWritableBroadcastState</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span>
						<span class="n">registeredBroadcastStatesDeepCopies</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
						<span class="n">broadcastMetaInfoSnapshots</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">().</span><span class="na">getStateMetaInfo</span><span class="p">().</span><span class="na">snapshot</span><span class="p">());</span>
					<span class="p">}</span>

					<span class="c1">// 写入元数据
</span><span class="c1"></span>					<span class="c1">// ... write them all in the checkpoint stream ...
</span><span class="c1"></span>					<span class="n">DataOutputView</span> <span class="nf">dov</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataOutputViewStreamWrapper</span><span class="p">(</span><span class="n">localOut</span><span class="p">);</span>

					<span class="n">OperatorBackendSerializationProxy</span> <span class="nf">backendSerializationProxy</span> <span class="o">=</span>
						<span class="k">new</span> <span class="n">OperatorBackendSerializationProxy</span><span class="p">(</span><span class="n">operatorMetaInfoSnapshots</span><span class="p">,</span> <span class="n">broadcastMetaInfoSnapshots</span><span class="p">);</span>

					<span class="n">backendSerializationProxy</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">dov</span><span class="p">);</span>

					<span class="c1">// ... and then go for the states ...
</span><span class="c1"></span>
					<span class="c1">// 写入状态
</span><span class="c1"></span>					<span class="c1">// we put BOTH normal and broadcast state metadata here
</span><span class="c1"></span>					<span class="kt">int</span> <span class="nf">initialMapCapacity</span> <span class="o">=</span>
						<span class="n">registeredOperatorStatesDeepCopies</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">registeredBroadcastStatesDeepCopies</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
					<span class="kd">final</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">OperatorStateHandle</span><span class="p">.</span><span class="na">StateMetaInfo</span><span class="o">&gt;</span> <span class="nf">writtenStatesMetaData</span> <span class="o">=</span>
						<span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">initialMapCapacity</span><span class="p">);</span>

					<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">PartitionableListState</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span>
						<span class="n">registeredOperatorStatesDeepCopies</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>

						<span class="n">PartitionableListState</span><span class="o">&lt;?&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
						<span class="kt">long</span><span class="p">[]</span> <span class="nf">partitionOffsets</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">localOut</span><span class="p">);</span>
						<span class="n">OperatorStateHandle</span><span class="p">.</span><span class="na">Mode</span> <span class="nf">mode</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="na">getStateMetaInfo</span><span class="p">().</span><span class="na">getAssignmentMode</span><span class="p">();</span>
						<span class="n">writtenStatesMetaData</span><span class="p">.</span><span class="na">put</span><span class="p">(</span>
							<span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">(),</span>
							<span class="k">new</span> <span class="n">OperatorStateHandle</span><span class="p">.</span><span class="na">StateMetaInfo</span><span class="p">(</span><span class="n">partitionOffsets</span><span class="p">,</span> <span class="n">mode</span><span class="p">));</span>
					<span class="p">}</span>

					<span class="c1">// ... and the broadcast states themselves ...
</span><span class="c1"></span>					<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">BackendWritableBroadcastState</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;&gt;</span> <span class="n">entry</span> <span class="o">:</span>
						<span class="n">registeredBroadcastStatesDeepCopies</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>

						<span class="n">BackendWritableBroadcastState</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="n">value</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
						<span class="kt">long</span><span class="p">[]</span> <span class="nf">partitionOffsets</span> <span class="o">=</span> <span class="p">{</span><span class="n">value</span><span class="p">.</span><span class="na">write</span><span class="p">(</span><span class="n">localOut</span><span class="p">)};</span>
						<span class="n">OperatorStateHandle</span><span class="p">.</span><span class="na">Mode</span> <span class="nf">mode</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="na">getStateMetaInfo</span><span class="p">().</span><span class="na">getAssignmentMode</span><span class="p">();</span>
						<span class="n">writtenStatesMetaData</span><span class="p">.</span><span class="na">put</span><span class="p">(</span>
							<span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">(),</span>
							<span class="k">new</span> <span class="n">OperatorStateHandle</span><span class="p">.</span><span class="na">StateMetaInfo</span><span class="p">(</span><span class="n">partitionOffsets</span><span class="p">,</span> <span class="n">mode</span><span class="p">));</span>
					<span class="p">}</span>

					<span class="c1">// ... and, finally, create the state handle.
</span><span class="c1"></span>					<span class="n">OperatorStateHandle</span> <span class="nf">retValue</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">snapshotCloseableRegistry</span><span class="p">.</span><span class="na">unregisterCloseable</span><span class="p">(</span><span class="n">localOut</span><span class="p">))</span> <span class="p">{</span>

						<span class="c1">//关闭输出流，获得状态句柄，后面可以用这个句柄读取状态
</span><span class="c1"></span>						<span class="n">StreamStateHandle</span> <span class="nf">stateHandle</span> <span class="o">=</span> <span class="n">localOut</span><span class="p">.</span><span class="na">closeAndGetHandle</span><span class="p">();</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">stateHandle</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">retValue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperatorStreamStateHandle</span><span class="p">(</span><span class="n">writtenStatesMetaData</span><span class="p">,</span> <span class="n">stateHandle</span><span class="p">);</span>
						<span class="p">}</span>

						<span class="k">return</span> <span class="n">SnapshotResult</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">retValue</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="p">(</span><span class="s">&#34;Stream was already unregistered.&#34;</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="nd">@Override</span>
				<span class="kd">protected</span> <span class="nf">void</span> <span class="n">cleanupProvidedResources</span><span class="p">()</span> <span class="p">{</span>
					<span class="c1">// nothing to do
</span><span class="c1"></span>				<span class="p">}</span>

				<span class="nd">@Override</span>
				<span class="kd">protected</span> <span class="nf">void</span> <span class="n">logAsyncSnapshotComplete</span><span class="p">(</span><span class="kt">long</span> <span class="nf">startTime</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">asynchronousSnapshots</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">logAsyncCompleted</span><span class="p">(</span><span class="n">streamFactory</span><span class="p">,</span> <span class="n">startTime</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">};</span>

		<span class="kd">final</span> <span class="nf">FutureTask</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">task</span> <span class="o">=</span>
			<span class="n">snapshotCallable</span><span class="p">.</span><span class="na">toAsyncSnapshotFutureTask</span><span class="p">(</span><span class="n">closeStreamOnCancelRegistry</span><span class="p">);</span>

		<span class="c1">//如果不是异步 checkpoint 那么在这里直接运行 FutureTask，即在同步阶段就完成了状态的写入
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">asynchronousSnapshots</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">task</span><span class="p">.</span><span class="na">run</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">task</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>keyed state 写入的基本流程与此相似，但由于 keyed state 在存储时有多种实现，包括基于堆内存和 RocksDB 的不同实现，此外基于 RocksDB 的实现还包括支持<a href="https://flink.apache.org/features/2018/01/30/incremental-checkpointing.html">增量 checkpoint</a>，因而相比于 operator state 要更复杂一些。另外，Flink 自 1.5.0 版本还引入了一个<a href="https://issues.apache.org/jira/browse/FLINK-8360">本地状态存储</a>的优化，支持在 TaskManager 的本地保存一份 keyed state，试图优化状态恢复的速度和网络开销。</p>

<p>至此，我们介绍了快照操作的第一个阶段，即同步执行的阶段。异步执行阶段被封装为 <code>AsyncCheckpointRunnable</code>，主要的操作包括 1）执行同步阶段创建的 FutureTask 2）完成后向 CheckpointCoordinator 发送 Ack 响应。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">StreamTask</span> <span class="p">{</span>
	<span class="kd">protected</span> <span class="nf">static</span> <span class="kd">final</span> <span class="nf">class</span> <span class="n">AsyncCheckpointRunnable</span> <span class="nf">implements</span> <span class="n">Runnable</span><span class="p">,</span> <span class="n">Closeable</span> <span class="p">{</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="nf">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
			<span class="n">FileSystemSafetyNet</span><span class="p">.</span><span class="na">initializeSafetyNetForThread</span><span class="p">();</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="n">TaskStateSnapshot</span> <span class="nf">jobManagerTaskOperatorSubtaskStates</span> <span class="o">=</span>
					<span class="k">new</span> <span class="n">TaskStateSnapshot</span><span class="p">(</span><span class="n">operatorSnapshotsInProgress</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>
				<span class="n">TaskStateSnapshot</span> <span class="nf">localTaskOperatorSubtaskStates</span> <span class="o">=</span>
					<span class="k">new</span> <span class="n">TaskStateSnapshot</span><span class="p">(</span><span class="n">operatorSnapshotsInProgress</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>

				<span class="c1">// 完成每一个 operator 的状态写入
</span><span class="c1"></span>				<span class="c1">// 如果是同步 checkpoint，那么在此之前状态已经写入完成
</span><span class="c1"></span>				<span class="c1">// 如果是异步 checkpoint，那么在这里才会写入状态
</span><span class="c1"></span>				<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="p">.</span><span class="na">Entry</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="p">,</span> <span class="n">OperatorSnapshotFutures</span><span class="o">&gt;</span> <span class="nf">entry</span> <span class="o">:</span> <span class="n">operatorSnapshotsInProgress</span><span class="p">.</span><span class="na">entrySet</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">OperatorID</span> <span class="nf">operatorID</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getKey</span><span class="p">();</span>
					<span class="n">OperatorSnapshotFutures</span> <span class="nf">snapshotInProgress</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="na">getValue</span><span class="p">();</span>
					<span class="c1">// finalize the async part of all by executing all snapshot runnables
</span><span class="c1"></span>					<span class="n">OperatorSnapshotFinalizer</span> <span class="nf">finalizedSnapshots</span> <span class="o">=</span>
						<span class="k">new</span> <span class="n">OperatorSnapshotFinalizer</span><span class="p">(</span><span class="n">snapshotInProgress</span><span class="p">);</span>

					<span class="n">jobManagerTaskOperatorSubtaskStates</span><span class="p">.</span><span class="na">putSubtaskStateByOperatorID</span><span class="p">(</span>
						<span class="n">operatorID</span><span class="p">,</span>
						<span class="n">finalizedSnapshots</span><span class="p">.</span><span class="na">getJobManagerOwnedState</span><span class="p">());</span>

					<span class="n">localTaskOperatorSubtaskStates</span><span class="p">.</span><span class="na">putSubtaskStateByOperatorID</span><span class="p">(</span>
						<span class="n">operatorID</span><span class="p">,</span>
						<span class="n">finalizedSnapshots</span><span class="p">.</span><span class="na">getTaskLocalState</span><span class="p">());</span>
				<span class="p">}</span>

				<span class="kd">final</span> <span class="nf">long</span> <span class="n">asyncEndNanos</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">nanoTime</span><span class="p">();</span>
				<span class="kd">final</span> <span class="nf">long</span> <span class="n">asyncDurationMillis</span> <span class="o">=</span> <span class="p">(</span><span class="n">asyncEndNanos</span> <span class="o">-</span> <span class="n">asyncStartNanos</span><span class="p">)</span> <span class="o">/</span> <span class="n">1_000_000L</span><span class="p">;</span>

				<span class="n">checkpointMetrics</span><span class="p">.</span><span class="na">setAsyncDurationMillis</span><span class="p">(</span><span class="n">asyncDurationMillis</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">asyncCheckpointState</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="n">CheckpointingOperation</span><span class="p">.</span><span class="na">AsyncCheckpointState</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">,</span>
					<span class="n">CheckpointingOperation</span><span class="p">.</span><span class="na">AsyncCheckpointState</span><span class="p">.</span><span class="na">COMPLETED</span><span class="p">))</span> <span class="p">{</span>
					<span class="c1">//报告 snapshot 完成
</span><span class="c1"></span>					<span class="n">reportCompletedSnapshotStates</span><span class="p">(</span>
						<span class="n">jobManagerTaskOperatorSubtaskStates</span><span class="p">,</span>
						<span class="n">localTaskOperatorSubtaskStates</span><span class="p">,</span>
						<span class="n">asyncDurationMillis</span><span class="p">);</span>

				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;{} - asynchronous part of checkpoint {} could not be completed because it was closed before.&#34;</span><span class="p">,</span>
						<span class="n">owner</span><span class="p">.</span><span class="na">getName</span><span class="p">(),</span>
						<span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">());</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">handleExecutionException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
				<span class="n">owner</span><span class="p">.</span><span class="na">cancelables</span><span class="p">.</span><span class="na">unregisterCloseable</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
				<span class="n">FileSystemSafetyNet</span><span class="p">.</span><span class="na">closeSafetyNetAndGuardedResourcesForThread</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">reportCompletedSnapshotStates</span><span class="p">(</span>
			<span class="n">TaskStateSnapshot</span> <span class="nf">acknowledgedTaskStateSnapshot</span><span class="p">,</span>
			<span class="n">TaskStateSnapshot</span> <span class="nf">localTaskStateSnapshot</span><span class="p">,</span>
			<span class="kt">long</span> <span class="nf">asyncDurationMillis</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">TaskStateManager</span> <span class="nf">taskStateManager</span> <span class="o">=</span> <span class="n">owner</span><span class="p">.</span><span class="na">getEnvironment</span><span class="p">().</span><span class="na">getTaskStateManager</span><span class="p">();</span>
			<span class="kt">boolean</span> <span class="nf">hasAckState</span> <span class="o">=</span> <span class="n">acknowledgedTaskStateSnapshot</span><span class="p">.</span><span class="na">hasState</span><span class="p">();</span>
			<span class="kt">boolean</span> <span class="nf">hasLocalState</span> <span class="o">=</span> <span class="n">localTaskStateSnapshot</span><span class="p">.</span><span class="na">hasState</span><span class="p">();</span>
			<span class="c1">// we signal stateless tasks by reporting null, so that there are no attempts to assign empty state
</span><span class="c1"></span>			<span class="c1">// to stateless tasks on restore. This enables simple job modifications that only concern
</span><span class="c1"></span>			<span class="c1">// stateless without the need to assign them uids to match their (always empty) states.
</span><span class="c1"></span>			<span class="n">taskStateManager</span><span class="p">.</span><span class="na">reportTaskStateSnapshots</span><span class="p">(</span>
				<span class="n">checkpointMetaData</span><span class="p">,</span>
				<span class="n">checkpointMetrics</span><span class="p">,</span>
				<span class="n">hasAckState</span> <span class="o">?</span> <span class="n">acknowledgedTaskStateSnapshot</span> <span class="o">:</span> <span class="kc">null</span><span class="p">,</span>
				<span class="n">hasLocalState</span> <span class="o">?</span> <span class="n">localTaskStateSnapshot</span> <span class="o">:</span> <span class="kc">null</span><span class="p">);</span>
		<span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">class</span> <span class="n">TaskStateManagerImpl</span> <span class="nf">implements</span> <span class="n">TaskStateManager</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">reportTaskStateSnapshots</span><span class="p">(</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointMetaData</span> <span class="nf">checkpointMetaData</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointMetrics</span> <span class="nf">checkpointMetrics</span><span class="p">,</span>
		<span class="nd">@Nullable</span> <span class="n">TaskStateSnapshot</span> <span class="nf">acknowledgedState</span><span class="p">,</span>
		<span class="nd">@Nullable</span> <span class="n">TaskStateSnapshot</span> <span class="nf">localState</span><span class="p">)</span> <span class="p">{</span>

		<span class="kt">long</span> <span class="nf">checkpointId</span> <span class="o">=</span> <span class="n">checkpointMetaData</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">();</span>

		<span class="n">localStateStore</span><span class="p">.</span><span class="na">storeLocalState</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">,</span> <span class="n">localState</span><span class="p">);</span>

		<span class="c1">//发送 ACK 响应给 CheckpointCoordinator
</span><span class="c1"></span>		<span class="n">checkpointResponder</span><span class="p">.</span><span class="na">acknowledgeCheckpoint</span><span class="p">(</span>
			<span class="n">jobId</span><span class="p">,</span>
			<span class="n">executionAttemptID</span><span class="p">,</span>
			<span class="n">checkpointId</span><span class="p">,</span>
			<span class="n">checkpointMetrics</span><span class="p">,</span>
			<span class="n">acknowledgedState</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="本地状态存储">本地状态存储</h3>

<p>所谓本地状态存储，即在存储检查点快照时，在 <code>Task</code> 所在的 TaskManager 本地文件系统中存储一份副本，这样在进行状态恢复时可以优先从本地状态进行恢复，从而减少网络数据传输的开销。本地状态存储仅针对 keyed state，我们以较为简单的 <code>HeapKeyedStateBackend</code> 为例，看看本地状态存储时如何实现的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">HeapSnapshotStrategy</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span>
	<span class="nf">extends</span> <span class="n">AbstractSnapshotStrategy</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span> <span class="nf">implements</span> <span class="n">SnapshotStrategySynchronicityBehavior</span><span class="o">&lt;</span><span class="n">K</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">@Nonnull</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">RunnableFuture</span><span class="o">&lt;</span><span class="n">SnapshotResult</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">snapshot</span><span class="p">(</span>
		<span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">,</span>
		<span class="kt">long</span> <span class="nf">timestamp</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointStreamFactory</span> <span class="nf">primaryStreamFactory</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointOptions</span> <span class="nf">checkpointOptions</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>

		<span class="p">......</span>

		<span class="c1">//创建 CheckpointStreamWithResultProvider
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">SupplierWithException</span><span class="o">&lt;</span><span class="n">CheckpointStreamWithResultProvider</span><span class="p">,</span> <span class="n">Exception</span><span class="o">&gt;</span> <span class="nf">checkpointStreamSupplier</span> <span class="o">=</span>

			<span class="n">localRecoveryConfig</span><span class="p">.</span><span class="na">isLocalRecoveryEnabled</span><span class="p">()</span> <span class="o">?</span>

				<span class="p">()</span> <span class="o">-&gt;</span> <span class="n">CheckpointStreamWithResultProvider</span><span class="p">.</span><span class="na">createDuplicatingStream</span><span class="p">(</span>
					<span class="n">checkpointId</span><span class="p">,</span>
					<span class="n">CheckpointedStateScope</span><span class="p">.</span><span class="na">EXCLUSIVE</span><span class="p">,</span>
					<span class="n">primaryStreamFactory</span><span class="p">,</span>
					<span class="n">localRecoveryConfig</span><span class="p">.</span><span class="na">getLocalStateDirectoryProvider</span><span class="p">())</span> <span class="o">:</span>

				<span class="p">()</span> <span class="o">-&gt;</span> <span class="n">CheckpointStreamWithResultProvider</span><span class="p">.</span><span class="na">createSimpleStream</span><span class="p">(</span>
					<span class="n">CheckpointedStateScope</span><span class="p">.</span><span class="na">EXCLUSIVE</span><span class="p">,</span>
					<span class="n">primaryStreamFactory</span><span class="p">);</span>

		<span class="p">........</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>其中关键的一点在于，根据是否启用本地状态恢复创建不同的 <code>CheckpointStreamWithResultProvider</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">CheckpointStreamWithResultProvider</span> <span class="nf">extends</span> <span class="n">Closeable</span> <span class="p">{</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">static</span> <span class="nf">CheckpointStreamWithResultProvider</span> <span class="n">createSimpleStream</span><span class="p">(</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointedStateScope</span> <span class="nf">checkpointedStateScope</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointStreamFactory</span> <span class="nf">primaryStreamFactory</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>

		<span class="n">CheckpointStreamFactory</span><span class="p">.</span><span class="na">CheckpointStateOutputStream</span> <span class="nf">primaryOut</span> <span class="o">=</span>
			<span class="n">primaryStreamFactory</span><span class="p">.</span><span class="na">createCheckpointStateOutputStream</span><span class="p">(</span><span class="n">checkpointedStateScope</span><span class="p">);</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">CheckpointStreamWithResultProvider</span><span class="p">.</span><span class="na">PrimaryStreamOnly</span><span class="p">(</span><span class="n">primaryOut</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Nonnull</span>
	<span class="kd">static</span> <span class="nf">CheckpointStreamWithResultProvider</span> <span class="n">createDuplicatingStream</span><span class="p">(</span>
		<span class="nd">@Nonnegative</span> <span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointedStateScope</span> <span class="nf">checkpointedStateScope</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CheckpointStreamFactory</span> <span class="nf">primaryStreamFactory</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">LocalRecoveryDirectoryProvider</span> <span class="nf">secondaryStreamDirProvider</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>

		<span class="n">CheckpointStreamFactory</span><span class="p">.</span><span class="na">CheckpointStateOutputStream</span> <span class="nf">primaryOut</span> <span class="o">=</span>
			<span class="n">primaryStreamFactory</span><span class="p">.</span><span class="na">createCheckpointStateOutputStream</span><span class="p">(</span><span class="n">checkpointedStateScope</span><span class="p">);</span>

		<span class="k">try</span> <span class="p">{</span>
			<span class="n">File</span> <span class="nf">outFile</span> <span class="o">=</span> <span class="k">new</span> <span class="n">File</span><span class="p">(</span>
				<span class="n">secondaryStreamDirProvider</span><span class="p">.</span><span class="na">subtaskSpecificCheckpointDirectory</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">),</span>
				<span class="n">String</span><span class="p">.</span><span class="na">valueOf</span><span class="p">(</span><span class="n">UUID</span><span class="p">.</span><span class="na">randomUUID</span><span class="p">()));</span>
			<span class="n">Path</span> <span class="nf">outPath</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Path</span><span class="p">(</span><span class="n">outFile</span><span class="p">.</span><span class="na">toURI</span><span class="p">());</span>

			<span class="n">CheckpointStreamFactory</span><span class="p">.</span><span class="na">CheckpointStateOutputStream</span> <span class="nf">secondaryOut</span> <span class="o">=</span>
				<span class="k">new</span> <span class="n">FileBasedStateOutputStream</span><span class="p">(</span><span class="n">outPath</span><span class="p">.</span><span class="na">getFileSystem</span><span class="p">(),</span> <span class="n">outPath</span><span class="p">);</span>
			<span class="c1">//有两个输出流，primary 和 secondary，secondary 对应本地存储
</span><span class="c1"></span>			<span class="k">return</span> <span class="k">new</span> <span class="n">CheckpointStreamWithResultProvider</span><span class="p">.</span><span class="na">PrimaryAndSecondaryStream</span><span class="p">(</span><span class="n">primaryOut</span><span class="p">,</span> <span class="n">secondaryOut</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="nf">secondaryEx</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;Exception when opening secondary/local checkpoint output stream. &#34;</span> <span class="o">+</span>
				<span class="s">&#34;Continue only with the primary stream.&#34;</span><span class="p">,</span> <span class="n">secondaryEx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">CheckpointStreamWithResultProvider</span><span class="p">.</span><span class="na">PrimaryStreamOnly</span><span class="p">(</span><span class="n">primaryOut</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>所以在启用本地状态存储的情况下，会创建两个输出流，其中 <code>primaryOut</code> 对应外部存储，而 <code>secondaryOut</code> 对应本地存储。状态会输出两份。本地状态句柄会存储在 <code>TaskLocalStateStore</code> 中。</p>

<h2 id="对-checkpoint-的确认">对 Checkpoint 的确认</h2>

<p><code>Task</code> 对 checkpoint 的响应是通过 <code>CheckpointResponder</code> 接口完成的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">CheckpointResponder</span> <span class="p">{</span>

	<span class="cm">/**
</span><span class="cm">	 * Acknowledges the given checkpoint.
</span><span class="cm">	 */</span>
	<span class="kt">void</span> <span class="nf">acknowledgeCheckpoint</span><span class="p">(</span>
		<span class="n">JobID</span> <span class="nf">jobID</span><span class="p">,</span>
		<span class="n">ExecutionAttemptID</span> <span class="nf">executionAttemptID</span><span class="p">,</span>
		<span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">,</span>
		<span class="n">CheckpointMetrics</span> <span class="nf">checkpointMetrics</span><span class="p">,</span>
		<span class="n">TaskStateSnapshot</span> <span class="nf">subtaskState</span><span class="p">);</span>

	<span class="cm">/**
</span><span class="cm">	 * Declines the given checkpoint.
</span><span class="cm">	 */</span>
	<span class="kt">void</span> <span class="nf">declineCheckpoint</span><span class="p">(</span>
		<span class="n">JobID</span> <span class="nf">jobID</span><span class="p">,</span>
		<span class="n">ExecutionAttemptID</span> <span class="nf">executionAttemptID</span><span class="p">,</span>
		<span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">,</span>
		<span class="n">Throwable</span> <span class="nf">cause</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>RpcCheckpointResponder</code> 作为 <code>CheckpointResponder</code> 的具体实现，主要是通过 RPC 调用通知 <code>CheckpointCoordinatorGateway</code>，即通知给 <code>JobMaster</code>, <code>JobMaster</code> 调用 <code>CheckpointCoordinator.receiveAcknowledgeMessage()</code> 和 <code>CheckpointCoordinator.receiveDeclineMessage()</code> 进行处理。</p>

<h3 id="确认完成">确认完成</h3>

<p>在一个 <code>Task</code> 完成 checkpoint 操作后，<code>CheckpointCoordinator</code> 接收到 Ack 响应，对 Ack 响应的处理流程主要如下：</p>

<ul>
<li>根据 Ack 的 checkpointID 从 <code>Map&lt;Long, PendingCheckpoint&gt; pendingCheckpoints</code> 中查找对应的 <code>PendingCheckpoint</code></li>
<li>若存在对应的 <code>PendingCheckpoint</code>

<ul>
<li>这个 <code>PendingCheckpoint</code> 没有被丢弃，调用 <code>PendingCheckpoint.acknowledgeTask</code> 方法处理 Ack，根据处理结果的不同：

<ul>
<li>SUCCESS：判断是否已经接受了所有需要响应的 Ack，如果是，则调用 <code>completePendingCheckpoint</code> 完成此次 checkpoint</li>
<li>DUPLICATE：Ack 消息重复接收，直接忽略</li>
<li>UNKNOWN：未知的 Ack 消息，清理上报的 Ack 中携带的状态句柄</li>
<li>DISCARD：Checkpoint 已经被 discard，清理上报的 Ack 中携带的状态句柄</li>
</ul></li>
<li>这个 <code>PendingCheckpoint</code> 已经被丢弃，抛出异常</li>
</ul></li>
<li>若不存在对应的 <code>PendingCheckpoint</code>，则清理上报的 Ack 中携带的状态句柄</li>
</ul>

<p>相应的代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">CheckpointCoordinator</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">receiveAcknowledgeMessage</span><span class="p">(</span><span class="n">AcknowledgeCheckpoint</span> <span class="nf">message</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">CheckpointException</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span> <span class="o">||</span> <span class="n">message</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">job</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">LOG</span><span class="p">.</span><span class="na">error</span><span class="p">(</span><span class="s">&#34;Received wrong AcknowledgeCheckpoint message for job {}: {}&#34;</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
			<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="kd">final</span> <span class="nf">long</span> <span class="n">checkpointId</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">();</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// we need to check inside the lock for being shutdown as well, otherwise we
</span><span class="c1"></span>			<span class="c1">// get races and invalid error log messages
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kd">final</span> <span class="nf">PendingCheckpoint</span> <span class="n">checkpoint</span> <span class="o">=</span> <span class="n">pendingCheckpoints</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">checkpoint</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkpoint</span><span class="p">.</span><span class="na">isDiscarded</span><span class="p">())</span> <span class="p">{</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">checkpoint</span><span class="p">.</span><span class="na">acknowledgeTask</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getSubtaskState</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointMetrics</span><span class="p">()))</span> <span class="p">{</span>
					<span class="k">case</span> <span class="n">SUCCESS</span><span class="o">:</span>
						<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Received acknowledge message for checkpoint {} from task {} of job {}.&#34;</span><span class="p">,</span>
							<span class="n">checkpointId</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">());</span>

						<span class="k">if</span> <span class="p">(</span><span class="n">checkpoint</span><span class="p">.</span><span class="na">isFullyAcknowledged</span><span class="p">())</span> <span class="p">{</span>
							<span class="n">completePendingCheckpoint</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">);</span>
						<span class="p">}</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="k">case</span> <span class="n">DUPLICATE</span><span class="o">:</span>
						<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Received a duplicate acknowledge message for checkpoint {}, task {}, job {}.&#34;</span><span class="p">,</span>
							<span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">());</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="k">case</span> <span class="n">UNKNOWN</span><span class="o">:</span>
						<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;Could not acknowledge the checkpoint {} for task {} of job {}, &#34;</span> <span class="o">+</span>
								<span class="s">&#34;because the task&#39;s execution attempt id was unknown. Discarding &#34;</span> <span class="o">+</span>
								<span class="s">&#34;the state handle to avoid lingering state.&#34;</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span>
							<span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">());</span>

						<span class="n">discardSubtaskState</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getSubtaskState</span><span class="p">());</span>

						<span class="k">break</span><span class="p">;</span>
					<span class="k">case</span> <span class="n">DISCARDED</span><span class="o">:</span>
						<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;Could not acknowledge the checkpoint {} for task {} of job {}, &#34;</span> <span class="o">+</span>
							<span class="s">&#34;because the pending checkpoint had been discarded. Discarding the &#34;</span> <span class="o">+</span>
								<span class="s">&#34;state handle tp avoid lingering state.&#34;</span><span class="p">,</span>
							<span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">());</span>

						<span class="n">discardSubtaskState</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getSubtaskState</span><span class="p">());</span>
				<span class="p">}</span>

				<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">checkpoint</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// this should not happen
</span><span class="c1"></span>				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span>
						<span class="s">&#34;Received message for discarded but non-removed checkpoint &#34;</span> <span class="o">+</span> <span class="n">checkpointId</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="kt">boolean</span> <span class="nf">wasPendingCheckpoint</span><span class="p">;</span>
				<span class="c1">// message is for an unknown checkpoint, or comes too late (checkpoint disposed)
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">recentPendingCheckpoints</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">wasPendingCheckpoint</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
					<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;Received late message for now expired checkpoint attempt {} from &#34;</span> <span class="o">+</span>
						<span class="s">&#34;{} of job {}.&#34;</span><span class="p">,</span> <span class="n">checkpointId</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">());</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Received message for an unknown checkpoint {} from {} of job {}.&#34;</span><span class="p">,</span>
						<span class="n">checkpointId</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">());</span>
					<span class="n">wasPendingCheckpoint</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="c1">// try to discard the state so that we don&#39;t have lingering state lying around
</span><span class="c1"></span>				<span class="n">discardSubtaskState</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">(),</span> <span class="n">message</span><span class="p">.</span><span class="na">getSubtaskState</span><span class="p">());</span>

				<span class="k">return</span> <span class="n">wasPendingCheckpoint</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>对于一个已经触发但还没有完成的 checkpoint，即 <code>PendingCheckpoint</code>，它是如何处理 Ack 消息的呢？在 <code>PendingCheckpoint</code> 内部维护了两个 Map，分别是：</p>

<ul>
<li><code>Map&lt;OperatorID, OperatorState&gt; operatorStates;</code> : 已经接收到 Ack 的算子的状态句柄</li>
<li><code>Map&lt;ExecutionAttemptID, ExecutionVertex&gt; notYetAcknowledgedTasks;</code>: 需要 Ack 但还没有接收到的 Task</li>
</ul>

<p>每当接收到一个 Ack 消息时，<code>PendingCheckpoint</code> 就从 <code>notYetAcknowledgedTasks</code> 中移除对应的 Task，并保存 Ack 携带的状态句柄保存。当 <code>notYetAcknowledgedTasks</code> 为空时，表明所有的 Ack 消息都接收到了。</p>

<p>其中 <code>OperatorState</code> 是算子状态句柄的一层封装：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">OperatorState</span> <span class="kd">implements</span> <span class="nf">CompositeStateHandle</span> <span class="p">{</span>
	<span class="cm">/** handles to non-partitioned states, subtaskindex -&gt; subtaskstate */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">OperatorSubtaskState</span><span class="o">&gt;</span> <span class="nf">operatorSubtaskStates</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">class</span> <span class="n">OperatorSubtaskState</span> <span class="nf">implements</span> <span class="n">CompositeStateHandle</span> <span class="p">{</span>
	<span class="cm">/** Snapshot from the {@link org.apache.flink.runtime.state.OperatorStateBackend}. */</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="nf">managedOperatorState</span><span class="p">;</span>

	<span class="cm">/** Snapshot written using {@link org.apache.flink.runtime.state.OperatorStateCheckpointOutputStream}. */</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;</span> <span class="nf">rawOperatorState</span><span class="p">;</span>

	<span class="cm">/** Snapshot from {@link org.apache.flink.runtime.state.KeyedStateBackend}. */</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span> <span class="nf">managedKeyedState</span><span class="p">;</span>

	<span class="cm">/** Snapshot written using {@link org.apache.flink.runtime.state.KeyedStateCheckpointOutputStream}. */</span>
	<span class="nd">@Nonnull</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;</span> <span class="nf">rawKeyedState</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>一旦 <code>PendingCheckpoint</code> 确认所有 Ack 消息都已经接收，那么就可以完成此次 checkpoint 了，具体包括：</p>

<ul>
<li>调用 <code>PendingCheckpoint.finalizeCheckpoint()</code> 将 <code>PendingCheckpoint</code> 转化为 <code>CompletedCheckpoint</code>

<ul>
<li>获取 <code>CheckpointMetadataOutputStream</code>，将所有的状态句柄信息通过 <code>CheckpointMetadataOutputStream</code> 写入到存储系统中</li>
<li>创建一个 <code>CompletedCheckpoint</code> 对象</li>
</ul></li>
<li>将 <code>CompletedCheckpoint</code> 保存到 <code>CompletedCheckpointStore</code> 中

<ul>
<li><code>CompletedCheckpointStore</code> 有两种实现，分别为 <code>StandaloneCompletedCheckpointStore</code> 和 <code>ZooKeeperCompletedCheckpointStore</code></li>
<li><code>StandaloneCompletedCheckpointStore</code> 简单地将 <code>CompletedCheckpointStore</code> 存放在一个数组中</li>
<li><code>ZooKeeperCompletedCheckpointStore</code> 提供高可用实现：先将 <code>CompletedCheckpointStore</code> 写入到 <code>RetrievableStateStorageHelper</code> 中（通常是文件系统），然后将文件句柄存在 ZK 中</li>
<li>保存的 <code>CompletedCheckpointStore</code> 数量是有限的，会删除旧的快照</li>
</ul></li>
<li>移除被越过的 <code>PendingCheckpoint</code>，因为 <code>CheckpointID</code> 是递增的，那么所有比当前完成的 <code>CheckpointID</code> 小的 <code>PendingCheckpoint</code> 都可以被丢弃了</li>
<li>依次调用 <code>Execution.notifyCheckpointComplete()</code> 通知所有的 Task 当前 Checkpoint 已经完成

<ul>
<li>通过 RPC 调用 <code>TaskExecutor.confirmCheckpoint()</code> 告知对应的 Task</li>
</ul></li>
</ul>

<h3 id="拒绝">拒绝</h3>

<p>在 Task 进行 checkpoint 的过程，可能会发生异常导致 checkpoint 失败，在这种情况下会通过 <code>CheckpointResponder</code> 发出回绝的消息。当 <code>CheckpointCoordinator</code> 接收到 <code>DeclineCheckpoint</code> 消息后会移除 <code>PendingCheckpoint</code>，并尝试丢弃已经接收到的 Ack 消息中已完成的状态句柄：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">CheckpointCoordinator</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">receiveDeclineMessage</span><span class="p">(</span><span class="n">DeclineCheckpoint</span> <span class="nf">message</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span> <span class="o">||</span> <span class="n">message</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">job</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">()))</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;Received DeclineCheckpoint message for job &#34;</span> <span class="o">+</span>
				<span class="n">message</span><span class="p">.</span><span class="na">getJob</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; while this coordinator handles job &#34;</span> <span class="o">+</span> <span class="n">job</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="kd">final</span> <span class="nf">long</span> <span class="n">checkpointId</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="na">getCheckpointId</span><span class="p">();</span>
		<span class="kd">final</span> <span class="nf">String</span> <span class="n">reason</span> <span class="o">=</span> <span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="na">getReason</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">message</span><span class="p">.</span><span class="na">getReason</span><span class="p">().</span><span class="na">getMessage</span><span class="p">()</span> <span class="o">:</span> <span class="s">&#34;&#34;</span><span class="p">);</span>

		<span class="n">PendingCheckpoint</span> <span class="nf">checkpoint</span><span class="p">;</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// we need to check inside the lock for being shutdown as well, otherwise we
</span><span class="c1"></span>			<span class="c1">// get races and invalid error log messages
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">checkpoint</span> <span class="o">=</span> <span class="n">pendingCheckpoints</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">checkpoint</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">checkpoint</span><span class="p">.</span><span class="na">isDiscarded</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">LOG</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;Decline checkpoint {} by task {} of job {}.&#34;</span><span class="p">,</span> <span class="n">checkpointId</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="na">getTaskExecutionId</span><span class="p">(),</span> <span class="n">job</span><span class="p">);</span>
				<span class="n">discardCheckpoint</span><span class="p">(</span><span class="n">checkpoint</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="na">getReason</span><span class="p">());</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">checkpoint</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// this should not happen
</span><span class="c1"></span>				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span>
						<span class="s">&#34;Received message for discarded but non-removed checkpoint &#34;</span> <span class="o">+</span> <span class="n">checkpointId</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">LOG</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">recentPendingCheckpoints</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">))</span> <span class="p">{</span>
					<span class="c1">// message is for an unknown checkpoint, or comes too late (checkpoint disposed)
</span><span class="c1"></span>					<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Received another decline message for now expired checkpoint attempt {} of job {} : {}&#34;</span><span class="p">,</span>
							<span class="n">checkpointId</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// message is for an unknown checkpoint. might be so old that we don&#39;t even remember it any more
</span><span class="c1"></span>					<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Received decline message for unknown (too old?) checkpoint attempt {} of job {} : {}&#34;</span><span class="p">,</span>
							<span class="n">checkpointId</span><span class="p">,</span> <span class="n">job</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="状态恢复">状态恢复</h2>

<p>当 Flink 作业失败重启或者从指定 SavePoint 启动时，需要将整个作业恢复到上一次成功 checkpoint 的状态。这里主要分为两个阶段：</p>

<ul>
<li><code>CheckpointCoordinator</code> 加载最近一次成功的 <code>CompletedCheckpoint</code>，并将状态重新分配到不同的 <code>Execution</code>（<code>Task</code>）中</li>
<li><code>Task</code> 启动时进行状态初始化</li>
</ul>

<h3 id="状态分配">状态分配</h3>

<p>首先，<code>JobMaster</code> 在创建 <code>ExecutionGraph</code> 后会尝试恢复状态到最近一次成功的 checkpoint，或者加载 SavePoint，最终都会调用 <code>CheckpointCoordinator.restoreLatestCheckpointedState()</code> 方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">CheckpointCoordinator</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">restoreLatestCheckpointedState</span><span class="p">(</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="p">,</span> <span class="n">ExecutionJobVertex</span><span class="o">&gt;</span> <span class="nf">tasks</span><span class="p">,</span>
			<span class="kt">boolean</span> <span class="nf">errorIfNoCheckpoint</span><span class="p">,</span>
			<span class="kt">boolean</span> <span class="nf">allowNonRestoredState</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">......</span>
			<span class="c1">// Restore from the latest checkpoint
</span><span class="c1"></span>			<span class="n">CompletedCheckpoint</span> <span class="nf">latest</span> <span class="o">=</span> <span class="n">completedCheckpointStore</span><span class="p">.</span><span class="na">getLatestCheckpoint</span><span class="p">();</span>
			<span class="kd">final</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="p">,</span> <span class="n">OperatorState</span><span class="o">&gt;</span> <span class="nf">operatorStates</span> <span class="o">=</span> <span class="n">latest</span><span class="p">.</span><span class="na">getOperatorStates</span><span class="p">();</span>
			<span class="n">StateAssignmentOperation</span> <span class="nf">stateAssignmentOperation</span> <span class="o">=</span>
					<span class="k">new</span> <span class="n">StateAssignmentOperation</span><span class="p">(</span><span class="n">latest</span><span class="p">.</span><span class="na">getCheckpointID</span><span class="p">(),</span> <span class="n">tasks</span><span class="p">,</span> <span class="n">operatorStates</span><span class="p">,</span> <span class="n">allowNonRestoredState</span><span class="p">);</span>
			<span class="n">stateAssignmentOperation</span><span class="p">.</span><span class="na">assignStates</span><span class="p">();</span>
			<span class="p">........</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>状态的分配过程被封装在 <code>StateAssignmentOperation</code> 中。在状态恢复的过程中，假如任务的并行度发生变化，那么每个子任务的状态和先前必然是不一致的，这其中就涉及到状态的平均重新分配问题，关于状态分配的细节，可以参考 Flink 团队的博文 <a href="https://flink.apache.org/features/2017/07/04/flink-rescalable-state.html#reassigning-operator-state-when-rescaling">A Deep Dive into Rescalable State in Apache Flink</a>，里面给出了 operator state 和 keyed state 重新分配的详细介绍。</p>

<p>最终，每个 <code>Task</code> 分配的状态被封装在 <code>JobManagerTaskRestore</code> 中，并通过 <code>Execution.setInitialState()</code> 关联到 <code>Execution</code> 中。<code>JobManagerTaskRestore</code> 回作为 <code>TaskDeploymentDescriptor</code> 的一个属性下发到 <code>TaskExecutor</code> 中。</p>

<h3 id="task-状态初始化">Task 状态初始化</h3>

<p>当 <code>TaskDeploymentDescriptor</code> 被提交给 <code>TaskExecutor</code> 之后，<code>TaskExecutor</code> 会 <code>TaskStateManager</code> 用于管理当前 <code>Task</code> 的状态，<code>TaskStateManager</code> 对象会基于分配的 <code>JobManagerTaskRestore</code> 和本地状态存储 <code>TaskLocalStateStore</code> 进行创建：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">TaskExecutor</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">CompletableFuture</span><span class="o">&lt;</span><span class="n">Acknowledge</span><span class="o">&gt;</span> <span class="nf">submitTask</span><span class="p">(</span>
			<span class="n">TaskDeploymentDescriptor</span> <span class="nf">tdd</span><span class="p">,</span>
			<span class="n">JobMasterId</span> <span class="nf">jobMasterId</span><span class="p">,</span>
			<span class="n">Time</span> <span class="nf">timeout</span><span class="p">)</span> <span class="p">{</span>

		<span class="p">.......</span>

		<span class="c1">//本地状态存储
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">TaskLocalStateStore</span> <span class="n">localStateStore</span> <span class="o">=</span> <span class="n">localStateStoresManager</span><span class="p">.</span><span class="na">localStateStoreForSubtask</span><span class="p">(</span>
				<span class="n">jobId</span><span class="p">,</span>
				<span class="n">tdd</span><span class="p">.</span><span class="na">getAllocationId</span><span class="p">(),</span>
				<span class="n">taskInformation</span><span class="p">.</span><span class="na">getJobVertexId</span><span class="p">(),</span>
				<span class="n">tdd</span><span class="p">.</span><span class="na">getSubtaskIndex</span><span class="p">());</span>
		<span class="c1">//由 JobManager 分配的用于恢复的状态
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">JobManagerTaskRestore</span> <span class="n">taskRestore</span> <span class="o">=</span> <span class="n">tdd</span><span class="p">.</span><span class="na">getTaskRestore</span><span class="p">();</span>
		<span class="c1">//创建 TaskStateManager
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">TaskStateManager</span> <span class="n">taskStateManager</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TaskStateManagerImpl</span><span class="p">(</span>
				<span class="n">jobId</span><span class="p">,</span>
				<span class="n">tdd</span><span class="p">.</span><span class="na">getExecutionAttemptId</span><span class="p">(),</span>
				<span class="n">localStateStore</span><span class="p">,</span>
				<span class="n">taskRestore</span><span class="p">,</span>
				<span class="n">checkpointResponder</span><span class="p">);</span>

		<span class="c1">//创建并启动 Task
</span><span class="c1"></span>		<span class="p">......</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <code>Task</code> 启动后，<code>StreamTask</code> 会先调用 <code>initializeState</code> 方法，这样每一个算子都会调用 <code>StreamOperator.initializeState()</code> 进行状态的初始化：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">AbstractStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span>
		<span class="nf">implements</span> <span class="n">StreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Serializable</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">final</span> <span class="kt">void</span> <span class="nf">initializeState</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">TypeSerializer</span><span class="o">&lt;?&gt;</span> <span class="n">keySerializer</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="na">getStateKeySerializer</span><span class="p">(</span><span class="n">getUserCodeClassloader</span><span class="p">());</span>

		<span class="kd">final</span> <span class="nf">StreamTask</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="n">containingTask</span> <span class="o">=</span>
			<span class="n">Preconditions</span><span class="p">.</span><span class="na">checkNotNull</span><span class="p">(</span><span class="n">getContainingTask</span><span class="p">());</span>
		<span class="kd">final</span> <span class="nf">CloseableRegistry</span> <span class="n">streamTaskCloseableRegistry</span> <span class="o">=</span>
			<span class="n">Preconditions</span><span class="p">.</span><span class="na">checkNotNull</span><span class="p">(</span><span class="n">containingTask</span><span class="p">.</span><span class="na">getCancelables</span><span class="p">());</span>
		<span class="kd">final</span> <span class="nf">StreamTaskStateInitializer</span> <span class="n">streamTaskStateManager</span> <span class="o">=</span>
			<span class="n">Preconditions</span><span class="p">.</span><span class="na">checkNotNull</span><span class="p">(</span><span class="n">containingTask</span><span class="p">.</span><span class="na">createStreamTaskStateInitializer</span><span class="p">());</span>

		<span class="c1">//创建 StreamOperatorStateContext，这一步会进行状态的恢复，
</span><span class="c1"></span>		<span class="c1">//这样 operatorStateBackend 和 keyedStateBackend 就可以恢复到到最后一次 checkpoint 的状态
</span><span class="c1"></span>		<span class="c1">//timeServiceManager 也会恢复
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">StreamOperatorStateContext</span> <span class="n">context</span> <span class="o">=</span>
			<span class="n">streamTaskStateManager</span><span class="p">.</span><span class="na">streamOperatorStateContext</span><span class="p">(</span>
				<span class="n">getOperatorID</span><span class="p">(),</span>
				<span class="n">getClass</span><span class="p">().</span><span class="na">getSimpleName</span><span class="p">(),</span>
				<span class="k">this</span><span class="p">,</span>
				<span class="n">keySerializer</span><span class="p">,</span>
				<span class="n">streamTaskCloseableRegistry</span><span class="p">,</span>
				<span class="n">metrics</span><span class="p">);</span>

		<span class="k">this</span><span class="p">.</span><span class="na">operatorStateBackend</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="na">operatorStateBackend</span><span class="p">();</span>
		<span class="k">this</span><span class="p">.</span><span class="na">keyedStateBackend</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="na">keyedStateBackend</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">keyedStateBackend</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="na">keyedStateStore</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DefaultKeyedStateStore</span><span class="p">(</span><span class="n">keyedStateBackend</span><span class="p">,</span> <span class="n">getExecutionConfig</span><span class="p">());</span>
		<span class="p">}</span>

		<span class="n">timeServiceManager</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="na">internalTimerServiceManager</span><span class="p">();</span>

		<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">KeyGroupStatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="nf">keyedStateInputs</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="na">rawKeyedStateInputs</span><span class="p">();</span>
		<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">StatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="nf">operatorStateInputs</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="na">rawOperatorStateInputs</span><span class="p">();</span>

		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">//StateInitializationContext 对外暴露了 state backend，timer service manager 等，operator 可以借助它来进行状态初始化
</span><span class="c1"></span>			<span class="n">StateInitializationContext</span> <span class="nf">initializationContext</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StateInitializationContextImpl</span><span class="p">(</span>
				<span class="n">context</span><span class="p">.</span><span class="na">isRestored</span><span class="p">(),</span> <span class="c1">// information whether we restore or start for the first time
</span><span class="c1"></span>				<span class="n">operatorStateBackend</span><span class="p">,</span> <span class="c1">// access to operator state backend
</span><span class="c1"></span>				<span class="n">keyedStateStore</span><span class="p">,</span> <span class="c1">// access to keyed state backend
</span><span class="c1"></span>				<span class="n">keyedStateInputs</span><span class="p">,</span> <span class="c1">// access to keyed state stream
</span><span class="c1"></span>				<span class="n">operatorStateInputs</span><span class="p">);</span> <span class="c1">// access to operator state stream
</span><span class="c1"></span>
			<span class="c1">//进行状态初始化，在子类中实现，比如调用 UDF 的状态初始化方法
</span><span class="c1"></span>			<span class="n">initializeState</span><span class="p">(</span><span class="n">initializationContext</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
			<span class="n">closeFromRegistry</span><span class="p">(</span><span class="n">operatorStateInputs</span><span class="p">,</span> <span class="n">streamTaskCloseableRegistry</span><span class="p">);</span>
			<span class="n">closeFromRegistry</span><span class="p">(</span><span class="n">keyedStateInputs</span><span class="p">,</span> <span class="n">streamTaskCloseableRegistry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">initializeState</span><span class="p">(</span><span class="n">StateInitializationContext</span> <span class="nf">context</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">AbstractUdfStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">F</span> <span class="nf">extends</span> <span class="n">Function</span><span class="o">&gt;</span>
		<span class="nf">extends</span> <span class="n">AbstractStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span>
		<span class="nf">implements</span> <span class="n">OutputTypeConfigurable</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="p">{</span>
		<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">initializeState</span><span class="p">(</span><span class="n">StateInitializationContext</span> <span class="nf">context</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kd">super</span><span class="p">.</span><span class="na">initializeState</span><span class="p">(</span><span class="n">context</span><span class="p">);</span>
		<span class="c1">//用户函数调用状态初始化方法
</span><span class="c1"></span>		<span class="n">StreamingFunctionUtils</span><span class="p">.</span><span class="na">restoreFunctionState</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">userFunction</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>状态恢复的关键操作在于通过 <code>StreamTaskStateInitializer.streamOperatorStateContext()</code> 生成 <code>StreamOperatorStateContext</code>, 通过 <code>StreamOperatorStateContext</code> 可以获取 state backend，timer service manager 等：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">StreamOperatorStateContext</span> <span class="p">{</span>
	<span class="c1">// Returns true, the states provided by this context are restored from a checkpoint/savepoint.
</span><span class="c1"></span>	<span class="kt">boolean</span> <span class="nf">isRestored</span><span class="p">();</span>

	<span class="c1">// Returns the operator state backend for the stream operator.
</span><span class="c1"></span>	<span class="n">OperatorStateBackend</span> <span class="nf">operatorStateBackend</span><span class="p">();</span>

	<span class="c1">// Returns the keyed state backend for the stream operator. This method returns null for non-keyed operators.
</span><span class="c1"></span>	<span class="n">AbstractKeyedStateBackend</span><span class="o">&lt;?&gt;</span> <span class="n">keyedStateBackend</span><span class="p">();</span>

	<span class="c1">// Returns the internal timer service manager for the stream operator. This method returns null for non-keyed operators.
</span><span class="c1"></span>	<span class="n">InternalTimeServiceManager</span><span class="o">&lt;?&gt;</span> <span class="n">internalTimerServiceManager</span><span class="p">();</span>

	<span class="c1">// Returns an iterable to obtain input streams for previously stored operator state partitions that are assigned to this stream operator.
</span><span class="c1"></span>	<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">StatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="nf">rawOperatorStateInputs</span><span class="p">();</span>

	<span class="c1">// Returns an iterable to obtain input streams for previously stored keyed state partitions that are assigned tothis operator. This method returns null for non-keyed operators.
</span><span class="c1"></span>	<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">KeyGroupStatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="nf">rawKeyedStateInputs</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>为了生成 <code>StreamOperatorStateContext</code>，首先要通过 <code>TaskStateManager.prioritizedOperatorState()</code> 方法获得每个 Operator 需要恢复的状态句柄；然后使用获得的状态句柄创建并还原 state backend 和 timer。这里引入了 <code>PrioritizedOperatorSubtaskState</code>, 它封装了多个备选的 OperatorSubtaskState (快照)，这些快照相互之间是可以（部分）替换的，并按照优先级排序。列表中的最后一项是包含了这个子任务的所有状态，但是优先级最低。在进行状态恢复的时候，优先从高优先级的状态句柄中读取状态。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">PrioritizedOperatorSubtaskState</span> <span class="p">{</span>
	<span class="cm">/** List of prioritized snapshot alternatives for managed operator state. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">prioritizedManagedOperatorState</span><span class="p">;</span>

	<span class="cm">/** List of prioritized snapshot alternatives for raw operator state. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">OperatorStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">prioritizedRawOperatorState</span><span class="p">;</span>

	<span class="cm">/** List of prioritized snapshot alternatives for managed keyed state. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">prioritizedManagedKeyedState</span><span class="p">;</span>

	<span class="cm">/** List of prioritized snapshot alternatives for raw keyed state. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">KeyedStateHandle</span><span class="o">&gt;&gt;</span> <span class="nf">prioritizedRawKeyedState</span><span class="p">;</span>

	<span class="kd">public</span> <span class="nf">static</span> <span class="kd">class</span> <span class="nf">Builder</span> <span class="p">{</span>
		<span class="kd">protected</span> <span class="o">&lt;</span><span class="n">T</span> <span class="nf">extends</span> <span class="n">StateObject</span><span class="o">&gt;</span> <span class="nf">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">resolvePrioritizedAlternatives</span><span class="p">(</span>
			<span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">jobManagerState</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">alternativesByPriority</span><span class="p">,</span>
			<span class="n">BiFunction</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">Boolean</span><span class="o">&gt;</span> <span class="nf">approveFun</span><span class="p">)</span> <span class="p">{</span>

			<span class="c1">// Nothing to resolve if there are no alternatives, or the ground truth has already no state, or if we can
</span><span class="c1"></span>			<span class="c1">// assume that a rescaling happened because we find more than one handle in the JM state (this is more a sanity
</span><span class="c1"></span>			<span class="c1">// check).
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">alternativesByPriority</span> <span class="o">==</span> <span class="kc">null</span>
				<span class="o">||</span> <span class="n">alternativesByPriority</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">()</span>
				<span class="o">||</span> <span class="o">!</span><span class="n">jobManagerState</span><span class="p">.</span><span class="na">hasState</span><span class="p">()</span>
				<span class="o">||</span> <span class="n">jobManagerState</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">!=</span> <span class="n">1</span><span class="p">)</span> <span class="p">{</span>

				<span class="k">return</span> <span class="n">Collections</span><span class="p">.</span><span class="na">singletonList</span><span class="p">(</span><span class="n">jobManagerState</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="c1">// As we know size is == 1
</span><span class="c1"></span>			<span class="n">T</span> <span class="nf">reference</span> <span class="o">=</span> <span class="n">jobManagerState</span><span class="p">.</span><span class="na">iterator</span><span class="p">().</span><span class="na">next</span><span class="p">();</span>
			<span class="c1">// This will contain the end result, we initialize it with the potential max. size.
</span><span class="c1"></span>			<span class="n">List</span><span class="o">&lt;</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">approved</span> <span class="o">=</span>
				<span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">1</span> <span class="o">+</span> <span class="n">alternativesByPriority</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">StateObjectCollection</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">alternative</span> <span class="o">:</span> <span class="n">alternativesByPriority</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// We found an alternative to the JM state if it has state, we have a 1:1 relationship, and the
</span><span class="c1"></span>				<span class="c1">// approve-function signaled true.
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">alternative</span> <span class="o">!=</span> <span class="kc">null</span>
					<span class="o">&amp;&amp;</span> <span class="n">alternative</span><span class="p">.</span><span class="na">hasState</span><span class="p">()</span>
					<span class="o">&amp;&amp;</span> <span class="n">alternative</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">1</span>
					<span class="o">&amp;&amp;</span> <span class="n">BooleanUtils</span><span class="p">.</span><span class="na">isTrue</span><span class="p">(</span><span class="n">approveFun</span><span class="p">.</span><span class="na">apply</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">alternative</span><span class="p">.</span><span class="na">iterator</span><span class="p">().</span><span class="na">next</span><span class="p">())))</span> <span class="p">{</span>
					<span class="n">approved</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">alternative</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">// 从 JobManager 获取的状态作为最低优先级的备选
</span><span class="c1"></span>			<span class="c1">// Of course we include the ground truth as last alternative.
</span><span class="c1"></span>			<span class="n">approved</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">jobManagerState</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">Collections</span><span class="p">.</span><span class="na">unmodifiableList</span><span class="p">(</span><span class="n">approved</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kd">public</span> <span class="nf">class</span> <span class="n">TaskStateManagerImpl</span> <span class="nf">implements</span> <span class="n">TaskStateManager</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">PrioritizedOperatorSubtaskState</span> <span class="n">prioritizedOperatorState</span><span class="p">(</span><span class="n">OperatorID</span> <span class="nf">operatorID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jobManagerTaskRestore</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">PrioritizedOperatorSubtaskState</span><span class="p">.</span><span class="na">emptyNotRestored</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="c1">//从 JobManager 获取的状态快照
</span><span class="c1"></span>		<span class="n">TaskStateSnapshot</span> <span class="nf">jobManagerStateSnapshot</span> <span class="o">=</span>
			<span class="n">jobManagerTaskRestore</span><span class="p">.</span><span class="na">getTaskStateSnapshot</span><span class="p">();</span>
		<span class="n">OperatorSubtaskState</span> <span class="nf">jobManagerSubtaskState</span> <span class="o">=</span>
			<span class="n">jobManagerStateSnapshot</span><span class="p">.</span><span class="na">getSubtaskStateByOperatorID</span><span class="p">(</span><span class="n">operatorID</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jobManagerSubtaskState</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">PrioritizedOperatorSubtaskState</span><span class="p">.</span><span class="na">emptyNotRestored</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="c1">//本地状态快照作为备选
</span><span class="c1"></span>		<span class="kt">long</span> <span class="nf">restoreCheckpointId</span> <span class="o">=</span> <span class="n">jobManagerTaskRestore</span><span class="p">.</span><span class="na">getRestoreCheckpointId</span><span class="p">();</span>
		<span class="n">TaskStateSnapshot</span> <span class="nf">localStateSnapshot</span> <span class="o">=</span>
			<span class="n">localStateStore</span><span class="p">.</span><span class="na">retrieveLocalState</span><span class="p">(</span><span class="n">restoreCheckpointId</span><span class="p">);</span>

		<span class="n">localStateStore</span><span class="p">.</span><span class="na">pruneMatchingCheckpoints</span><span class="p">((</span><span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">checkpointId</span> <span class="o">!=</span> <span class="n">restoreCheckpointId</span><span class="p">);</span>
		<span class="n">List</span><span class="o">&lt;</span><span class="n">OperatorSubtaskState</span><span class="o">&gt;</span> <span class="nf">alternativesByPriority</span> <span class="o">=</span> <span class="n">Collections</span><span class="p">.</span><span class="na">emptyList</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">localStateSnapshot</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">OperatorSubtaskState</span> <span class="nf">localSubtaskState</span> <span class="o">=</span> <span class="n">localStateSnapshot</span><span class="p">.</span><span class="na">getSubtaskStateByOperatorID</span><span class="p">(</span><span class="n">operatorID</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">localSubtaskState</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">alternativesByPriority</span> <span class="o">=</span> <span class="n">Collections</span><span class="p">.</span><span class="na">singletonList</span><span class="p">(</span><span class="n">localSubtaskState</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">//构建 PrioritizedOperatorSubtaskState
</span><span class="c1"></span>		<span class="n">PrioritizedOperatorSubtaskState</span><span class="p">.</span><span class="na">Builder</span> <span class="nf">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PrioritizedOperatorSubtaskState</span><span class="p">.</span><span class="na">Builder</span><span class="p">(</span>
			<span class="n">jobManagerSubtaskState</span><span class="p">,</span>
			<span class="n">alternativesByPriority</span><span class="p">,</span>
			<span class="kc">true</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">builder</span><span class="p">.</span><span class="na">build</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在获得了 <code>PrioritizedOperatorSubtaskState</code> 之后就可以进行状态的恢复了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">StreamTaskStateInitializerImpl</span> <span class="nf">implements</span> <span class="n">StreamTaskStateInitializer</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">StreamOperatorStateContext</span> <span class="n">streamOperatorStateContext</span><span class="p">(</span>
		<span class="nd">@Nonnull</span> <span class="n">OperatorID</span> <span class="nf">operatorID</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">String</span> <span class="nf">operatorClassName</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">KeyContext</span> <span class="nf">keyContext</span><span class="p">,</span>
		<span class="nd">@Nullable</span> <span class="n">TypeSerializer</span><span class="o">&lt;?&gt;</span> <span class="n">keySerializer</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">CloseableRegistry</span> <span class="nf">streamTaskCloseableRegistry</span><span class="p">,</span>
		<span class="nd">@Nonnull</span> <span class="n">MetricGroup</span> <span class="nf">metricGroup</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>

		<span class="n">TaskInfo</span> <span class="nf">taskInfo</span> <span class="o">=</span> <span class="n">environment</span><span class="p">.</span><span class="na">getTaskInfo</span><span class="p">();</span>
		<span class="n">OperatorSubtaskDescriptionText</span> <span class="nf">operatorSubtaskDescription</span> <span class="o">=</span>
			<span class="k">new</span> <span class="n">OperatorSubtaskDescriptionText</span><span class="p">(</span>
				<span class="n">operatorID</span><span class="p">,</span>
				<span class="n">operatorClassName</span><span class="p">,</span>
				<span class="n">taskInfo</span><span class="p">.</span><span class="na">getIndexOfThisSubtask</span><span class="p">(),</span>
				<span class="n">taskInfo</span><span class="p">.</span><span class="na">getNumberOfParallelSubtasks</span><span class="p">());</span>

		<span class="kd">final</span> <span class="nf">String</span> <span class="n">operatorIdentifierText</span> <span class="o">=</span> <span class="n">operatorSubtaskDescription</span><span class="p">.</span><span class="na">toString</span><span class="p">();</span>

		<span class="c1">//先获取用于恢复状态的 PrioritizedOperatorSubtaskState
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">PrioritizedOperatorSubtaskState</span> <span class="n">prioritizedOperatorSubtaskStates</span> <span class="o">=</span>
			<span class="n">taskStateManager</span><span class="p">.</span><span class="na">prioritizedOperatorState</span><span class="p">(</span><span class="n">operatorID</span><span class="p">);</span>

		<span class="n">AbstractKeyedStateBackend</span><span class="o">&lt;?&gt;</span> <span class="n">keyedStatedBackend</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="n">OperatorStateBackend</span> <span class="nf">operatorStateBackend</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">KeyGroupStatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="nf">rawKeyedStateInputs</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="n">CloseableIterable</span><span class="o">&lt;</span><span class="n">StatePartitionStreamProvider</span><span class="o">&gt;</span> <span class="nf">rawOperatorStateInputs</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="n">InternalTimeServiceManager</span><span class="o">&lt;?&gt;</span> <span class="n">timeServiceManager</span><span class="p">;</span>

		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">// -------------- Keyed State Backend --------------
</span><span class="c1"></span>			<span class="n">keyedStatedBackend</span> <span class="o">=</span> <span class="n">keyedStatedBackend</span><span class="p">(</span>
				<span class="n">keySerializer</span><span class="p">,</span>
				<span class="n">operatorIdentifierText</span><span class="p">,</span>
				<span class="n">prioritizedOperatorSubtaskStates</span><span class="p">,</span>
				<span class="n">streamTaskCloseableRegistry</span><span class="p">,</span>
				<span class="n">metricGroup</span><span class="p">);</span>

			<span class="c1">// -------------- Operator State Backend --------------
</span><span class="c1"></span>			<span class="n">operatorStateBackend</span> <span class="o">=</span> <span class="n">operatorStateBackend</span><span class="p">(</span>
				<span class="n">operatorIdentifierText</span><span class="p">,</span>
				<span class="n">prioritizedOperatorSubtaskStates</span><span class="p">,</span>
				<span class="n">streamTaskCloseableRegistry</span><span class="p">);</span>

			<span class="c1">// -------------- Raw State Streams --------------
</span><span class="c1"></span>			<span class="n">rawKeyedStateInputs</span> <span class="o">=</span> <span class="n">rawKeyedStateInputs</span><span class="p">(</span>
				<span class="n">prioritizedOperatorSubtaskStates</span><span class="p">.</span><span class="na">getPrioritizedRawKeyedState</span><span class="p">().</span><span class="na">iterator</span><span class="p">());</span>
			<span class="n">streamTaskCloseableRegistry</span><span class="p">.</span><span class="na">registerCloseable</span><span class="p">(</span><span class="n">rawKeyedStateInputs</span><span class="p">);</span>

			<span class="n">rawOperatorStateInputs</span> <span class="o">=</span> <span class="n">rawOperatorStateInputs</span><span class="p">(</span>
				<span class="n">prioritizedOperatorSubtaskStates</span><span class="p">.</span><span class="na">getPrioritizedRawOperatorState</span><span class="p">().</span><span class="na">iterator</span><span class="p">());</span>
			<span class="n">streamTaskCloseableRegistry</span><span class="p">.</span><span class="na">registerCloseable</span><span class="p">(</span><span class="n">rawOperatorStateInputs</span><span class="p">);</span>

			<span class="c1">// -------------- Internal Timer Service Manager --------------
</span><span class="c1"></span>			<span class="n">timeServiceManager</span> <span class="o">=</span> <span class="n">internalTimeServiceManager</span><span class="p">(</span><span class="n">keyedStatedBackend</span><span class="p">,</span> <span class="n">keyContext</span><span class="p">,</span> <span class="n">rawKeyedStateInputs</span><span class="p">);</span>

			<span class="c1">// -------------- Preparing return value --------------
</span><span class="c1"></span>
			<span class="k">return</span> <span class="k">new</span> <span class="n">StreamOperatorStateContextImpl</span><span class="p">(</span>
				<span class="n">prioritizedOperatorSubtaskStates</span><span class="p">.</span><span class="na">isRestored</span><span class="p">(),</span>
				<span class="n">operatorStateBackend</span><span class="p">,</span>
				<span class="n">keyedStatedBackend</span><span class="p">,</span>
				<span class="n">timeServiceManager</span><span class="p">,</span>
				<span class="n">rawOperatorStateInputs</span><span class="p">,</span>
				<span class="n">rawKeyedStateInputs</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">ex</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//.......
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>状态恢复和创建创建 state backend 耦合在一起，借助 <code>BackendRestorerProcedure</code> 来完成，具体的逻辑在 <code>BackendRestorerProcedure.createAndRestore</code> 方法中。</p>

<h2 id="小结">小结</h2>

<p>Flink 的 checkpoint 机制是实现故障恢复和数据一致性的重要保障。本文首先对 Flink 的分布式快照的核心思想进行了概述，接着从源码的角度对 checkpoint 的发起、执行、以及状态恢复等流程进行了分析。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="http://www.vldb.org%2Fpvldb%2Fvol10%2Fp1718-carbone.pdf">State Management in Apache Flink</a></li>
<li><a href="https://flink.apache.org/features/2017/07/04/flink-rescalable-state.html#reassigning-operator-state-when-rescaling">A Deep Dive into Rescalable State in Apache Flink</a></li>
<li><a href="https://flink.apache.org/features/2018/01/30/incremental-checkpointing.html">Managing Large State in Apache Flink: An Intro to Incremental Checkpointing</a></li>
</ul>

<p>-EOF-</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">原始链接</span>
    <span class="item-content"><a href="https://blog.jrwang.me/2019/flink-source-code-checkpoint/">https://blog.jrwang.me/2019/flink-source-code-checkpoint/</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-09-12
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flink/">Flink</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2019/flink-source-code-time-and-window/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Flink 源码阅读笔记（12）- 时间、定时器和窗口</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/flink-source-code-state/">
            <span class="next-text nav-default">Flink 源码阅读笔记（10）- State 管理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="jrthe42/blog-comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jrthe42@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/jrthe42" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/jrthe42" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://blog.jrwang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.f79f403f.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-66913886-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
