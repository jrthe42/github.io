<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Flink 源码阅读笔记（2）- JobGraph 的生成 - JR&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jrthe42" /><meta name="description" content="前面的文章我们介绍了 StreamGraph 的生成，这个实际上只对应 Flink 作业在逻辑上的执行计划图。Flink 会进一步对 StreamGraph 进行转换，得到另一个执行计划图，即 JobGr" /><meta name="keywords" content="jrthe42, Blog, Programming" />






<meta name="generator" content="Hugo 0.59.0 with theme even" />


<link rel="canonical" href="https://blog.jrwang.me/2019/flink-source-code-jobgraph/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.7d171193.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Flink 源码阅读笔记（2）- JobGraph 的生成" />
<meta property="og:description" content="前面的文章我们介绍了 StreamGraph 的生成，这个实际上只对应 Flink 作业在逻辑上的执行计划图。Flink 会进一步对 StreamGraph 进行转换，得到另一个执行计划图，即 JobGr" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.jrwang.me/2019/flink-source-code-jobgraph/" />
<meta property="article:published_time" content="2019-02-17T16:35:45+00:00" />
<meta property="article:modified_time" content="2019-09-07T17:33:33+08:00" />
<meta itemprop="name" content="Flink 源码阅读笔记（2）- JobGraph 的生成">
<meta itemprop="description" content="前面的文章我们介绍了 StreamGraph 的生成，这个实际上只对应 Flink 作业在逻辑上的执行计划图。Flink 会进一步对 StreamGraph 进行转换，得到另一个执行计划图，即 JobGr">


<meta itemprop="datePublished" content="2019-02-17T16:35:45&#43;00:00" />
<meta itemprop="dateModified" content="2019-09-07T17:33:33&#43;08:00" />
<meta itemprop="wordCount" content="3839">



<meta itemprop="keywords" content="Flink," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flink 源码阅读笔记（2）- JobGraph 的生成"/>
<meta name="twitter:description" content="前面的文章我们介绍了 StreamGraph 的生成，这个实际上只对应 Flink 作业在逻辑上的执行计划图。Flink 会进一步对 StreamGraph 进行转换，得到另一个执行计划图，即 JobGr"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">JRTHE42</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">JRTHE42</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Flink 源码阅读笔记（2）- JobGraph 的生成</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-02-17 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#jobvertex">JobVertex</a></li>
<li><a href="#jobedge">JobEdge</a></li>
<li><a href="#intermediatedataset">IntermediateDataSet</a></li>
<li><a href="#streamconfig">StreamConfig</a></li>
<li><a href="#从-streamgraph-到-jobgraph">从 StreamGraph 到 JobGraph</a></li>
<li><a href="#小结">小结</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>前面的文章我们介绍了 StreamGraph 的生成，这个实际上只对应 Flink 作业在逻辑上的执行计划图。Flink 会进一步对 StreamGraph 进行转换，得到另一个执行计划图，即 JobGraph。</p>

<h2 id="jobvertex">JobVertex</h2>

<p>在 StreamGraph 中，每一个算子（Operator） 对应了图中的一个节点（StreamNode）。StreamGraph 会被进一步优化，将多个符合条件的节点串联（Chain） 在一起形成一个节点，从而减少数据在不同节点之间流动所产生的序列化、反序列化、网络传输的开销。多个算子被 chain 在一起的形成的节点在 <code>JobGraph</code> 中对应的就是 <code>JobVertex</code>。</p>

<p>每个 <code>JobVertex</code> 中包含一个或多个 Operators。 <code>JobVertex</code> 的主要成员变量包括</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="cm">/** The ID of the vertex. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">JobVertexID</span> <span class="nf">id</span><span class="p">;</span>

	<span class="cm">/** The alternative IDs of the vertex. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">JobVertexID</span><span class="o">&gt;</span> <span class="nf">idAlternatives</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="cm">/** The IDs of all operators contained in this vertex. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="nf">operatorIDs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="cm">/** The alternative IDs of all operators contained in this vertex. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">OperatorID</span><span class="o">&gt;</span> <span class="nf">operatorIdsAlternatives</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="cm">/** List of produced data sets, one per writer */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IntermediateDataSet</span><span class="o">&gt;</span> <span class="nf">results</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IntermediateDataSet</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="cm">/** List of edges with incoming data. One per Reader. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">JobEdge</span><span class="o">&gt;</span> <span class="nf">inputs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">JobEdge</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="cm">/** Number of subtasks to split this task into at runtime.*/</span>
	<span class="kd">private</span> <span class="nf">int</span> <span class="n">parallelism</span> <span class="o">=</span> <span class="n">ExecutionConfig</span><span class="p">.</span><span class="na">PARALLELISM_DEFAULT</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>其输入是 <code>JobEdge</code> 列表, 输出是 <code>IntermediateDataSet</code> 列表。</p>

<h2 id="jobedge">JobEdge</h2>

<p>在 <code>StramGraph</code> 中，<code>StreamNode</code> 之间是通过 <code>StreamEdge</code> 建立连接的。在 <code>JobEdge</code> 中，对应的是 <code>JobEdge</code> 。</p>

<p>和 <code>StreamEdge</code> 中同时保留了源节点和目标节点 （sourceId 和 targetId）不同，在 <code>JobEdge</code> 中只有源节点的信息。由于 <code>JobVertex</code> 中保存了所有输入的 <code>JobEdge</code> 的信息，因而同样可以在两个节点之间建立连接。更确切地说，<code>JobEdge</code> 是和节点的输出结果相关联的，我们看下 <code>JobEdge</code> 主要的成员变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="cm">/** The vertex connected to this edge. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">JobVertex</span> <span class="nf">target</span><span class="p">;</span>

	<span class="cm">/** The distribution pattern that should be used for this job edge. */</span>
  <span class="c1">// DistributionPattern 决定了在上游节点（生产者）的子任务和下游节点（消费者）之间的连接模式
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">DistributionPattern</span> <span class="nf">distributionPattern</span><span class="p">;</span>

	<span class="cm">/** The data set at the source of the edge, may be null if the edge is not yet connected*/</span>
	<span class="kd">private</span> <span class="nf">IntermediateDataSet</span> <span class="n">source</span><span class="p">;</span>

	<span class="cm">/** The id of the source intermediate data set */</span>
	<span class="kd">private</span> <span class="nf">IntermediateDataSetID</span> <span class="n">sourceId</span><span class="p">;</span>

	<span class="cm">/** Optional name for the data shipping strategy (forward, partition hash, rebalance, ...),
</span><span class="cm">	 * to be displayed in the JSON plan */</span>
	<span class="kd">private</span> <span class="nf">String</span> <span class="n">shipStrategyName</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="intermediatedataset">IntermediateDataSet</h2>

<p><code>JobVertex</code> 产生的数据被抽象为 <code>IntermediateDataSet</code>, 字面意思为中间数据集，这个很容易理解。前面提到，<code>JobEdge</code> 是和节点的输出结果相关联的，其实就是指可以把 <code>JobEdge</code> 看作是 <code>IntermediateDataSet</code> 的消费者，那么 <code>JobVertex</code> 自然就是生产者了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="nf">final</span> <span class="n">IntermediateDataSetID</span> <span class="nf">id</span><span class="p">;</span> 		<span class="c1">// the identifier
</span><span class="c1"></span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">JobVertex</span> <span class="nf">producer</span><span class="p">;</span>			<span class="c1">// the operation that produced this data set
</span><span class="c1"></span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">JobEdge</span><span class="o">&gt;</span> <span class="nf">consumers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">JobEdge</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="c1">// The type of partition to use at runtime
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultPartitionType</span> <span class="nf">resultType</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>其中 <code>ResultPartitionType</code> 表示中间结果的类型，说起来有点抽象，我们看下属性就明白了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="cm">/** Can the partition be consumed while being produced? */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">boolean</span> <span class="nf">isPipelined</span><span class="p">;</span>

	<span class="cm">/** Does the partition produce back pressure when not consumed? */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">boolean</span> <span class="nf">hasBackPressure</span><span class="p">;</span>

	<span class="cm">/** Does this partition use a limited number of (network) buffers? */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">boolean</span> <span class="nf">isBounded</span><span class="p">;</span></code></pre></td></tr></table>
</div>
</div>
<p>这个要结合 Flink 任务运行时的内存管理机制来看，在后面的文章再进行分析。目前在 Stream 模式下使用的类型是 <code>PIPELINED_BOUNDED(true, true, true)</code>，上面的三个属性都是 true。</p>

<h2 id="streamconfig">StreamConfig</h2>

<p>对于每一个 <code>StreamOperator</code>, 也就是 <code>StreamGraph</code> 中的每一个 <code>StreamGraph</code>, 在生成 <code>JobGraph</code> 的过程中 <code>StreamingJobGraphGenerator</code> 都会创建一个对应的 <code>StreamConfig</code>。</p>

<p><code>StreamConfig</code> 中保存了这个算子（operator） 在运行是需要的所有配置信息，这些信息都是通过 key/value 的形式存储在 <code>Configuration</code> 中的。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="c1">//保存StreamOperator信息
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">void</span> <span class="n">setStreamOperator</span><span class="p">(</span><span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">operator</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">operator</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">config</span><span class="p">.</span><span class="na">setClass</span><span class="p">(</span><span class="n">USER_FUNCTION</span><span class="p">,</span> <span class="n">operator</span><span class="p">.</span><span class="na">getClass</span><span class="p">());</span>

			<span class="k">try</span> <span class="p">{</span>
				<span class="n">InstantiationUtil</span><span class="p">.</span><span class="na">writeObjectToConfig</span><span class="p">(</span><span class="n">operator</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">config</span><span class="p">,</span> <span class="n">SERIALIZEDUDF</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">StreamTaskException</span><span class="p">(</span><span class="s">&#34;Cannot serialize operator object &#34;</span>
						<span class="o">+</span> <span class="n">operator</span><span class="p">.</span><span class="na">getClass</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34;.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>


  <span class="kd">public</span> <span class="nf">void</span> <span class="n">setChainedOutputs</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">chainedOutputs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="n">InstantiationUtil</span><span class="p">.</span><span class="na">writeObjectToConfig</span><span class="p">(</span><span class="n">chainedOutputs</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">config</span><span class="p">,</span> <span class="n">CHAINED_OUTPUTS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">StreamTaskException</span><span class="p">(</span><span class="s">&#34;Cannot serialize chained outputs.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

  <span class="kd">public</span> <span class="nf">void</span> <span class="n">setNonChainedOutputs</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">outputvertexIDs</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="n">InstantiationUtil</span><span class="p">.</span><span class="na">writeObjectToConfig</span><span class="p">(</span><span class="n">outputvertexIDs</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">config</span><span class="p">,</span> <span class="n">NONCHAINED_OUTPUTS</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">StreamTaskException</span><span class="p">(</span><span class="s">&#34;Cannot serialize non chained outputs.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

  <span class="kd">public</span> <span class="nf">void</span> <span class="n">setInPhysicalEdges</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">inEdges</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="n">InstantiationUtil</span><span class="p">.</span><span class="na">writeObjectToConfig</span><span class="p">(</span><span class="n">inEdges</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">config</span><span class="p">,</span> <span class="n">IN_STREAM_EDGES</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">StreamTaskException</span><span class="p">(</span><span class="s">&#34;Cannot serialize inward edges.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

  <span class="o">//</span><span class="p">......</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="从-streamgraph-到-jobgraph">从 StreamGraph 到 JobGraph</h2>

<p>从 <code>StreamGraph</code> 到 <code>JobGraph</code> 的转换入口在 <code>StreamingJobGraphGenerator</code> 中。</p>

<p>首先来看下 <code>StreamingJobGraphGenerator</code> 的成员变量和入口函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="c1">//id -&gt; JobVertex 的对应关系
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">JobVertex</span><span class="o">&gt;</span> <span class="nf">jobVertices</span><span class="p">;</span>
	<span class="c1">//已经构建的JobVertex的id集合
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">Collection</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="nf">builtVertices</span><span class="p">;</span>
  <span class="c1">//物理边集合（不包含chain内部的边）, 按创建顺序排序
</span><span class="c1"></span>  <span class="kd">private</span> <span class="nf">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">physicalEdgesInOrder</span><span class="p">;</span>
  <span class="c1">//保存 operataor chain 的信息，部署时用来构建 OperatorChain，startNodeId -&gt; (currentNodeId -&gt; StreamConfig)
</span><span class="c1"></span>  <span class="kd">private</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;&gt;</span> <span class="nf">chainedConfigs</span><span class="p">;</span>
  <span class="c1">//所有节点的配置信息，id -&gt; StreamConfig
</span><span class="c1"></span>  <span class="kd">private</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;</span> <span class="nf">vertexConfigs</span><span class="p">;</span>
  <span class="c1">//保存每个节点的名字，id -&gt; chainedName
</span><span class="c1"></span>  <span class="kd">private</span> <span class="nf">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="nf">chainedNames</span><span class="p">;</span>

  <span class="c1">//用于计算hash值的算法
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">StreamGraphHasher</span> <span class="nf">defaultStreamGraphHasher</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">StreamGraphHasher</span><span class="o">&gt;</span> <span class="nf">legacyStreamGraphHashers</span><span class="p">;</span>
	<span class="c1">//.....
</span><span class="c1"></span>
<span class="kd">private</span> <span class="nf">JobGraph</span> <span class="n">createJobGraph</span><span class="p">()</span> <span class="p">{</span>

		<span class="c1">// 调度模式，立即启动
</span><span class="c1"></span>		<span class="n">jobGraph</span><span class="p">.</span><span class="na">setScheduleMode</span><span class="p">(</span><span class="n">ScheduleMode</span><span class="p">.</span><span class="na">EAGER</span><span class="p">);</span>

		<span class="c1">// 广度优先遍历 StreamGraph 并且为每个SteamNode生成hash，hash值将被用于 JobVertexId 中
</span><span class="c1"></span>		<span class="c1">// 保证如果提交的拓扑没有改变，则每次生成的hash都是一样的
</span><span class="c1"></span>		<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;</span> <span class="nf">hashes</span> <span class="o">=</span> <span class="n">defaultStreamGraphHasher</span><span class="p">.</span><span class="na">traverseStreamGraphAndGenerateHashes</span><span class="p">(</span><span class="n">streamGraph</span><span class="p">);</span>
		<span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;</span> <span class="nf">legacyHashes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">legacyStreamGraphHashers</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">StreamGraphHasher</span> <span class="nf">hasher</span> <span class="o">:</span> <span class="n">legacyStreamGraphHashers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">legacyHashes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">hasher</span><span class="p">.</span><span class="na">traverseStreamGraphAndGenerateHashes</span><span class="p">(</span><span class="n">streamGraph</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="kt">byte</span><span class="p">[],</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">chainedOperatorHashes</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>

		<span class="c1">// 主要的转换逻辑，生成 JobVetex， JobEdge 等
</span><span class="c1"></span>		<span class="n">setChaining</span><span class="p">(</span><span class="n">hashes</span><span class="p">,</span> <span class="n">legacyHashes</span><span class="p">,</span> <span class="n">chainedOperatorHashes</span><span class="p">);</span>

		<span class="c1">// 将每个JobVertex的输入边集合也序列化到该JobVertex的StreamConfig中
</span><span class="c1"></span>    <span class="c1">// (出边集合已经在setChaining的时候写入了)
</span><span class="c1"></span>		<span class="n">setPhysicalEdges</span><span class="p">();</span>

		<span class="c1">// 根据group name，为每个 JobVertex 指定所属的 SlotSharingGroup
</span><span class="c1"></span>		<span class="c1">// 以及针对 Iteration的头尾设置  CoLocationGroup
</span><span class="c1"></span>		<span class="n">setSlotSharingAndCoLocation</span><span class="p">();</span>

		<span class="c1">// 配置 checkpoint
</span><span class="c1"></span>		<span class="n">configureCheckpointing</span><span class="p">();</span>

		<span class="c1">// 添加用户提供的自定义的文件信息
</span><span class="c1"></span>		<span class="n">JobGraphGenerator</span><span class="p">.</span><span class="na">addUserArtifactEntries</span><span class="p">(</span><span class="n">streamGraph</span><span class="p">.</span><span class="na">getEnvironment</span><span class="p">().</span><span class="na">getCachedFiles</span><span class="p">(),</span> <span class="n">jobGraph</span><span class="p">);</span>

		<span class="c1">// 将 StreamGraph 的 ExecutionConfig 序列化到 JobGraph 的配置中
</span><span class="c1"></span>		<span class="k">try</span> <span class="p">{</span>
			<span class="n">jobGraph</span><span class="p">.</span><span class="na">setExecutionConfig</span><span class="p">(</span><span class="n">streamGraph</span><span class="p">.</span><span class="na">getExecutionConfig</span><span class="p">());</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">IOException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalConfigurationException</span><span class="p">(</span><span class="s">&#34;Could not serialize the ExecutionConfig.&#34;</span> <span class="o">+</span>
					<span class="s">&#34;This indicates that non-serializable types (like custom serializers) were registered&#34;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">jobGraph</span><span class="p">;</span>
	<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>StreamingJobGraphGenerator#createJobGraph</code> 函数的逻辑也很清晰，首先为所有节点生成一个唯一的hash id，如果节点在多次提交中没有改变（包括并发度、上下游等），那么这个id就不会改变，这主要用于故障恢复。这里我们不能用 <code>StreamNode.id</code> 来代替，因为这是一个从 1 开始的静态计数变量，同样的 Job 可能会得到不一样的 id。然后就是最关键的 chaining 处理，和生成JobVetex、JobEdge等。之后就是写入各种配置相关的信息。</p>

<p>我们先来看一下，Flink 是如何确定两个 Operator 是否能够被 chain 到同一个节点的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="c1">//StreamEdge 两端的节点是否能够被 chain 到同一个 JobVertex 中
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">static</span> <span class="kt">boolean</span> <span class="nf">isChainable</span><span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">edge</span><span class="p">,</span> <span class="n">StreamGraph</span> <span class="nf">streamGraph</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//获取到上游和下游节点
</span><span class="c1"></span>		<span class="n">StreamNode</span> <span class="nf">upStreamVertex</span> <span class="o">=</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getSourceVertex</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
		<span class="n">StreamNode</span> <span class="nf">downStreamVertex</span> <span class="o">=</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getTargetVertex</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>

		<span class="c1">//获取到上游和下游节点具体的算子 StreamOperator
</span><span class="c1"></span>		<span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">headOperator</span> <span class="o">=</span> <span class="n">upStreamVertex</span><span class="p">.</span><span class="na">getOperator</span><span class="p">();</span>
		<span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">outOperator</span> <span class="o">=</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getOperator</span><span class="p">();</span>

		<span class="k">return</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getInEdges</span><span class="p">().</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">1</span> <span class="c1">//下游节点只有一个输入
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">outOperator</span> <span class="o">!=</span> <span class="kc">null</span>
				<span class="o">&amp;&amp;</span> <span class="n">headOperator</span> <span class="o">!=</span> <span class="kc">null</span>
				<span class="o">&amp;&amp;</span> <span class="n">upStreamVertex</span><span class="p">.</span><span class="na">isSameSlotSharingGroup</span><span class="p">(</span><span class="n">downStreamVertex</span><span class="p">)</span> <span class="c1">//在同一个slot共享组中
</span><span class="c1"></span>				<span class="c1">//上下游算子的 chainning 策略，要允许chainning
</span><span class="c1"></span>				<span class="c1">//默认的是 ALWAYS
</span><span class="c1"></span>				<span class="c1">//在添加算子时，也可以强制使用 disableChain 设置为 NEVER
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">outOperator</span><span class="p">.</span><span class="na">getChainingStrategy</span><span class="p">()</span> <span class="o">==</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">ALWAYS</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">headOperator</span><span class="p">.</span><span class="na">getChainingStrategy</span><span class="p">()</span> <span class="o">==</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">HEAD</span> <span class="o">||</span>
					<span class="n">headOperator</span><span class="p">.</span><span class="na">getChainingStrategy</span><span class="p">()</span> <span class="o">==</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">ALWAYS</span><span class="p">)</span>
				<span class="c1">//上下游节点之间的数据传输方式必须是FORWARD，而不能是REBALANCE等其它模式
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="na">getPartitioner</span><span class="p">()</span> <span class="k">instanceof</span> <span class="n">ForwardPartitioner</span><span class="p">)</span>
				<span class="c1">//上下游节点的并行度要一致
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">upStreamVertex</span><span class="p">.</span><span class="na">getParallelism</span><span class="p">()</span> <span class="o">==</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getParallelism</span><span class="p">()</span>
				<span class="o">&amp;&amp;</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">isChainingEnabled</span><span class="p">();</span>
	<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>只要一条边两端的节点满足上面的条件，那么这两个节点就可以被串联在同一个 <code>JobVertex</code> 中。接着来就来看最为关键的函数 setChaining 的逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java">	<span class="cm">/**
</span><span class="cm">	 * Sets up task chains from the source {@link StreamNode} instances.
</span><span class="cm">	 *
</span><span class="cm">	 * &lt;p&gt;This will recursively create all {@link JobVertex} instances.
</span><span class="cm">	 */</span>
	<span class="kd">private</span> <span class="nf">void</span> <span class="n">setChaining</span><span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;</span> <span class="nf">hashes</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;</span> <span class="nf">legacyHashes</span><span class="p">,</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="kt">byte</span><span class="p">[],</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">chainedOperatorHashes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">Integer</span> <span class="nf">sourceNodeId</span> <span class="o">:</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getSourceIDs</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">createChain</span><span class="p">(</span><span class="n">sourceNodeId</span><span class="p">,</span> <span class="n">sourceNodeId</span><span class="p">,</span> <span class="n">hashes</span><span class="p">,</span> <span class="n">legacyHashes</span><span class="p">,</span> <span class="n">0</span><span class="p">,</span> <span class="n">chainedOperatorHashes</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="c1">//构建 operator chain（可能包含一个或多个StreamNode），返回值是当前的这个 operator chain 实际的输出边（不包括内部的边）
</span><span class="c1"></span>	<span class="c1">//如果 currentNodeId != startNodeId, 说明当前节点在  operator chain 的内部
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">createChain</span><span class="p">(</span>
			<span class="n">Integer</span> <span class="nf">startNodeId</span><span class="p">,</span>
			<span class="n">Integer</span> <span class="nf">currentNodeId</span><span class="p">,</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;</span> <span class="nf">hashes</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;</span> <span class="nf">legacyHashes</span><span class="p">,</span>
			<span class="kt">int</span> <span class="nf">chainIndex</span><span class="p">,</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="kt">byte</span><span class="p">[],</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;&gt;</span> <span class="nf">chainedOperatorHashes</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">builtVertices</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">))</span> <span class="p">{</span>

			<span class="c1">//当前 operator chain 最终的输出边，不包括内部的边
</span><span class="c1"></span>			<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">transitiveOutEdges</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span><span class="p">();</span>

			<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">chainableOutputs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span><span class="p">();</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">nonChainableOutputs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span><span class="p">();</span>

			<span class="c1">//将当前节点的出边分为两组，即 chainable 和 nonChainable
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">outEdge</span> <span class="o">:</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getStreamNode</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">).</span><span class="na">getOutEdges</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">isChainable</span><span class="p">(</span><span class="n">outEdge</span><span class="p">,</span> <span class="n">streamGraph</span><span class="p">))</span> <span class="p">{</span> <span class="c1">//判断当前 StreamEdge 的上下游是否可以串联在一起
</span><span class="c1"></span>					<span class="n">chainableOutputs</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">outEdge</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">nonChainableOutputs</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">outEdge</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">//对于chainable的输出边，递归调用，找到最终的输出边并加入到输出列表中
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">chainable</span> <span class="o">:</span> <span class="n">chainableOutputs</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">transitiveOutEdges</span><span class="p">.</span><span class="na">addAll</span><span class="p">(</span>
						<span class="n">createChain</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">,</span> <span class="n">chainable</span><span class="p">.</span><span class="na">getTargetId</span><span class="p">(),</span> <span class="n">hashes</span><span class="p">,</span> <span class="n">legacyHashes</span><span class="p">,</span> <span class="n">chainIndex</span> <span class="o">+</span> <span class="n">1</span><span class="p">,</span> <span class="n">chainedOperatorHashes</span><span class="p">));</span>
			<span class="p">}</span>

			<span class="c1">//对于 nonChainable 的边
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">nonChainable</span> <span class="o">:</span> <span class="n">nonChainableOutputs</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//这个边本身就应该加入到当前节点的输出列表中
</span><span class="c1"></span>				<span class="n">transitiveOutEdges</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">nonChainable</span><span class="p">);</span>
				<span class="c1">//递归调用，以下游节点为起点创建新的operator chain
</span><span class="c1"></span>				<span class="n">createChain</span><span class="p">(</span><span class="n">nonChainable</span><span class="p">.</span><span class="na">getTargetId</span><span class="p">(),</span> <span class="n">nonChainable</span><span class="p">.</span><span class="na">getTargetId</span><span class="p">(),</span> <span class="n">hashes</span><span class="p">,</span> <span class="n">legacyHashes</span><span class="p">,</span> <span class="n">0</span><span class="p">,</span> <span class="n">chainedOperatorHashes</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="c1">//用于保存一个operator chain所有 operator 的 hash 信息
</span><span class="c1"></span>			<span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="kt">byte</span><span class="p">[],</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;&gt;</span> <span class="nf">operatorHashes</span> <span class="o">=</span>
				<span class="n">chainedOperatorHashes</span><span class="p">.</span><span class="na">computeIfAbsent</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">,</span> <span class="n">k</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">());</span>

			<span class="kt">byte</span><span class="p">[]</span> <span class="nf">primaryHashBytes</span> <span class="o">=</span> <span class="n">hashes</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">);</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="kt">byte</span><span class="p">[]</span><span class="o">&gt;</span> <span class="nf">legacyHash</span> <span class="o">:</span> <span class="n">legacyHashes</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">operatorHashes</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">primaryHashBytes</span><span class="p">,</span> <span class="n">legacyHash</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">)));</span>
			<span class="p">}</span>

			<span class="c1">//当前节点的名称，资源要求等信息
</span><span class="c1"></span>			<span class="n">chainedNames</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">createChainedName</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">chainableOutputs</span><span class="p">));</span>
			<span class="n">chainedMinResources</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">createChainedMinResources</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">chainableOutputs</span><span class="p">));</span>
			<span class="n">chainedPreferredResources</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">createChainedPreferredResources</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">chainableOutputs</span><span class="p">));</span>

			<span class="c1">//如果当前节点是起始节点, 则直接创建 JobVertex 并返回 StreamConfig, 否则先创建一个空的 StreamConfig
</span><span class="c1"></span>			<span class="c1">//createJobVertex 函数就是根据 StreamNode 创建对应的 JobVertex, 并返回了空的 StreamConfig
</span><span class="c1"></span>			<span class="n">StreamConfig</span> <span class="nf">config</span> <span class="o">=</span> <span class="n">currentNodeId</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">)</span>
					<span class="o">?</span> <span class="n">createJobVertex</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">,</span> <span class="n">hashes</span><span class="p">,</span> <span class="n">legacyHashes</span><span class="p">,</span> <span class="n">chainedOperatorHashes</span><span class="p">)</span>
					<span class="o">:</span> <span class="k">new</span> <span class="n">StreamConfig</span><span class="p">(</span><span class="k">new</span> <span class="n">Configuration</span><span class="p">());</span>

			<span class="c1">// 设置 JobVertex 的 StreamConfig, 基本上是序列化 StreamNode 中的配置到 StreamConfig 中.
</span><span class="c1"></span>			<span class="c1">// 其中包括 序列化器, StreamOperator, Checkpoint 等相关配置
</span><span class="c1"></span>			<span class="n">setVertexConfig</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">chainableOutputs</span><span class="p">,</span> <span class="n">nonChainableOutputs</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">currentNodeId</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">))</span> <span class="p">{</span>
				<span class="c1">// 如果是chain的起始节点。（不是chain中的节点，也会被标记成 chain start）
</span><span class="c1"></span>				<span class="n">config</span><span class="p">.</span><span class="na">setChainStart</span><span class="p">();</span>
				<span class="n">config</span><span class="p">.</span><span class="na">setChainIndex</span><span class="p">(</span><span class="n">0</span><span class="p">);</span>
				<span class="n">config</span><span class="p">.</span><span class="na">setOperatorName</span><span class="p">(</span><span class="n">streamGraph</span><span class="p">.</span><span class="na">getStreamNode</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">).</span><span class="na">getOperatorName</span><span class="p">());</span>
				<span class="c1">//把实际的输出边写入配置, 部署时会用到
</span><span class="c1"></span>				<span class="n">config</span><span class="p">.</span><span class="na">setOutEdgesInOrder</span><span class="p">(</span><span class="n">transitiveOutEdges</span><span class="p">);</span>
				<span class="c1">//operator chain 的头部 operator 的输出边，包括内部的边
</span><span class="c1"></span>				<span class="n">config</span><span class="p">.</span><span class="na">setOutEdges</span><span class="p">(</span><span class="n">streamGraph</span><span class="p">.</span><span class="na">getStreamNode</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">).</span><span class="na">getOutEdges</span><span class="p">());</span>

				<span class="c1">// 将当前节点(headOfChain)与所有出边相连
</span><span class="c1"></span>				<span class="k">for</span> <span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">edge</span> <span class="o">:</span> <span class="n">transitiveOutEdges</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// 通过StreamEdge构建出JobEdge，创建IntermediateDataSet，用来将JobVertex和JobEdge相连
</span><span class="c1"></span>					<span class="n">connect</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">,</span> <span class="n">edge</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="c1">// 将operator chain中所有子节点的 StreamConfig 写入到 headOfChain 节点的 CHAINED_TASK_CONFIG 配置中
</span><span class="c1"></span>				<span class="n">config</span><span class="p">.</span><span class="na">setTransitiveChainedTaskConfigs</span><span class="p">(</span><span class="n">chainedConfigs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">));</span>

			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">//如果是 operator chain 内部的节点
</span><span class="c1"></span>				<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;</span> <span class="nf">chainedConfs</span> <span class="o">=</span> <span class="n">chainedConfigs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">chainedConfs</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">chainedConfigs</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">,</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;</span><span class="p">());</span>
				<span class="p">}</span>
				<span class="n">config</span><span class="p">.</span><span class="na">setChainIndex</span><span class="p">(</span><span class="n">chainIndex</span><span class="p">);</span>
				<span class="n">StreamNode</span> <span class="nf">node</span> <span class="o">=</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getStreamNode</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">);</span>
				<span class="n">config</span><span class="p">.</span><span class="na">setOperatorName</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="na">getOperatorName</span><span class="p">());</span>
				<span class="c1">// 将当前节点的 StreamConfig 添加所在的 operator chain 的 config 集合中
</span><span class="c1"></span>				<span class="n">chainedConfigs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">startNodeId</span><span class="p">).</span><span class="na">put</span><span class="p">(</span><span class="n">currentNodeId</span><span class="p">,</span> <span class="n">config</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="c1">//设置当前 operator 的 OperatorID
</span><span class="c1"></span>			<span class="n">config</span><span class="p">.</span><span class="na">setOperatorID</span><span class="p">(</span><span class="k">new</span> <span class="n">OperatorID</span><span class="p">(</span><span class="n">primaryHashBytes</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">chainableOutputs</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">config</span><span class="p">.</span><span class="na">setChainEnd</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="n">transitiveOutEdges</span><span class="p">;</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>上述过程实际上就是通过 DFS 遍历所有的 <code>StreamNode</code>, 并按照 chainable 的条件不停地将可以串联的呃 operator 放在同一个的 operator chain 中。每一个 <code>StreamNode</code> 的配置信息都会被序列化到对应的 <code>StreamConfig</code> 中。只有 operator chain 的头部节点会生成对应的 <code>JobVertex</code> ，一个 operator chain 的所有内部节点都会以序列化的形式写入头部节点的  <code>CHAINED_TASK_CONFIG</code> 配置项中。</p>

<p>每一个 operator chain 都会为所有的实际输出边创建对应的 <code>JobEdge</code>，并和 <code>JobVertex</code> 连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">private</span> <span class="nf">void</span> <span class="n">connect</span><span class="p">(</span><span class="n">Integer</span> <span class="nf">headOfChain</span><span class="p">,</span> <span class="n">StreamEdge</span> <span class="nf">edge</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">physicalEdgesInOrder</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>

		<span class="n">Integer</span> <span class="nf">downStreamvertexID</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="na">getTargetId</span><span class="p">();</span>

		<span class="c1">//上下游节点
</span><span class="c1"></span>		<span class="n">JobVertex</span> <span class="nf">headVertex</span> <span class="o">=</span> <span class="n">jobVertices</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">headOfChain</span><span class="p">);</span>
		<span class="n">JobVertex</span> <span class="nf">downStreamVertex</span> <span class="o">=</span> <span class="n">jobVertices</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">downStreamvertexID</span><span class="p">);</span>

		<span class="n">StreamConfig</span> <span class="nf">downStreamConfig</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamConfig</span><span class="p">(</span><span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getConfiguration</span><span class="p">());</span>
		<span class="c1">//下游节点增加一个输入
</span><span class="c1"></span>		<span class="n">downStreamConfig</span><span class="p">.</span><span class="na">setNumberOfInputs</span><span class="p">(</span><span class="n">downStreamConfig</span><span class="p">.</span><span class="na">getNumberOfInputs</span><span class="p">()</span> <span class="o">+</span> <span class="n">1</span><span class="p">);</span>

		<span class="n">StreamPartitioner</span><span class="o">&lt;?&gt;</span> <span class="n">partitioner</span> <span class="o">=</span> <span class="n">edge</span><span class="p">.</span><span class="na">getPartitioner</span><span class="p">();</span>
		<span class="n">JobEdge</span> <span class="nf">jobEdge</span><span class="p">;</span>
		<span class="c1">//创建 JobEdge 和 IntermediateDataSet
</span><span class="c1"></span>		<span class="c1">//根据StreamPartitioner类型决定在上游节点（生产者）的子任务和下游节点（消费者）之间的连接模式
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">partitioner</span> <span class="nf">instanceof</span> <span class="n">ForwardPartitioner</span> <span class="o">||</span> <span class="n">partitioner</span> <span class="nf">instanceof</span> <span class="n">RescalePartitioner</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jobEdge</span> <span class="o">=</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">connectNewDataSetAsInput</span><span class="p">(</span>
				<span class="n">headVertex</span><span class="p">,</span>
				<span class="n">DistributionPattern</span><span class="p">.</span><span class="na">POINTWISE</span><span class="p">,</span>
				<span class="n">ResultPartitionType</span><span class="p">.</span><span class="na">PIPELINED_BOUNDED</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">jobEdge</span> <span class="o">=</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">connectNewDataSetAsInput</span><span class="p">(</span>
					<span class="n">headVertex</span><span class="p">,</span>
					<span class="n">DistributionPattern</span><span class="p">.</span><span class="na">ALL_TO_ALL</span><span class="p">,</span>
					<span class="n">ResultPartitionType</span><span class="p">.</span><span class="na">PIPELINED_BOUNDED</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="c1">// set strategy name so that web interface can show it.
</span><span class="c1"></span>		<span class="n">jobEdge</span><span class="p">.</span><span class="na">setShipStrategyName</span><span class="p">(</span><span class="n">partitioner</span><span class="p">.</span><span class="na">toString</span><span class="p">());</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">LOG</span><span class="p">.</span><span class="na">isDebugEnabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;CONNECTED: {} - {} -&gt; {}&#34;</span><span class="p">,</span> <span class="n">partitioner</span><span class="p">.</span><span class="na">getClass</span><span class="p">().</span><span class="na">getSimpleName</span><span class="p">(),</span>
					<span class="n">headOfChain</span><span class="p">,</span> <span class="n">downStreamvertexID</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="小结">小结</h2>

<p>本文分析了从 <code>StreamGraph</code> 到 <code>JobGraph</code> 之间的转换过程。 <code>JobGraph</code> 的关键在于将多个 <code>StreamNode</code> 优化为一个 <code>JobVertex</code>, 对应的 <code>StreamEdge</code> 则转化为 <code>JobEdge</code>, 并且 <code>JobVertex</code> 和 <code>JobEdge</code> 之间通过 <code>IntermediateDataSet</code> 形成一个生产者和消费者的连接关系。</p>

<p>-EOF-</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">原始链接</span>
    <span class="item-content"><a href="https://blog.jrwang.me/2019/flink-source-code-jobgraph/">https://blog.jrwang.me/2019/flink-source-code-jobgraph/</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-09-07
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flink/">Flink</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2019/flink-source-code-executiongraph/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Flink 源码阅读笔记（3）- ExecutionGraph 的生成</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/flink-source-code-streamgraph/">
            <span class="next-text nav-default">Flink 源码阅读笔记（1）- StreamGraph 的生成</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="jrthe42/blog-comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jrthe42@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/jrthe42" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/jrthe42" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://blog.jrwang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2021
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.f79f403f.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-66913886-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
