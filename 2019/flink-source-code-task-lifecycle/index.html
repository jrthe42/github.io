<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Flink 源码阅读笔记（9）- Task 的生命周期 - JR&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jrthe42" /><meta name="description" content="一个 Flink Job 提交到集群中运行时，会被调度为不同的 Task。在前面的文章中，我们已经介绍了 Flink 如何根据用户的编写的程序生成调度用的执行图，如何为 Task 分" /><meta name="keywords" content="jrthe42, Blog, Programming" />






<meta name="generator" content="Hugo 0.59.0 with theme even" />


<link rel="canonical" href="https://blog.jrwang.me/2019/flink-source-code-task-lifecycle/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.7d171193.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Flink 源码阅读笔记（9）- Task 的生命周期" />
<meta property="og:description" content="一个 Flink Job 提交到集群中运行时，会被调度为不同的 Task。在前面的文章中，我们已经介绍了 Flink 如何根据用户的编写的程序生成调度用的执行图，如何为 Task 分" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.jrwang.me/2019/flink-source-code-task-lifecycle/" />
<meta property="article:published_time" content="2019-06-02T19:05:03+00:00" />
<meta property="article:modified_time" content="2019-09-12T16:32:52+08:00" />
<meta itemprop="name" content="Flink 源码阅读笔记（9）- Task 的生命周期">
<meta itemprop="description" content="一个 Flink Job 提交到集群中运行时，会被调度为不同的 Task。在前面的文章中，我们已经介绍了 Flink 如何根据用户的编写的程序生成调度用的执行图，如何为 Task 分">


<meta itemprop="datePublished" content="2019-06-02T19:05:03&#43;00:00" />
<meta itemprop="dateModified" content="2019-09-12T16:32:52&#43;08:00" />
<meta itemprop="wordCount" content="7262">



<meta itemprop="keywords" content="Flink," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flink 源码阅读笔记（9）- Task 的生命周期"/>
<meta name="twitter:description" content="一个 Flink Job 提交到集群中运行时，会被调度为不同的 Task。在前面的文章中，我们已经介绍了 Flink 如何根据用户的编写的程序生成调度用的执行图，如何为 Task 分"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">JRTHE42</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">JRTHE42</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Flink 源码阅读笔记（9）- Task 的生命周期</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-06-02 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#task-和-operatorchain">Task 和 OperatorChain</a></li>
<li><a href="#operatorchain-内部的数据传递">OperatorChain 内部的数据传递</a></li>
<li><a href="#task-的生命周期">Task 的生命周期</a>
<ul>
<li><a href="#任务调度">任务调度</a></li>
<li><a href="#启动-task-线程">启动 Task 线程</a></li>
<li><a href="#streamtask">StreamTask</a></li>
<li><a href="#operatorchain">OperatorChain</a></li>
<li><a href="#几类不同的-streamtask">几类不同的 StreamTask</a>
<ul>
<li><a href="#sourcestreamtask">SourceStreamTask</a></li>
<li><a href="#oneinputstreamtask">OneInputStreamTask</a></li>
<li><a href="#twoinputstreamtask">TwoInputStreamTask</a></li>
</ul></li>
</ul></li>
<li><a href="#小节">小节</a></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>一个 Flink Job 提交到集群中运行时，会被调度为不同的 Task。在前面的文章中，我们已经介绍了 Flink 如何根据用户的编写的程序生成调度用的执行图，如何为 Task 分配计算资源，以及 Task 之间如何进行数据交换。在这篇文章中，我们将跟踪一个 Task 的完整的生命周期，进一步加深对 Flink 执行过程的理解。</p>

<h2 id="task-和-operatorchain">Task 和 OperatorChain</h2>

<p>在前面介绍如何生成 <code>JobGraph</code> 的文章中，我们已经了解了 Flink 会尽可能把能够 chaining 到一起的算子串联在一起，形成 <code>OperatorChain</code>，对应一个 <code>JobVertex</code>。</p>

<p>两个 Operator 能够串联在一起的条件包括：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">StreamingJobGraphGenerator</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">static</span> <span class="kt">boolean</span> <span class="nf">isChainable</span><span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">edge</span><span class="p">,</span> <span class="n">StreamGraph</span> <span class="nf">streamGraph</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">StreamNode</span> <span class="nf">upStreamVertex</span> <span class="o">=</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getSourceVertex</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>
		<span class="n">StreamNode</span> <span class="nf">downStreamVertex</span> <span class="o">=</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">getTargetVertex</span><span class="p">(</span><span class="n">edge</span><span class="p">);</span>

		<span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">headOperator</span> <span class="o">=</span> <span class="n">upStreamVertex</span><span class="p">.</span><span class="na">getOperator</span><span class="p">();</span>
		<span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span> <span class="n">outOperator</span> <span class="o">=</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getOperator</span><span class="p">();</span>

		<span class="k">return</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getInEdges</span><span class="p">().</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">1</span> <span class="c1">//下游节点只有一个输入
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">outOperator</span> <span class="o">!=</span> <span class="kc">null</span>
				<span class="o">&amp;&amp;</span> <span class="n">headOperator</span> <span class="o">!=</span> <span class="kc">null</span>
				<span class="o">&amp;&amp;</span> <span class="n">upStreamVertex</span><span class="p">.</span><span class="na">isSameSlotSharingGroup</span><span class="p">(</span><span class="n">downStreamVertex</span><span class="p">)</span> <span class="c1">//在同一个 slot 共享组中
</span><span class="c1"></span>				<span class="c1">//上下游算子的 chainning 策略，要允许 chainning
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">outOperator</span><span class="p">.</span><span class="na">getChainingStrategy</span><span class="p">()</span> <span class="o">==</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">ALWAYS</span>
				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">headOperator</span><span class="p">.</span><span class="na">getChainingStrategy</span><span class="p">()</span> <span class="o">==</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">HEAD</span> <span class="o">||</span>
					<span class="n">headOperator</span><span class="p">.</span><span class="na">getChainingStrategy</span><span class="p">()</span> <span class="o">==</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">ALWAYS</span><span class="p">)</span>
				<span class="c1">//上下游算子之间的数据传输方式必须是FORWARD，而不能是REBALANCE等其它模式
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">edge</span><span class="p">.</span><span class="na">getPartitioner</span><span class="p">()</span> <span class="k">instanceof</span> <span class="n">ForwardPartitioner</span><span class="p">)</span>
				<span class="c1">//上下游算子的并行度要一致
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">upStreamVertex</span><span class="p">.</span><span class="na">getParallelism</span><span class="p">()</span> <span class="o">==</span> <span class="n">downStreamVertex</span><span class="p">.</span><span class="na">getParallelism</span><span class="p">()</span>
				<span class="c1">// StreamExecutionEnvironment 配置允许 chainning
</span><span class="c1"></span>				<span class="o">&amp;&amp;</span> <span class="n">streamGraph</span><span class="p">.</span><span class="na">isChainingEnabled</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>JobGraph</code> 在 JobManager 中进一步被转换为可供调度的并行化版本的 <code>ExecutionGraph</code>，其中 <code>JobVertex</code> 被展开为并行化版本的 <code>ExecutionVertex</code>，每一个 <code>ExecutionVertex</code> 对应 <code>JobVertex</code> 的一个并行子任务，它的每一次调度对应一个 <code>Execution</code>，即 TaskManager 中的一个 <code>Task</code>。所以，一个 <code>Task</code> 运行期间的主要处理逻辑对应一个 <code>OperatorChain</code>，这个 <code>OperatorChain</code> 可能包含多个 Operator，也可能只有一个 Operator。</p>

<h2 id="operatorchain-内部的数据传递">OperatorChain 内部的数据传递</h2>

<p>在前面的文章中，我们已经介绍过不同的 <code>Task</code> 之间如何通过网络栈进行数据交换，并对 <code>Task</code> 之间应对&rdquo;反压&rdquo;的机制进行了分析。现在我们知道，在一个 <code>Task</code> 内部同样可能包含多个不同的算子，这些算子处理数据的主要逻辑由用户提供的自定义函数（UDF）实现，那么上游算子处理之后的记录如何传递给下游算子呢？既然一个 <code>Task</code> 是一个独立的线程，多个算子的计算逻辑是依次执行的，那么很直观的想法就是直接通过函数调用的参数来数据。我们看下 Flink 内部是如何处理的。</p>

<p>首先，要看一下 <code>Output</code> 接口，<code>Output</code> 接口继承自 <code>Collector</code> 接口，用于接受 Operator 提交的数据:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">extends</span> <span class="n">Collector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="cm">/**
</span><span class="cm">	 * Emits a {@link Watermark} from an operator. This watermark is broadcast to all downstream
</span><span class="cm">	 * operators.
</span><span class="cm">	 *
</span><span class="cm">	 * &lt;p&gt;A watermark specifies that no element with a timestamp lower or equal to the watermark
</span><span class="cm">	 * timestamp will be emitted in the future.
</span><span class="cm">	 */</span>
	<span class="kt">void</span> <span class="nf">emitWatermark</span><span class="p">(</span><span class="n">Watermark</span> <span class="nf">mark</span><span class="p">);</span>

	<span class="cm">/**
</span><span class="cm">	 * Emits a record the side output identified by the given {@link OutputTag}.
</span><span class="cm">	 *
</span><span class="cm">	 * @param record The record to collect.
</span><span class="cm">	 */</span>
	<span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">void</span> <span class="n">collect</span><span class="p">(</span><span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">outputTag</span><span class="p">,</span> <span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">record</span><span class="p">);</span>

	<span class="kt">void</span> <span class="nf">emitLatencyMarker</span><span class="p">(</span><span class="n">LatencyMarker</span> <span class="nf">latencyMarker</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <code>OperatorChain</code> 内部还有一个 <code>WatermarkGaugeExposingOutput</code> 接口继承自 <code>Output</code>，它主要是额外提供了一个获取 watermark 值的方法：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">extends</span> <span class="n">Output</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="n">Gauge</span><span class="o">&lt;</span><span class="n">Long</span><span class="o">&gt;</span> <span class="nf">getWatermarkGauge</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>每一个 <code>StreamOperator</code> 都有一个 <code>Output</code> 成员，用于收集当前算子处理完的记录，比如在 <code>StreamMap</code> 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">StreamMap</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span>
		<span class="nf">extends</span> <span class="n">AbstractUdfStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">MapFunction</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;&gt;</span>
		<span class="nf">implements</span> <span class="n">OneInputStreamOperator</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">processElement</span><span class="p">(</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">element</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="n">output</span><span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="na">replace</span><span class="p">(</span><span class="n">userFunction</span><span class="p">.</span><span class="na">map</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="na">getValue</span><span class="p">())));</span>
	<span class="p">}</span>	
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <code>StreamFilter</code> 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">StreamFilter</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">extends</span> <span class="n">AbstractUdfStreamOperator</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">FilterFunction</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;&gt;</span> <span class="nf">implements</span> <span class="n">OneInputStreamOperator</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">IN</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">processElement</span><span class="p">(</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">element</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">userFunction</span><span class="p">.</span><span class="na">filter</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="na">getValue</span><span class="p">()))</span> <span class="p">{</span>
			<span class="n">output</span><span class="p">.</span><span class="na">collect</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 <code>StreamFlatMap</code> 中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">StreamFlatMap</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span>
		<span class="nf">extends</span> <span class="n">AbstractUdfStreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;&gt;</span>
		<span class="nf">implements</span> <span class="n">OneInputStreamOperator</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">transient</span> <span class="n">TimestampedCollector</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span> <span class="nf">collector</span><span class="p">;</span>

	<span class="kd">public</span> <span class="nf">StreamFlatMap</span><span class="p">(</span><span class="n">FlatMapFunction</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="nf">flatMapper</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">super</span><span class="p">(</span><span class="n">flatMapper</span><span class="p">);</span>
		<span class="n">chainingStrategy</span> <span class="o">=</span> <span class="n">ChainingStrategy</span><span class="p">.</span><span class="na">ALWAYS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">processElement</span><span class="p">(</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">element</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="n">collector</span><span class="p">.</span><span class="na">setTimestamp</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
		<span class="n">userFunction</span><span class="p">.</span><span class="na">flatMap</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="na">getValue</span><span class="p">(),</span> <span class="n">collector</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>那么 <code>Output</code> 又是怎么处理算子提交的记录的呢？这就需要进一步看一下 <code>Output</code> 的具体实现类。</p>

<p><code>OperatorChain</code> 的内部类 <code>ChainingOutput</code> 实现了 <code>WatermarkGaugeExposingOutput</code> 接口，它持有一个 <code>OneInputStreamOperator</code>, 即 <code>OperatorChain</code> 中当前算子的下游算子。当 <code>ChainingOutput</code> 接收到当前算子提交的数据时，直接将调用下游算子的 <code>processElement</code> 方法:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">ChainingOutput</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">implements</span> <span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
	<span class="kd">protected</span> <span class="nf">final</span> <span class="n">OneInputStreamOperator</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="n">operator</span><span class="p">;</span> <span class="c1">//这是下游算子
</span><span class="c1"></span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">collect</span><span class="p">(</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">record</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">outputTag</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// we are only responsible for emitting to the main input
</span><span class="c1"></span>			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pushToOperator</span><span class="p">(</span><span class="n">record</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">void</span> <span class="n">collect</span><span class="p">(</span><span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">outputTag</span><span class="p">,</span> <span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">record</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//如果有 OutputTag， 则要求 OutputTag 匹配才会转发记录
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">outputTag</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="k">this</span><span class="p">.</span><span class="na">outputTag</span><span class="p">.</span><span class="na">equals</span><span class="p">(</span><span class="n">outputTag</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">pushToOperator</span><span class="p">(</span><span class="n">record</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kd">protected</span> <span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">void</span> <span class="n">pushToOperator</span><span class="p">(</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="nf">record</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">// we know that the given outputTag matches our OutputTag so the record
</span><span class="c1"></span>			<span class="c1">// must be of the type that our operator expects.
</span><span class="c1"></span>			<span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&#34;unchecked&#34;</span><span class="p">)</span>
			<span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">castRecord</span> <span class="o">=</span> <span class="p">(</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">record</span><span class="p">;</span>
			<span class="n">numRecordsIn</span><span class="p">.</span><span class="na">inc</span><span class="p">();</span>
			<span class="c1">//直接调用下游算子的 processElement 方法
</span><span class="c1"></span>			<span class="n">operator</span><span class="p">.</span><span class="na">setKeyContextElement1</span><span class="p">(</span><span class="n">castRecord</span><span class="p">);</span>
			<span class="n">operator</span><span class="p">.</span><span class="na">processElement</span><span class="p">(</span><span class="n">castRecord</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">ExceptionInChainedOperatorException</span><span class="p">(</span><span class="n">e</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>通过在 <code>ChainingOutput</code> 中保存下游 <code>StreamOperator</code> 的引用，<code>ChainingOutput</code> 直接将对象的引用传递给下游算子。但是 <code>ExecutionConfig</code> 有一个配置项，即 <code>objectReuse</code>，在默认情况下会禁止对象重用。如果不允许对象重用，则不会使用 <code>ChainingOutput</code>，而是会使用 <code>CopyingChainingOutput</code>。顾名思义，它和 <code>ChainingOutput</code> 的区别在于，它会对记录进行拷贝后传递给下游算子。</p>

<p><code>BroadcastingOutputCollector</code> 封装了一组 <code>Output</code>, 即 <code>Output&lt;StreamRecord&lt;T&gt;&gt;[] outputs</code>, 在接收到 <code>StreamRecord</code> 时，会将消息提交到所有的 内部所有的 <code>Output</code> 中。<code>BroadcastingOutputCollector</code> 主要用在当前算子有多个下游算子的情况下。与此对应的还有一个 <code>CopyingBroadcastingOutputCollector</code>。</p>

<p><code>DirectedOutput</code> 基于 <code>OutputSelector&lt;OUT&gt;[] outputSelectors</code> 选择要转发的目标 <code>Output</code>，主要是在 split/select 的情况下使用。与 <code>DirectedOutput</code> 对应的也有一个 <code>CopyingDirectedOutput</code>。</p>

<p>对于位于 <code>OperatorChain</code> 末尾的算子，它处理过的记录需要被其它 <code>Task</code> 消费，因此它的记录需要被写入 <code>ResultPartition</code> 。因此，Flink 提供了 <code>RecordWriterOutput</code>，它也实现了 <code>WatermarkGaugeExposingOutput</code>， 但是它是通过 <code>RecordWriter</code> 输出接收到的消息记录。<code>RecordWriter</code> 是 <code>ResultPartitionWriter</code> 的一层包装，提供了将记录序列化到 buffer 中的功能。</p>

<h2 id="task-的生命周期">Task 的生命周期</h2>

<p>下面我们将进一步对 Task 运行的生命周期进行分析。</p>

<h3 id="任务调度">任务调度</h3>

<p>当 <code>JobGraph</code> 被提交到 <code>JobMaster</code> 之后，首先会生成 <code>ExecutionGraph</code>，这是任务调度时使用的调度执行图。然后通过 <code>ExecutionGraph#scheduleForExecution</code> 方法开始调度各个子任务。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">ExecutionGraph</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">scheduleForExecution</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">JobException</span> <span class="p">{</span>
		<span class="n">assertRunningInJobMasterMainThread</span><span class="p">();</span>
		<span class="kd">final</span> <span class="nf">long</span> <span class="n">currentGlobalModVersion</span> <span class="o">=</span> <span class="n">globalModVersion</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transitionState</span><span class="p">(</span><span class="n">JobStatus</span><span class="p">.</span><span class="na">CREATED</span><span class="p">,</span> <span class="n">JobStatus</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">))</span> <span class="p">{</span>
			<span class="kd">final</span> <span class="nf">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">newSchedulingFuture</span><span class="p">;</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">scheduleMode</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//调度任务
</span><span class="c1"></span>				<span class="k">case</span> <span class="n">LAZY_FROM_SOURCES</span><span class="o">:</span> <span class="c1">//只运行 source，其它的子任务由source进行通知
</span><span class="c1"></span>					<span class="n">newSchedulingFuture</span> <span class="o">=</span> <span class="n">scheduleLazy</span><span class="p">(</span><span class="n">slotProvider</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">case</span> <span class="n">EAGER</span><span class="o">:</span> <span class="c1">//所有的子任务都立即进行调度，这是 streaming 模式采用的方式
</span><span class="c1"></span>					<span class="n">newSchedulingFuture</span> <span class="o">=</span> <span class="n">scheduleEager</span><span class="p">(</span><span class="n">slotProvider</span><span class="p">,</span> <span class="n">allocationTimeout</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">default</span><span class="o">:</span>
					<span class="k">throw</span> <span class="k">new</span> <span class="n">JobException</span><span class="p">(</span><span class="s">&#34;Schedule mode is invalid.&#34;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">JobStatus</span><span class="p">.</span><span class="na">RUNNING</span> <span class="o">&amp;&amp;</span> <span class="n">currentGlobalModVersion</span> <span class="o">==</span> <span class="n">globalModVersion</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">schedulingFuture</span> <span class="o">=</span> <span class="n">newSchedulingFuture</span><span class="p">;</span>
				<span class="n">newSchedulingFuture</span><span class="p">.</span><span class="na">whenComplete</span><span class="p">(</span>
					<span class="p">(</span><span class="n">Void</span> <span class="nf">ignored</span><span class="p">,</span> <span class="n">Throwable</span> <span class="nf">throwable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">throwable</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">throwable</span> <span class="nf">instanceof</span> <span class="n">CancellationException</span><span class="p">))</span> <span class="p">{</span>
							<span class="c1">// only fail if the scheduling future was not canceled
</span><span class="c1"></span>							<span class="n">failGlobal</span><span class="p">(</span><span class="n">ExceptionUtils</span><span class="p">.</span><span class="na">stripCompletionException</span><span class="p">(</span><span class="n">throwable</span><span class="p">));</span>
						<span class="p">}</span>
					<span class="p">});</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">newSchedulingFuture</span><span class="p">.</span><span class="na">cancel</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Job may only be scheduled from state &#34;</span> <span class="o">+</span> <span class="n">JobStatus</span><span class="p">.</span><span class="na">CREATED</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在调度执行的时候，首先所有的子任务都需要先向 <code>Scheduler</code> 申请 slot 资源（关于计算资源的管理可以参考前面的文章），当所有需要调度的子任务都分配到 slot 资源后，才正式开始调度任务：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">ExecutionGraph</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">CompletableFuture</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">&gt;</span> <span class="nf">scheduleEager</span><span class="p">(</span><span class="n">SlotProvider</span> <span class="nf">slotProvider</span><span class="p">,</span> <span class="kd">final</span> <span class="nf">Time</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">assertRunningInJobMasterMainThread</span><span class="p">();</span>
		<span class="n">checkState</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">JobStatus</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">,</span> <span class="s">&#34;job is not running currently&#34;</span><span class="p">);</span>

		<span class="c1">// collecting all the slots may resize and fail in that operation without slots getting lost
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">ArrayList</span><span class="o">&lt;</span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Execution</span><span class="o">&gt;&gt;</span> <span class="nf">allAllocationFutures</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">getNumberOfExecutionJobVertices</span><span class="p">());</span>
		<span class="kd">final</span> <span class="nf">Set</span><span class="o">&lt;</span><span class="n">AllocationID</span><span class="o">&gt;</span> <span class="nf">allPreviousAllocationIds</span> <span class="o">=</span>
			<span class="n">Collections</span><span class="p">.</span><span class="na">unmodifiableSet</span><span class="p">(</span><span class="n">computeAllPriorAllocationIdsIfRequiredByScheduling</span><span class="p">());</span>
		<span class="c1">// allocate the slots (obtain all their futures
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">ExecutionJobVertex</span> <span class="nf">ejv</span> <span class="o">:</span> <span class="n">getVerticesTopologically</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">// these calls are not blocking, they only return futures
</span><span class="c1"></span>			<span class="n">Collection</span><span class="o">&lt;</span><span class="n">CompletableFuture</span><span class="o">&lt;</span><span class="n">Execution</span><span class="o">&gt;&gt;</span> <span class="nf">allocationFutures</span> <span class="o">=</span> <span class="n">ejv</span><span class="p">.</span><span class="na">allocateResourcesForAll</span><span class="p">(</span>
				<span class="n">slotProvider</span><span class="p">,</span>
				<span class="n">queued</span><span class="p">,</span>
				<span class="n">LocationPreferenceConstraint</span><span class="p">.</span><span class="na">ALL</span><span class="p">,</span>
				<span class="n">allPreviousAllocationIds</span><span class="p">,</span>
				<span class="n">timeout</span><span class="p">);</span>
			<span class="n">allAllocationFutures</span><span class="p">.</span><span class="na">addAll</span><span class="p">(</span><span class="n">allocationFutures</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// this future is complete once all slot futures are complete.
</span><span class="c1"></span>		<span class="c1">// the future fails once one slot future fails.
</span><span class="c1"></span>		<span class="c1">// 等待所有需要调度的子任务都分配到资源
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">ConjunctFuture</span><span class="o">&lt;</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Execution</span><span class="o">&gt;&gt;</span> <span class="nf">allAllocationsFuture</span> <span class="o">=</span> <span class="n">FutureUtils</span><span class="p">.</span><span class="na">combineAll</span><span class="p">(</span><span class="n">allAllocationFutures</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">allAllocationsFuture</span><span class="p">.</span><span class="na">thenAccept</span><span class="p">(</span>
			<span class="p">(</span><span class="n">Collection</span><span class="o">&lt;</span><span class="n">Execution</span><span class="o">&gt;</span> <span class="nf">executionsToDeploy</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">Execution</span> <span class="nf">execution</span> <span class="o">:</span> <span class="n">executionsToDeploy</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">try</span> <span class="p">{</span>
						<span class="c1">//启动 Execution
</span><span class="c1"></span>						<span class="n">execution</span><span class="p">.</span><span class="na">deploy</span><span class="p">();</span>
					<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="k">new</span> <span class="n">CompletionException</span><span class="p">(</span>
							<span class="k">new</span> <span class="n">FlinkException</span><span class="p">(</span>
								<span class="n">String</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;Could not deploy execution %s.&#34;</span><span class="p">,</span> <span class="n">execution</span><span class="p">),</span>
								<span class="n">t</span><span class="p">));</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">})</span>
			<span class="p">.</span><span class="na">exceptionally</span><span class="p">(......)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>Execution</code> 是 <code>ExecutionVertex</code> 的一次执行，在调度的时候会先生成对任务的描述 <code>TaskDeploymentDescription</code>， <code>TaskDeploymentDescription</code> 包含了对输入的描述 <code>InputGateDeploymentDescriptor</code>, 对输出的描述 <code>ResultPartitionDeploymentDescriptor</code>，以及保存了这个 Task 中运行的所有算子运行时信息的 <code>TaskInformation</code> 和 <code>JobInformation</code>。生成了 <code>TaskDeploymentDescription</code> 通过 RPC 调用提交给 <code>TaskExecutor</code> 执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">Execution</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">deploy</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">JobException</span> <span class="p">{</span>
		<span class="p">......</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">// race double check, did we fail/cancel and do we need to release the slot?
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">state</span> <span class="o">!=</span> <span class="n">DEPLOYING</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slot</span><span class="p">.</span><span class="na">releaseSlot</span><span class="p">(</span><span class="k">new</span> <span class="n">FlinkException</span><span class="p">(</span><span class="s">&#34;Actual state of execution &#34;</span> <span class="o">+</span> <span class="k">this</span> <span class="o">+</span> <span class="s">&#34; (&#34;</span> <span class="o">+</span> <span class="n">state</span> <span class="o">+</span> <span class="s">&#34;) does not match expected state DEPLOYING.&#34;</span><span class="p">));</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="kd">final</span> <span class="nf">TaskDeploymentDescriptor</span> <span class="n">deployment</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="na">createDeploymentDescriptor</span><span class="p">(</span>
				<span class="n">attemptId</span><span class="p">,</span>
				<span class="n">slot</span><span class="p">,</span>
				<span class="n">taskRestore</span><span class="p">,</span>
				<span class="n">attemptNumber</span><span class="p">);</span>

			<span class="c1">// null taskRestore to let it be GC&#39;ed
</span><span class="c1"></span>			<span class="n">taskRestore</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

			<span class="kd">final</span> <span class="nf">TaskManagerGateway</span> <span class="n">taskManagerGateway</span> <span class="o">=</span> <span class="n">slot</span><span class="p">.</span><span class="na">getTaskManagerGateway</span><span class="p">();</span>

			<span class="kd">final</span> <span class="nf">ComponentMainThreadExecutor</span> <span class="n">jobMasterMainThreadExecutor</span> <span class="o">=</span>
				<span class="n">vertex</span><span class="p">.</span><span class="na">getExecutionGraph</span><span class="p">().</span><span class="na">getJobMasterMainThreadExecutor</span><span class="p">();</span>

			<span class="c1">// We run the submission in the future executor so that the serialization of large TDDs does not block
</span><span class="c1"></span>			<span class="c1">// the main thread and sync back to the main thread once submission is completed.
</span><span class="c1"></span>			<span class="n">CompletableFuture</span><span class="p">.</span><span class="na">supplyAsync</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="n">taskManagerGateway</span><span class="p">.</span><span class="na">submitTask</span><span class="p">(</span><span class="n">deployment</span><span class="p">,</span> <span class="n">rpcTimeout</span><span class="p">),</span> <span class="n">executor</span><span class="p">)</span>
				<span class="p">.</span><span class="na">thenCompose</span><span class="p">(</span><span class="n">Function</span><span class="p">.</span><span class="na">identity</span><span class="p">())</span>
				<span class="p">.</span><span class="na">whenCompleteAsync</span><span class="p">(</span>
					<span class="p">(</span><span class="n">ack</span><span class="p">,</span> <span class="n">failure</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">{</span>
						<span class="c1">// only respond to the failure case
</span><span class="c1"></span>						<span class="k">if</span> <span class="p">(</span><span class="n">failure</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
							<span class="k">if</span> <span class="p">(</span><span class="n">failure</span> <span class="nf">instanceof</span> <span class="n">TimeoutException</span><span class="p">)</span> <span class="p">{</span>
								<span class="n">String</span> <span class="nf">taskname</span> <span class="o">=</span> <span class="n">vertex</span><span class="p">.</span><span class="na">getTaskNameWithSubtaskIndex</span><span class="p">()</span> <span class="o">+</span> <span class="s">&#34; (&#34;</span> <span class="o">+</span> <span class="n">attemptId</span> <span class="o">+</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>

								<span class="n">markFailed</span><span class="p">(</span><span class="k">new</span> <span class="n">Exception</span><span class="p">(</span>
									<span class="s">&#34;Cannot deploy task &#34;</span> <span class="o">+</span> <span class="n">taskname</span> <span class="o">+</span> <span class="s">&#34; - TaskManager (&#34;</span> <span class="o">+</span> <span class="n">getAssignedResourceLocation</span><span class="p">()</span>
										<span class="o">+</span> <span class="s">&#34;) not responding after a rpcTimeout of &#34;</span> <span class="o">+</span> <span class="n">rpcTimeout</span><span class="p">,</span> <span class="n">failure</span><span class="p">));</span>
							<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
								<span class="n">markFailed</span><span class="p">(</span><span class="n">failure</span><span class="p">);</span>
							<span class="p">}</span>
						<span class="p">}</span>
					<span class="p">},</span>
					<span class="n">jobMasterMainThreadExecutor</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">markFailed</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="n">ExceptionUtils</span><span class="p">.</span><span class="na">rethrow</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="启动-task-线程">启动 Task 线程</h3>

<p>当 <code>TaskDeploymentDescription</code> 被提交到 <code>TaskExecutor</code> 后，<code>TaskExecutor</code> 会据此创建一个 <code>Task</code> 对象，并在构造函数中完成一些初始化操作，如根据 <code>InputGateDeploymentDescriptor</code> 创建 <code>InputGate</code>，根据 <code>ResultPartitionDeploymentDescriptor</code> 创建 <code>ResultPartition</code>。</p>

<p><code>Task</code> 实现了 <code>Runnable</code> 接口，每个 Task 都会在一个单独的线程中运行，Task 的启动流程包括：</p>

<ol>
<li>首先完成状态的初始化 <code>ExecutionState.CREATED</code> -&gt; <code>ExecutionState.DEPLOYING</code></li>
<li>任务装配<br />

<ul>
<li>创建一个用户加载用户代码的类加载器</li>
<li>通过反序列化得到 <code>ExecutionConfig</code>，从 <code>ExecutionConfig</code> 中可以的到所有算子相关的信息</li>
<li>向网络栈中注册 <code>Task</code>,为 <code>ResultPartition</code> 和 <code>InputGate</code> 分配缓冲池</li>
<li>初始化用户代码，通过反射得到 <code>AbstractInvokable</code>(<code>StreamTask</code>) 实例</li>
</ul></li>
<li>执行任务

<ul>
<li>状态转换 <code>ExecutionState.DEPLOYING</code> -&gt; <code>ExecutionState.RUNNING</code></li>
<li>调用 <code>AbstractInvokable.invoke()</code> 启动任务</li>
</ul></li>
</ol>

<p>如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">Task</span> <span class="p">{</span>
	<span class="cm">/**
</span><span class="cm">	 * The core work method that bootstraps the task and executes its code.
</span><span class="cm">	 */</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// ----------------------------
</span><span class="c1"></span>		<span class="c1">//  Initial State transition
</span><span class="c1"></span>		<span class="c1">// ----------------------------
</span><span class="c1"></span>		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ExecutionState</span> <span class="nf">current</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">executionState</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current</span> <span class="o">==</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">CREATED</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">transitionState</span><span class="p">(</span><span class="n">ExecutionState</span><span class="p">.</span><span class="na">CREATED</span><span class="p">,</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">DEPLOYING</span><span class="p">))</span> <span class="p">{</span>
					<span class="c1">// success, we can start our work
</span><span class="c1"></span>					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">......</span> <span class="c1">//handle other state
</span><span class="c1"></span>		<span class="p">}</span>

		<span class="c1">// all resource acquisitions and registrations from here on
</span><span class="c1"></span>		<span class="c1">// need to be undone in the end
</span><span class="c1"></span>		<span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Future</span><span class="o">&lt;</span><span class="n">Path</span><span class="o">&gt;&gt;</span> <span class="nf">distributedCacheEntries</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>
		<span class="n">AbstractInvokable</span> <span class="nf">invokable</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>

		<span class="k">try</span> <span class="p">{</span>
			<span class="p">......</span>
			<span class="n">userCodeClassLoader</span> <span class="o">=</span> <span class="n">createUserCodeClassloader</span><span class="p">();</span>
			<span class="kd">final</span> <span class="nf">ExecutionConfig</span> <span class="n">executionConfig</span> <span class="o">=</span> <span class="n">serializedExecutionConfig</span><span class="p">.</span><span class="na">deserializeValue</span><span class="p">(</span><span class="n">userCodeClassLoader</span><span class="p">);</span>

			<span class="n">network</span><span class="p">.</span><span class="na">registerTask</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">ResultPartition</span> <span class="nf">partition</span> <span class="o">:</span> <span class="n">producedPartitions</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">taskEventDispatcher</span><span class="p">.</span><span class="na">registerPartition</span><span class="p">(</span><span class="n">partition</span><span class="p">.</span><span class="na">getPartitionId</span><span class="p">());</span>
			<span class="p">}</span>

			<span class="n">Environment</span> <span class="nf">env</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RuntimeEnvironment</span><span class="p">(.......)</span>
			<span class="c1">// now load and instantiate the task&#39;s invokable code
</span><span class="c1"></span>			<span class="c1">// nameOfInvokableClass 是 JobVertex 的 invokableClassName，
</span><span class="c1"></span>			<span class="c1">// 每一个 StreamNode 在添加的时候都会有一个 jobVertexClass 属性
</span><span class="c1"></span>			<span class="c1">// 对于一个 operator chain，就是 head operator 对应的 invokableClassName，见 StreamingJobGraphGenerator.createChain
</span><span class="c1"></span>			<span class="c1">// 通过反射创建 AbstractInvokable 对象
</span><span class="c1"></span>			<span class="c1">// 对于 Stream 任务而言，就是 StreamTask 的子类，SourceStreamTask、OneInputStreamTask、TwoInputStreamTask 等
</span><span class="c1"></span>			<span class="n">invokable</span> <span class="o">=</span> <span class="n">loadAndInstantiateInvokable</span><span class="p">(</span><span class="n">userCodeClassLoader</span><span class="p">,</span> <span class="n">nameOfInvokableClass</span><span class="p">,</span> <span class="n">env</span><span class="p">);</span>

			<span class="c1">// we must make strictly sure that the invokable is accessible to the cancel() call
</span><span class="c1"></span>			<span class="c1">// by the time we switched to running.
</span><span class="c1"></span>			<span class="k">this</span><span class="p">.</span><span class="na">invokable</span> <span class="o">=</span> <span class="n">invokable</span><span class="p">;</span>

			<span class="c1">// switch to the RUNNING state, if that fails, we have been canceled/failed in the meantime
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transitionState</span><span class="p">(</span><span class="n">ExecutionState</span><span class="p">.</span><span class="na">DEPLOYING</span><span class="p">,</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="c1">// notify everyone that we switched to running
</span><span class="c1"></span>			<span class="n">taskManagerActions</span><span class="p">.</span><span class="na">updateTaskExecutionState</span><span class="p">(</span><span class="k">new</span> <span class="n">TaskExecutionState</span><span class="p">(</span><span class="n">jobId</span><span class="p">,</span> <span class="n">executionId</span><span class="p">,</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">));</span>
			<span class="c1">// make sure the user code classloader is accessible thread-locally
</span><span class="c1"></span>			<span class="n">executingThread</span><span class="p">.</span><span class="na">setContextClassLoader</span><span class="p">(</span><span class="n">userCodeClassLoader</span><span class="p">);</span>

			<span class="c1">// run the invokable
</span><span class="c1"></span>			<span class="c1">// 运行
</span><span class="c1"></span>			<span class="n">invokable</span><span class="p">.</span><span class="na">invoke</span><span class="p">();</span>

			<span class="c1">// make sure, we enter the catch block if the task leaves the invoke() method due
</span><span class="c1"></span>			<span class="c1">// to the fact that it has been canceled
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">isCanceledOrFailed</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="c1">// 正常结束
</span><span class="c1"></span>			<span class="c1">// finish the produced partitions. if this fails, we consider the execution failed.
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">(</span><span class="n">ResultPartition</span> <span class="nf">partition</span> <span class="o">:</span> <span class="n">producedPartitions</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">partition</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">partition</span><span class="p">.</span><span class="na">finish</span><span class="p">();</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">// try to mark the task as finished
</span><span class="c1"></span>			<span class="c1">// if that fails, the task was canceled/failed in the meantime
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transitionState</span><span class="p">(</span><span class="n">ExecutionState</span><span class="p">.</span><span class="na">RUNNING</span><span class="p">,</span> <span class="n">ExecutionState</span><span class="p">.</span><span class="na">FINISHED</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">......</span>
		<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
			<span class="p">......</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="streamtask">StreamTask</h3>

<p><code>AbstractInvokable</code> 是 <code>Task</code> 执行的主要逻辑，也是所有被执行的任务的基类，包括 Streaming 模式和 Batch 模式。在 Streaming 模式下，所有任务都继承自 <code>StreamTask</code>，包括 <code>StreamTask</code> 的子类包括 <code>SourceStreamTask</code>, <code>OneInputStreamTask</code>, <code>TwoInputStreamTask</code>, 以及用于迭代模式下的 <code>StreamIterationHead</code> 和 <code>StreamIterationTail</code>。</p>

<p>每一个 <code>StreamNode</code> 在添加到 <code>StreamGraph</code> 的时候都会有一个关联的 <code>jobVertexClass</code> 属性，这个属性就是该 <code>StreamNode</code> 对应的 <code>StreamTask</code> 类型；对于一个 <code>OperatorChain</code> 而言，它所对应的 <code>StreamTask</code> 就是其  head operator 对应的 <code>StreamTask</code>。</p>

<p><code>StreamTask</code> 完整的生命周期包括：</p>

<ul>
<li>创建状态存储后端，为 OperatorChain 中的所有算子提供状态</li>
<li>加载 OperatorChain 中的所有算子</li>
<li>所有的 operator 调用 <code>setup</code></li>
<li>task 相关的初始化操作</li>
<li>所有 operator 调用 <code>initializeState</code> 初始化状态</li>
<li>所有的 operator 调用 <code>open</code></li>
<li><code>run</code> 方法循环处理数据</li>
<li>所有 operator 调用 <code>close</code></li>
<li>所有 operator 调用 <code>dispose</code></li>
<li>通用的 cleanup 操作</li>
<li>task 相关的 cleanup 操作</li>
</ul>

<p>主要代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">abstract</span> <span class="nf">class</span> <span class="n">StreamTask</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">final</span> <span class="kt">void</span> <span class="nf">invoke</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="kt">boolean</span> <span class="nf">disposed</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">// -------- Initialize ---------
</span><span class="c1"></span>			<span class="c1">//创建状态存储后端
</span><span class="c1"></span>			<span class="n">stateBackend</span> <span class="o">=</span> <span class="n">createStateBackend</span><span class="p">();</span>
			<span class="n">checkpointStorage</span> <span class="o">=</span> <span class="n">stateBackend</span><span class="p">.</span><span class="na">createCheckpointStorage</span><span class="p">(</span><span class="n">getEnvironment</span><span class="p">().</span><span class="na">getJobID</span><span class="p">());</span>
			<span class="c1">// if the clock is not already set, then assign a default TimeServiceProvider
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">timerService</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ThreadFactory</span> <span class="nf">timerThreadFactory</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DispatcherThreadFactory</span><span class="p">(</span><span class="n">TRIGGER_THREAD_GROUP</span><span class="p">,</span>
					<span class="s">&#34;Time Trigger for &#34;</span> <span class="o">+</span> <span class="n">getName</span><span class="p">(),</span> <span class="n">getUserCodeClassLoader</span><span class="p">());</span>
				<span class="n">timerService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SystemProcessingTimeService</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">getCheckpointLock</span><span class="p">(),</span> <span class="n">timerThreadFactory</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="c1">//创建 OperatorChain，会加载每一个 operator，并调用 setup 方法
</span><span class="c1"></span>			<span class="n">operatorChain</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OperatorChain</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">recordWriters</span><span class="p">);</span>
			<span class="n">headOperator</span> <span class="o">=</span> <span class="n">operatorChain</span><span class="p">.</span><span class="na">getHeadOperator</span><span class="p">();</span>

			<span class="c1">// 和具体 StreamTask 子类相关的初始化操作
</span><span class="c1"></span>			<span class="n">init</span><span class="p">();</span>

			<span class="c1">// save the work of reloading state, etc, if the task is already canceled
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">canceled</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="c1">// we need to make sure that any triggers scheduled in open() cannot be
</span><span class="c1"></span>			<span class="c1">// executed before all operators are opened
</span><span class="c1"></span>			<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// both the following operations are protected by the lock
</span><span class="c1"></span>				<span class="c1">// so that we avoid race conditions in the case that initializeState()
</span><span class="c1"></span>				<span class="c1">// registers a timer, that fires before the open() is called.
</span><span class="c1"></span>				<span class="c1">//状态初始化
</span><span class="c1"></span>				<span class="n">initializeState</span><span class="p">();</span>
				<span class="c1">//open
</span><span class="c1"></span>				<span class="n">openAllOperators</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="c1">// final check to exit early before starting to run
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">canceled</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="c1">// let the task do its work
</span><span class="c1"></span>			<span class="n">isRunning</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
			<span class="c1">//开始处理数据，这里通常是个循环
</span><span class="c1"></span>			<span class="n">run</span><span class="p">();</span>

			<span class="c1">// if this left the run() method cleanly despite the fact that this was canceled,
</span><span class="c1"></span>			<span class="c1">// make sure the &#34;clean shutdown&#34; is not attempted
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">canceled</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">// this is part of the main logic, so if this fails, the task is considered failed
</span><span class="c1"></span>				<span class="n">closeAllOperators</span><span class="p">();</span>
				<span class="c1">// make sure no new timers can come
</span><span class="c1"></span>				<span class="n">timerService</span><span class="p">.</span><span class="na">quiesce</span><span class="p">();</span>
				<span class="c1">// only set the StreamTask to not running after all operators have been closed!
</span><span class="c1"></span>				<span class="c1">// See FLINK-7430
</span><span class="c1"></span>				<span class="n">isRunning</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">// make sure all timers finish
</span><span class="c1"></span>			<span class="n">timerService</span><span class="p">.</span><span class="na">awaitPendingAfterQuiesce</span><span class="p">();</span>
			<span class="c1">// make sure all buffered data is flushed
</span><span class="c1"></span>			<span class="n">operatorChain</span><span class="p">.</span><span class="na">flushOutputs</span><span class="p">();</span>
			<span class="c1">// make an attempt to dispose the operators such that failures in the dispose call
</span><span class="c1"></span>			<span class="c1">// still let the computation fail
</span><span class="c1"></span>			<span class="n">tryDisposeAllOperators</span><span class="p">();</span>
			<span class="n">disposed</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
			<span class="c1">//cleanup
</span><span class="c1"></span>		<span class="p">}</span>

	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h3 id="operatorchain">OperatorChain</h3>

<p>前面已经提了很多次 <code>OperatorChain</code>，下面我们就看下 <code>OperatorChain</code> 是如何加载的，主要逻辑都在 <code>OperatorChain</code> 的构造函数中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">OperatorChain</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">OP</span> <span class="nf">extends</span> <span class="n">StreamOperator</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;&gt;</span> <span class="nf">implements</span> <span class="n">StreamStatusMaintainer</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">OperatorChain</span><span class="p">(</span>
			<span class="n">StreamTask</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">OP</span><span class="o">&gt;</span> <span class="nf">containingTask</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">RecordWriter</span><span class="o">&lt;</span><span class="n">SerializationDelegate</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;&gt;&gt;&gt;</span> <span class="nf">recordWriters</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">ClassLoader</span> <span class="n">userCodeClassloader</span> <span class="o">=</span> <span class="n">containingTask</span><span class="p">.</span><span class="na">getUserCodeClassLoader</span><span class="p">();</span>
		<span class="kd">final</span> <span class="nf">StreamConfig</span> <span class="n">configuration</span> <span class="o">=</span> <span class="n">containingTask</span><span class="p">.</span><span class="na">getConfiguration</span><span class="p">();</span>

		<span class="c1">//head operator
</span><span class="c1"></span>		<span class="n">headOperator</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">.</span><span class="na">getStreamOperator</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">);</span>

		<span class="c1">//OperatorChain 内部所有的 operator 的配置
</span><span class="c1"></span>		<span class="c1">// we read the chained configs, and the order of record writer registrations by output name
</span><span class="c1"></span>		<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;</span> <span class="nf">chainedConfigs</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">.</span><span class="na">getTransitiveChainedTaskConfigsWithSelf</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">);</span>

		<span class="c1">// create the final output stream writers
</span><span class="c1"></span>		<span class="c1">// we iterate through all the out edges from this job vertex and create a stream output
</span><span class="c1"></span>		<span class="c1">// 所有的输出边，这是对外输出，不包含内部 operator 之间的的数据传输
</span><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="o">&gt;</span> <span class="nf">outEdgesInOrder</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">.</span><span class="na">getOutEdgesInOrder</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">);</span>
		<span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="p">,</span> <span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">streamOutputMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">outEdgesInOrder</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>
		<span class="k">this</span><span class="p">.</span><span class="na">streamOutputs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;</span><span class="p">[</span><span class="n">outEdgesInOrder</span><span class="p">.</span><span class="na">size</span><span class="p">()];</span>
		<span class="c1">// from here on, we need to make sure that the output writers are shut down again on failure
</span><span class="c1"></span>		<span class="kt">boolean</span> <span class="nf">success</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">//对外输出的 RecordWriterOutput
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">outEdgesInOrder</span><span class="p">.</span><span class="na">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">StreamEdge</span> <span class="nf">outEdge</span> <span class="o">=</span> <span class="n">outEdgesInOrder</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

				<span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;</span> <span class="n">streamOutput</span> <span class="o">=</span> <span class="n">createStreamOutput</span><span class="p">(</span>
					<span class="n">recordWriters</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
					<span class="n">outEdge</span><span class="p">,</span>
					<span class="n">chainedConfigs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">outEdge</span><span class="p">.</span><span class="na">getSourceId</span><span class="p">()),</span>
					<span class="n">containingTask</span><span class="p">.</span><span class="na">getEnvironment</span><span class="p">());</span>

				<span class="k">this</span><span class="p">.</span><span class="na">streamOutputs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">streamOutput</span><span class="p">;</span>
				<span class="n">streamOutputMap</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">outEdge</span><span class="p">,</span> <span class="n">streamOutput</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="c1">// we create the chain of operators and grab the collector that leads into the chain
</span><span class="c1"></span>			<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamOperator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">allOps</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">chainedConfigs</span><span class="p">.</span><span class="na">size</span><span class="p">());</span>
			<span class="c1">//这里会递归调用，为 OperatorChain 内部的所有的 Operator 都创建 output
</span><span class="c1"></span>			<span class="k">this</span><span class="p">.</span><span class="na">chainEntryPoint</span> <span class="o">=</span> <span class="n">createOutputCollector</span><span class="p">(</span>
				<span class="n">containingTask</span><span class="p">,</span>
				<span class="n">configuration</span><span class="p">,</span>
				<span class="n">chainedConfigs</span><span class="p">,</span>
				<span class="n">userCodeClassloader</span><span class="p">,</span>
				<span class="n">streamOutputMap</span><span class="p">,</span>
				<span class="n">allOps</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">headOperator</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//chainEntryPoint 是 headOperator 的 output
</span><span class="c1"></span>				<span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;&gt;</span> <span class="nf">output</span> <span class="o">=</span> <span class="n">getChainEntryPoint</span><span class="p">();</span>
				<span class="c1">//header operator 调用 setup 方法
</span><span class="c1"></span>				<span class="n">headOperator</span><span class="p">.</span><span class="na">setup</span><span class="p">(</span><span class="n">containingTask</span><span class="p">,</span> <span class="n">configuration</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>

				<span class="n">headOperator</span><span class="p">.</span><span class="na">getMetricGroup</span><span class="p">().</span><span class="na">gauge</span><span class="p">(</span><span class="n">MetricNames</span><span class="p">.</span><span class="na">IO_CURRENT_OUTPUT_WATERMARK</span><span class="p">,</span> <span class="n">output</span><span class="p">.</span><span class="na">getWatermarkGauge</span><span class="p">());</span>
			<span class="p">}</span>

			<span class="c1">// add head operator to end of chain
</span><span class="c1"></span>			<span class="n">allOps</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">headOperator</span><span class="p">);</span>
			<span class="k">this</span><span class="p">.</span><span class="na">allOperators</span> <span class="o">=</span> <span class="n">allOps</span><span class="p">.</span><span class="na">toArray</span><span class="p">(</span><span class="k">new</span> <span class="n">StreamOperator</span><span class="o">&lt;?&gt;</span><span class="p">[</span><span class="n">allOps</span><span class="p">.</span><span class="na">size</span><span class="p">()]);</span>
			<span class="n">success</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">finally</span> <span class="p">{</span>
			<span class="c1">// make sure we clean up after ourselves in case of a failure after acquiring
</span><span class="c1"></span>			<span class="c1">// the first resources
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">for</span> <span class="p">(</span><span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;</span> <span class="n">output</span> <span class="o">:</span> <span class="k">this</span><span class="p">.</span><span class="na">streamOutputs</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">output</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">output</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//创建 output collector
</span><span class="c1"></span>	<span class="kd">private</span> <span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">createOutputCollector</span><span class="p">(</span>
			<span class="n">StreamTask</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="n">containingTask</span><span class="p">,</span>
			<span class="n">StreamConfig</span> <span class="nf">operatorConfig</span><span class="p">,</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;</span> <span class="nf">chainedConfigs</span><span class="p">,</span>
			<span class="n">ClassLoader</span> <span class="nf">userCodeClassloader</span><span class="p">,</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="p">,</span> <span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">streamOutputs</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamOperator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">allOperators</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">List</span><span class="o">&lt;</span><span class="n">Tuple2</span><span class="o">&lt;</span><span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">StreamEdge</span><span class="o">&gt;&gt;</span> <span class="nf">allOutputs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">4</span><span class="p">);</span>
		<span class="c1">// create collectors for the network outputs
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">outputEdge</span> <span class="o">:</span> <span class="n">operatorConfig</span><span class="p">.</span><span class="na">getNonChainedOutputs</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">))</span> <span class="p">{</span>
			<span class="nd">@SuppressWarnings</span><span class="p">(</span><span class="s">&#34;unchecked&#34;</span><span class="p">)</span>
			<span class="n">RecordWriterOutput</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">output</span> <span class="o">=</span> <span class="p">(</span><span class="n">RecordWriterOutput</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="n">streamOutputs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">outputEdge</span><span class="p">);</span>

			<span class="n">allOutputs</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">outputEdge</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="c1">// Create collectors for the chained outputs
</span><span class="c1"></span>		<span class="c1">// OperatorChain 内部 Operator 之间的边
</span><span class="c1"></span>		<span class="k">for</span> <span class="p">(</span><span class="n">StreamEdge</span> <span class="nf">outputEdge</span> <span class="o">:</span> <span class="n">operatorConfig</span><span class="p">.</span><span class="na">getChainedOutputs</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="nf">outputId</span> <span class="o">=</span> <span class="n">outputEdge</span><span class="p">.</span><span class="na">getTargetId</span><span class="p">();</span>
			<span class="n">StreamConfig</span> <span class="nf">chainedOpConfig</span> <span class="o">=</span> <span class="n">chainedConfigs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">outputId</span><span class="p">);</span>

			<span class="c1">//创建当前节点的下游节点，并返回当前节点的 output
</span><span class="c1"></span>			<span class="c1">//createChainedOperator 在创建 operator 的时候，会调用 createOutputCollector 为 operator 创建 output
</span><span class="c1"></span>			<span class="c1">//随意会形成递归调用关系，所有的 operator 以及它们的 output 都会被创建出来
</span><span class="c1"></span>			<span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">output</span> <span class="o">=</span> <span class="n">createChainedOperator</span><span class="p">(</span>
				<span class="n">containingTask</span><span class="p">,</span>
				<span class="n">chainedOpConfig</span><span class="p">,</span>
				<span class="n">chainedConfigs</span><span class="p">,</span>
				<span class="n">userCodeClassloader</span><span class="p">,</span>
				<span class="n">streamOutputs</span><span class="p">,</span>
				<span class="n">allOperators</span><span class="p">,</span>
				<span class="n">outputEdge</span><span class="p">.</span><span class="na">getOutputTag</span><span class="p">());</span>
			<span class="n">allOutputs</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">Tuple2</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">outputEdge</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="c1">// if there are multiple outputs, or the outputs are directed, we need to
</span><span class="c1"></span>		<span class="c1">// wrap them as one output
</span><span class="c1"></span>		<span class="n">List</span><span class="o">&lt;</span><span class="n">OutputSelector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="nf">selectors</span> <span class="o">=</span> <span class="n">operatorConfig</span><span class="p">.</span><span class="na">getOutputSelectors</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">selectors</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">selectors</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">// simple path, no selector necessary
</span><span class="c1"></span>			<span class="c1">//只有一个输出
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">allOutputs</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">allOutputs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">0</span><span class="p">).</span><span class="na">f0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="c1">//不止有一个输出，需要使用 BroadcastingOutputCollector 进行封装
</span><span class="c1"></span>				<span class="c1">// send to N outputs. Note that this includes the special case
</span><span class="c1"></span>				<span class="c1">// of sending to zero outputs
</span><span class="c1"></span>				<span class="nd">@SuppressWarnings</span><span class="p">({</span><span class="s">&#34;unchecked&#34;</span><span class="p">,</span> <span class="s">&#34;rawtypes&#34;</span><span class="p">})</span>
				<span class="n">Output</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">[]</span> <span class="nf">asArray</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Output</span><span class="p">[</span><span class="n">allOutputs</span><span class="p">.</span><span class="na">size</span><span class="p">()];</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">allOutputs</span><span class="p">.</span><span class="na">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">asArray</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">allOutputs</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="na">f0</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="c1">// This is the inverse of creating the normal ChainingOutput.
</span><span class="c1"></span>				<span class="c1">// If the chaining output does not copy we need to copy in the broadcast output,
</span><span class="c1"></span>				<span class="c1">// otherwise multi-chaining would not work correctly.
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">containingTask</span><span class="p">.</span><span class="na">getExecutionConfig</span><span class="p">().</span><span class="na">isObjectReuseEnabled</span><span class="p">())</span> <span class="p">{</span>
					<span class="k">return</span> <span class="k">new</span> <span class="n">CopyingBroadcastingOutputCollector</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">asArray</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span>  <span class="p">{</span>
					<span class="k">return</span> <span class="k">new</span> <span class="n">BroadcastingOutputCollector</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">asArray</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="c1">// selector present, more complex routing necessary
</span><span class="c1"></span>			<span class="c1">// 存在 selector，用 DirectedOutput 进行封装
</span><span class="c1"></span>			<span class="c1">// This is the inverse of creating the normal ChainingOutput.
</span><span class="c1"></span>			<span class="c1">// If the chaining output does not copy we need to copy in the broadcast output,
</span><span class="c1"></span>			<span class="c1">// otherwise multi-chaining would not work correctly.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">containingTask</span><span class="p">.</span><span class="na">getExecutionConfig</span><span class="p">().</span><span class="na">isObjectReuseEnabled</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">return</span> <span class="k">new</span> <span class="n">CopyingDirectedOutput</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">selectors</span><span class="p">,</span> <span class="n">allOutputs</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="k">new</span> <span class="n">DirectedOutput</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">selectors</span><span class="p">,</span> <span class="n">allOutputs</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="nf">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;&gt;</span> <span class="nf">createChainedOperator</span><span class="p">(</span>
			<span class="n">StreamTask</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span> <span class="n">containingTask</span><span class="p">,</span>
			<span class="n">StreamConfig</span> <span class="nf">operatorConfig</span><span class="p">,</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="p">,</span> <span class="n">StreamConfig</span><span class="o">&gt;</span> <span class="nf">chainedConfigs</span><span class="p">,</span>
			<span class="n">ClassLoader</span> <span class="nf">userCodeClassloader</span><span class="p">,</span>
			<span class="n">Map</span><span class="o">&lt;</span><span class="n">StreamEdge</span><span class="p">,</span> <span class="n">RecordWriterOutput</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">streamOutputs</span><span class="p">,</span>
			<span class="n">List</span><span class="o">&lt;</span><span class="n">StreamOperator</span><span class="o">&lt;?&gt;&gt;</span> <span class="n">allOperators</span><span class="p">,</span>
			<span class="n">OutputTag</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">outputTag</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// create the output that the operator writes to first. this may recursively create more operators
</span><span class="c1"></span>		<span class="c1">// 为当前 Operator 创建 output
</span><span class="c1"></span>		<span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;&gt;</span> <span class="nf">chainedOperatorOutput</span> <span class="o">=</span> <span class="n">createOutputCollector</span><span class="p">(</span>
			<span class="n">containingTask</span><span class="p">,</span>
			<span class="n">operatorConfig</span><span class="p">,</span>
			<span class="n">chainedConfigs</span><span class="p">,</span>
			<span class="n">userCodeClassloader</span><span class="p">,</span>
			<span class="n">streamOutputs</span><span class="p">,</span>
			<span class="n">allOperators</span><span class="p">);</span>

		<span class="c1">// now create the operator and give it the output collector to write its output to
</span><span class="c1"></span>		<span class="c1">//从 StreamConfig 中取出当前 Operator
</span><span class="c1"></span>		<span class="n">OneInputStreamOperator</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="nf">chainedOperator</span> <span class="o">=</span> <span class="n">operatorConfig</span><span class="p">.</span><span class="na">getStreamOperator</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">);</span>

		<span class="n">chainedOperator</span><span class="p">.</span><span class="na">setup</span><span class="p">(</span><span class="n">containingTask</span><span class="p">,</span> <span class="n">operatorConfig</span><span class="p">,</span> <span class="n">chainedOperatorOutput</span><span class="p">);</span>

		<span class="n">allOperators</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">chainedOperator</span><span class="p">);</span>

		<span class="c1">//这里是在为当前 operator 前向的 operator 创建 output
</span><span class="c1"></span>		<span class="c1">//所以当前 operator 被传递给前一个 operator 的 output，这样前一个 operator 的输出就可以直接调用当前 operator
</span><span class="c1"></span>		<span class="n">WatermarkGaugeExposingOutput</span><span class="o">&lt;</span><span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;&gt;</span> <span class="nf">currentOperatorOutput</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">containingTask</span><span class="p">.</span><span class="na">getExecutionConfig</span><span class="p">().</span><span class="na">isObjectReuseEnabled</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">currentOperatorOutput</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChainingOutput</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">chainedOperator</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">outputTag</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">TypeSerializer</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">inSerializer</span> <span class="o">=</span> <span class="n">operatorConfig</span><span class="p">.</span><span class="na">getTypeSerializerIn1</span><span class="p">(</span><span class="n">userCodeClassloader</span><span class="p">);</span>
			<span class="n">currentOperatorOutput</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CopyingChainingOutput</span><span class="o">&lt;&gt;</span><span class="p">(</span><span class="n">chainedOperator</span><span class="p">,</span> <span class="n">inSerializer</span><span class="p">,</span> <span class="n">outputTag</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// wrap watermark gauges since registered metrics must be unique
</span><span class="c1"></span>		<span class="n">chainedOperator</span><span class="p">.</span><span class="na">getMetricGroup</span><span class="p">().</span><span class="na">gauge</span><span class="p">(</span><span class="n">MetricNames</span><span class="p">.</span><span class="na">IO_CURRENT_INPUT_WATERMARK</span><span class="p">,</span> <span class="n">currentOperatorOutput</span><span class="p">.</span><span class="na">getWatermarkGauge</span><span class="p">()</span><span class="o">::</span><span class="n">getValue</span><span class="p">);</span>
		<span class="n">chainedOperator</span><span class="p">.</span><span class="na">getMetricGroup</span><span class="p">().</span><span class="na">gauge</span><span class="p">(</span><span class="n">MetricNames</span><span class="p">.</span><span class="na">IO_CURRENT_OUTPUT_WATERMARK</span><span class="p">,</span> <span class="n">chainedOperatorOutput</span><span class="p">.</span><span class="na">getWatermarkGauge</span><span class="p">()</span><span class="o">::</span><span class="n">getValue</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">currentOperatorOutput</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里的主要逻辑其实就是递归地创建 <code>OpeartorChain</code> 内部所有的 <code>StreamOperator</code>，并为每一个 <code>StreamOperator</code> 创建 <code>Output</code> collecto，结合本文上面对 <code>Output</code> 的介绍应该就很容易理解了。</p>

<h3 id="几类不同的-streamtask">几类不同的 StreamTask</h3>

<p><code>StreamTask</code> 的 <code>init</code> 方法和 <code>run</code> 方法等都是在子类中自行实现的。下面我们先主要看先 <code>SourceStramTask</code>, <code>OneInputStreamTask</code> 和 <code>TwoInputStreamTask</code>。对于在迭代场景下使用的 <code>StreamIterationHead</code> 和 <code>StreamIterationTail</code> 这里先不加以介绍了，留在后面分析迭代任务的实现时再进行说明。</p>

<h4 id="sourcestreamtask">SourceStreamTask</h4>

<p>顾名思义，<code>SourceStreamTask</code> 负责为下游任务生成数据，因此它没有输入，只负责对外输出记录。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">SourceStreamTask</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">SRC</span> <span class="nf">extends</span> <span class="n">SourceFunction</span><span class="o">&lt;</span><span class="n">OUT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">OP</span> <span class="nf">extends</span> <span class="n">StreamSource</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">SRC</span><span class="o">&gt;&gt;</span>
	<span class="nf">extends</span> <span class="n">StreamTask</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">OP</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// we check if the source is actually inducing the checkpoints, rather
</span><span class="c1"></span>		<span class="c1">// than the trigger
</span><span class="c1"></span>		<span class="n">SourceFunction</span><span class="o">&lt;?&gt;</span> <span class="n">source</span> <span class="o">=</span> <span class="n">headOperator</span><span class="p">.</span><span class="na">getUserFunction</span><span class="p">();</span>
		<span class="c1">// 如果用户提供的 SourceFunction 是 ExternallyInducedSource，则需要创建一个 CheckpointTrigger 对象提供给 ExternallyInducedSource
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">source</span> <span class="nf">instanceof</span> <span class="n">ExternallyInducedSource</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">externallyInducedCheckpoints</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

			<span class="n">ExternallyInducedSource</span><span class="p">.</span><span class="na">CheckpointTrigger</span> <span class="nf">triggerHook</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ExternallyInducedSource</span><span class="p">.</span><span class="na">CheckpointTrigger</span><span class="p">()</span> <span class="p">{</span>
				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="nf">void</span> <span class="n">triggerCheckpoint</span><span class="p">(</span><span class="kt">long</span> <span class="nf">checkpointId</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">FlinkException</span> <span class="p">{</span>
					<span class="c1">// TODO - we need to see how to derive those. We should probably not encode this in the
</span><span class="c1"></span>					<span class="c1">// TODO -   source&#39;s trigger message, but do a handshake in this task between the trigger
</span><span class="c1"></span>					<span class="c1">// TODO -   message from the master, and the source&#39;s trigger notification
</span><span class="c1"></span>					<span class="kd">final</span> <span class="nf">CheckpointOptions</span> <span class="n">checkpointOptions</span> <span class="o">=</span> <span class="n">CheckpointOptions</span><span class="p">.</span><span class="na">forCheckpointWithDefaultLocation</span><span class="p">();</span>
					<span class="kd">final</span> <span class="nf">long</span> <span class="n">timestamp</span> <span class="o">=</span> <span class="n">System</span><span class="p">.</span><span class="na">currentTimeMillis</span><span class="p">();</span>

					<span class="kd">final</span> <span class="nf">CheckpointMetaData</span> <span class="n">checkpointMetaData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CheckpointMetaData</span><span class="p">(</span><span class="n">checkpointId</span><span class="p">,</span> <span class="n">timestamp</span><span class="p">);</span>

					<span class="k">try</span> <span class="p">{</span>
						<span class="n">SourceStreamTask</span><span class="p">.</span><span class="na">super</span><span class="p">.</span><span class="na">triggerCheckpoint</span><span class="p">(</span><span class="n">checkpointMetaData</span><span class="p">,</span> <span class="n">checkpointOptions</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">catch</span> <span class="p">(</span><span class="n">RuntimeException</span> <span class="o">|</span> <span class="n">FlinkException</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="n">e</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="k">new</span> <span class="n">FlinkException</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="na">getMessage</span><span class="p">(),</span> <span class="n">e</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">};</span>

			<span class="p">((</span><span class="n">ExternallyInducedSource</span><span class="o">&lt;?</span><span class="p">,</span> <span class="o">?&gt;</span><span class="p">)</span> <span class="n">source</span><span class="p">).</span><span class="na">setCheckpointTrigger</span><span class="p">(</span><span class="n">triggerHook</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">run</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="c1">// 对source而言，就是调用 head operator 的 run 方法
</span><span class="c1"></span>		<span class="c1">//head operator 是一个 StreamSource，最终会调用用户提供的 SourceFunction 的 run 方法，一般是一个循环
</span><span class="c1"></span>		<span class="c1">//head operator 通过 Output 将数据传递给下游的算子
</span><span class="c1"></span>		<span class="n">headOperator</span><span class="p">.</span><span class="na">run</span><span class="p">(</span><span class="n">getCheckpointLock</span><span class="p">(),</span> <span class="n">getStreamStatusMaintainer</span><span class="p">());</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="oneinputstreamtask">OneInputStreamTask</h4>

<p>对于 <code>OneInputStreamTask</code>，它的主要执行逻辑就是不断循环调用 <code>StreamInputProcessor.processInpt()</code> 方法。</p>

<p><code>StreamInputProcessor</code> 从缓冲区中读取记录或 watermark 等消息，然后调用 <code>streamOperator.processElement(record)</code> 交给 head operator 进行处理，并依次将处理结果交给下游算子。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">OneInputStreamTask</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;</span> <span class="nf">extends</span> <span class="n">StreamTask</span><span class="o">&lt;</span><span class="n">OUT</span><span class="p">,</span> <span class="n">OneInputStreamOperator</span><span class="o">&lt;</span><span class="n">IN</span><span class="p">,</span> <span class="n">OUT</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">init</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="c1">//创建一个 StreamInputProcessor
</span><span class="c1"></span>		<span class="n">StreamConfig</span> <span class="nf">configuration</span> <span class="o">=</span> <span class="n">getConfiguration</span><span class="p">();</span>

		<span class="n">TypeSerializer</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">inSerializer</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">.</span><span class="na">getTypeSerializerIn1</span><span class="p">(</span><span class="n">getUserCodeClassLoader</span><span class="p">());</span>
		<span class="kt">int</span> <span class="nf">numberOfInputs</span> <span class="o">=</span> <span class="n">configuration</span><span class="p">.</span><span class="na">getNumberOfInputs</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">numberOfInputs</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">InputGate</span><span class="p">[]</span> <span class="nf">inputGates</span> <span class="o">=</span> <span class="n">getEnvironment</span><span class="p">().</span><span class="na">getAllInputGates</span><span class="p">();</span>

			<span class="n">inputProcessor</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StreamInputProcessor</span><span class="o">&lt;&gt;</span><span class="p">(</span>
					<span class="n">inputGates</span><span class="p">,</span>
					<span class="n">inSerializer</span><span class="p">,</span>
					<span class="k">this</span><span class="p">,</span>
					<span class="n">configuration</span><span class="p">.</span><span class="na">getCheckpointMode</span><span class="p">(),</span>
					<span class="n">getCheckpointLock</span><span class="p">(),</span>
					<span class="n">getEnvironment</span><span class="p">().</span><span class="na">getIOManager</span><span class="p">(),</span>
					<span class="n">getEnvironment</span><span class="p">().</span><span class="na">getTaskManagerInfo</span><span class="p">().</span><span class="na">getConfiguration</span><span class="p">(),</span>
					<span class="n">getStreamStatusMaintainer</span><span class="p">(),</span>
					<span class="k">this</span><span class="p">.</span><span class="na">headOperator</span><span class="p">,</span>
					<span class="n">getEnvironment</span><span class="p">().</span><span class="na">getMetricGroup</span><span class="p">().</span><span class="na">getIOMetricGroup</span><span class="p">(),</span>
					<span class="n">inputWatermarkGauge</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">headOperator</span><span class="p">.</span><span class="na">getMetricGroup</span><span class="p">().</span><span class="na">gauge</span><span class="p">(</span><span class="n">MetricNames</span><span class="p">.</span><span class="na">IO_CURRENT_INPUT_WATERMARK</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">inputWatermarkGauge</span><span class="p">);</span>
		<span class="c1">// wrap watermark gauge since registered metrics must be unique
</span><span class="c1"></span>		<span class="n">getEnvironment</span><span class="p">().</span><span class="na">getMetricGroup</span><span class="p">().</span><span class="na">gauge</span><span class="p">(</span><span class="n">MetricNames</span><span class="p">.</span><span class="na">IO_CURRENT_INPUT_WATERMARK</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="na">inputWatermarkGauge</span><span class="o">::</span><span class="n">getValue</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">run</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="c1">// cache processor reference on the stack, to make the code more JIT friendly
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">StreamInputProcessor</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">inputProcessor</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">inputProcessor</span><span class="p">;</span>
		<span class="c1">//循环调用 StreamInputProcessor.processInput 方法
</span><span class="c1"></span>		<span class="k">while</span> <span class="p">(</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">inputProcessor</span><span class="p">.</span><span class="na">processInput</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">// all the work happens in the &#34;processInput&#34; method
</span><span class="c1"></span>		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">class</span> <span class="n">StreamInputProcessor</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">processInput</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isFinished</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">numRecordsIn</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="n">numRecordsIn</span> <span class="o">=</span> <span class="p">((</span><span class="n">OperatorMetricGroup</span><span class="p">)</span> <span class="n">streamOperator</span><span class="p">.</span><span class="na">getMetricGroup</span><span class="p">()).</span><span class="na">getIOMetricGroup</span><span class="p">().</span><span class="na">getNumRecordsInCounter</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">LOG</span><span class="p">.</span><span class="na">warn</span><span class="p">(</span><span class="s">&#34;An exception occurred during the metrics setup.&#34;</span><span class="p">,</span> <span class="n">e</span><span class="p">);</span>
				<span class="n">numRecordsIn</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SimpleCounter</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">//这里虽然是一个while循环，但其实只会处理一条记录，因为单条记录可能需要多个 buffer 传输
</span><span class="c1"></span>		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">currentRecordDeserializer</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//反序列化
</span><span class="c1"></span>				<span class="n">DeserializationResult</span> <span class="nf">result</span> <span class="o">=</span> <span class="n">currentRecordDeserializer</span><span class="p">.</span><span class="na">getNextRecord</span><span class="p">(</span><span class="n">deserializationDelegate</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="na">isBufferConsumed</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//如果buffer里面的数据已经被消费了，则归还buffer
</span><span class="c1"></span>					<span class="n">currentRecordDeserializer</span><span class="p">.</span><span class="na">getCurrentBuffer</span><span class="p">().</span><span class="na">recycleBuffer</span><span class="p">();</span>
					<span class="n">currentRecordDeserializer</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="na">isFullRecord</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//得到了一条完整的记录
</span><span class="c1"></span>					<span class="n">StreamElement</span> <span class="nf">recordOrMark</span> <span class="o">=</span> <span class="n">deserializationDelegate</span><span class="p">.</span><span class="na">getInstance</span><span class="p">();</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">recordOrMark</span><span class="p">.</span><span class="na">isWatermark</span><span class="p">())</span> <span class="p">{</span>
						<span class="c1">// handle watermark
</span><span class="c1"></span>						<span class="n">statusWatermarkValve</span><span class="p">.</span><span class="na">inputWatermark</span><span class="p">(</span><span class="n">recordOrMark</span><span class="p">.</span><span class="na">asWatermark</span><span class="p">(),</span> <span class="n">currentChannel</span><span class="p">);</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recordOrMark</span><span class="p">.</span><span class="na">isStreamStatus</span><span class="p">())</span> <span class="p">{</span>
						<span class="c1">// handle stream status
</span><span class="c1"></span>						<span class="n">statusWatermarkValve</span><span class="p">.</span><span class="na">inputStreamStatus</span><span class="p">(</span><span class="n">recordOrMark</span><span class="p">.</span><span class="na">asStreamStatus</span><span class="p">(),</span> <span class="n">currentChannel</span><span class="p">);</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recordOrMark</span><span class="p">.</span><span class="na">isLatencyMarker</span><span class="p">())</span> <span class="p">{</span>
						<span class="c1">// handle latency marker
</span><span class="c1"></span>						<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">streamOperator</span><span class="p">.</span><span class="na">processLatencyMarker</span><span class="p">(</span><span class="n">recordOrMark</span><span class="p">.</span><span class="na">asLatencyMarker</span><span class="p">());</span>
						<span class="p">}</span>
						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="c1">// now we can do the actual processing
</span><span class="c1"></span>						<span class="c1">//是一条正常的记录，调用 operator 的处理方法，最终会调用用户自定义的函数的处理方法
</span><span class="c1"></span>						<span class="n">StreamRecord</span><span class="o">&lt;</span><span class="n">IN</span><span class="o">&gt;</span> <span class="nf">record</span> <span class="o">=</span> <span class="n">recordOrMark</span><span class="p">.</span><span class="na">asRecord</span><span class="p">();</span>
						<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
							<span class="n">numRecordsIn</span><span class="p">.</span><span class="na">inc</span><span class="p">();</span>
							<span class="n">streamOperator</span><span class="p">.</span><span class="na">setKeyContextElement1</span><span class="p">(</span><span class="n">record</span><span class="p">);</span>
							<span class="n">streamOperator</span><span class="p">.</span><span class="na">processElement</span><span class="p">(</span><span class="n">record</span><span class="p">);</span>
						<span class="p">}</span>
						<span class="c1">//处理完一条记录，结束本次调用
</span><span class="c1"></span>						<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">//获取下一个 BufferOrEvent，这是个阻塞的调用
</span><span class="c1"></span>			<span class="kd">final</span> <span class="nf">BufferOrEvent</span> <span class="n">bufferOrEvent</span> <span class="o">=</span> <span class="n">barrierHandler</span><span class="p">.</span><span class="na">getNextNonBlocked</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">isBuffer</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//如果是Buffer，要确定是哪个 channel 的，然后用对应 channel 的反序列化器解析
</span><span class="c1"></span>					<span class="c1">//不同channel在反序列化的时候不能混淆
</span><span class="c1"></span>					<span class="n">currentChannel</span> <span class="o">=</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">();</span>
					<span class="n">currentRecordDeserializer</span> <span class="o">=</span> <span class="n">recordDeserializers</span><span class="p">[</span><span class="n">currentChannel</span><span class="p">];</span>
					<span class="n">currentRecordDeserializer</span><span class="p">.</span><span class="na">setNextBuffer</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getBuffer</span><span class="p">());</span>
				<span class="p">}</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="c1">// Event received
</span><span class="c1"></span>					<span class="kd">final</span> <span class="nf">AbstractEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">();</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="na">getClass</span><span class="p">()</span> <span class="o">!=</span> <span class="n">EndOfPartitionEvent</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="p">(</span><span class="s">&#34;Unexpected event: &#34;</span> <span class="o">+</span> <span class="n">event</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="c1">//表明上游结束了
</span><span class="c1"></span>				<span class="n">isFinished</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">barrierHandler</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
					<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Trailing data in checkpoint barrier handler.&#34;</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="twoinputstreamtask">TwoInputStreamTask</h4>

<p><code>TwoInputStreamTask</code> 和 <code>OneInputStreamTask</code> 的处理逻辑类似，只是要对两个上游的输入分别调用 <code>TwoInputStreamOperator.processElement1</code> 和 <code>TwoInputStreamOperator.processElement2</code> 进行处理。这里就不再赘述了。</p>

<h2 id="小节">小节</h2>

<p>Task 是 Flink 任务调度的最小单位。本文简要地介绍了 Task 的生命周期以及数据的处理的基本模式。通过 StreamTask -&gt; StreamOperator -&gt; User-define-function 这样的封装，用户自定义的数据处理逻辑最终得以调度执行。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-master/internals/task_lifecycle.html#interrupted-execution">Task Lifecycle</a></li>
</ul>

<p>-EOF-</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">原始链接</span>
    <span class="item-content"><a href="https://blog.jrwang.me/2019/flink-source-code-task-lifecycle/">https://blog.jrwang.me/2019/flink-source-code-task-lifecycle/</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-09-12
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flink/">Flink</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2019/flink-source-code-state/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Flink 源码阅读笔记（10）- State 管理</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/flink-source-code-data-exchange/">
            <span class="next-text nav-default">Flink 源码阅读笔记（8）- Task 之间的数据传输</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="jrthe42/blog-comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jrthe42@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/jrthe42" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/jrthe42" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://blog.jrwang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.f79f403f.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-66913886-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
