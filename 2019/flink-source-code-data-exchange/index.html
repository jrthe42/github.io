<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="想入非非就是寻找神奇" />



  <meta name="keywords" content="Flink," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中必然涉及到网络通信，文中也会对 Flink 的网络栈的实现，包括反压机制等，进行分析。 概览Flink 的数据交换机制在设计时遵循两个基本原则：  数据交换的控制流（例如，为初始化数据交换而发出的消息）是">
<meta name="keywords" content="Flink">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink 源码阅读笔记（8）- Task 之间的数据传输">
<meta property="og:url" content="http://blog.jrwang.me/2019/flink-source-code-data-exchange/index.html">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中必然涉及到网络通信，文中也会对 Flink 的网络栈的实现，包括反压机制等，进行分析。 概览Flink 的数据交换机制在设计时遵循两个基本原则：  数据交换的控制流（例如，为初始化数据交换而发出的消息）是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cwiki.apache.org/confluence/download/attachments/53741520/controlflow.png?version=1&modificationDate=1426849323000&api=v2">
<meta property="og:image" content="https://cwiki.apache.org/confluence/download/attachments/53741520/transfer.png?version=1&modificationDate=1426849435000&api=v2">
<meta property="og:updated_time" content="2019-08-29T03:25:48.259Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Flink 源码阅读笔记（8）- Task 之间的数据传输">
<meta name="twitter:description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中必然涉及到网络通信，文中也会对 Flink 的网络栈的实现，包括反压机制等，进行分析。 概览Flink 的数据交换机制在设计时遵循两个基本原则：  数据交换的控制流（例如，为初始化数据交换而发出的消息）是">
<meta name="twitter:image" content="https://cwiki.apache.org/confluence/download/attachments/53741520/controlflow.png?version=1&modificationDate=1426849323000&api=v2">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Flink 源码阅读笔记（8）- Task 之间的数据传输 | JR's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66913886-2', 'auto');
  ga('send', 'pageview');
</script>




  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">JR's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Flink 源码阅读笔记（8）- Task 之间的数据传输
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2019-05-25T20:03:00+08:00" content="2019-05-25">
            2019-05-25
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中必然涉及到网络通信，文中也会对 Flink 的网络栈的实现，包括反压机制等，进行分析。</p>
<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>Flink 的数据交换机制在设计时遵循两个基本原则：</p>
<ol>
<li>数据交换的控制流（例如，为初始化数据交换而发出的消息）是由接收端发起的</li>
<li>数据交换的数据流（例如，在网络中实际传输的数据被抽象为 IntermediateResult 的概念）是可插拔的。这意味着系统基于相同的实现逻辑既可以支持 Streaming 模式也可以支持 Batch 模式下数据的传输</li>
</ol>
<p>我们知道，在一个 TaskManager 中可能会同时并行运行多个 Task，每个 Task 都在单独的线程中运行。在不同的 TaskManager 中运行的 Task 之间进行数据传输要基于网络进行通信。实际上，是 TaskManager 和另一个 TaskManager 之间通过网络进行通信，通信是基于 Netty 创建的标准的 TCP 连接，同一个 TaskManager 内运行的不同 Task 会复用网络连接。</p>
<p>关于 Flink 的数据交换机制的具体流程，Flink 的 <a href="https://cwiki.apache.org/confluence/display/FLINK/Data+exchange+between+tasks" target="_blank" rel="noopener">wiki</a> 中给出了一个比较详细的说明，在这里引述一下其中的内容，对我们后续分析具体的实现细节很有帮助。</p>
<h3 id="数据交换的控制流"><a href="#数据交换的控制流" class="headerlink" title="数据交换的控制流"></a>数据交换的控制流</h3><p><img src="https://cwiki.apache.org/confluence/download/attachments/53741520/controlflow.png?version=1&amp;modificationDate=1426849323000&amp;api=v2" alt="controlflow"><br>上图代表了一个简单的 map-reduce 类型的作业，有两个并行的任务。有两个 TaskManager，每个 TaskManager 都分别运行一个 map Task 和一个 reduce Task。我们重点观察 M1 和 R2 这两个 Task 之间的数据传输的发起过程。数据传输用粗箭头表示，消息用细箭头表示。首先，M1 产出了一个 ResultPartition(RP1)（箭头1）。当这个 RP 可以被消费是，会告知 JobManager（箭头2）。JobManager 会通知想要接收这个 RP 分区数据的接收者（tasks R1 and R2）当前分区数据已经准备好。如果接受放还没有被调度，这将会触发对应任务的部署（箭头 3a，3b）。接着，接受方会从 RP 中请求数据（箭头 4a，4b）。这将会初始化 Task 之间的数据传输（5a,5b）,数据传输可能是本地的(5a)，也可能是通过 TaskManager 的网络栈进行（5b）。对于一个 RP 什么时候告知 JobManager 当前已经出于可用状态，在这个过程中是有充分的自由度的：例如，如果在 RP1 在告知 JM 之前已经完整地产出了所有的数据（甚至可能写入了本地文件），那么相应的数据传输更类似于 Batch 的批交换；如果 RP1 在第一条记录产出时就告知 JM，那么就是 Streaming 流交换。</p>
<h3 id="字节缓冲区在两个-Task-之间的传输"><a href="#字节缓冲区在两个-Task-之间的传输" class="headerlink" title="字节缓冲区在两个 Task 之间的传输"></a>字节缓冲区在两个 Task 之间的传输</h3><p><img src="https://cwiki.apache.org/confluence/download/attachments/53741520/transfer.png?version=1&amp;modificationDate=1426849435000&amp;api=v2" alt="datatransfer"></p>
<p>上面这张图展示了一个细节更加丰富的流程，描述了一条数据记录从生产者传输到消费者的完整生命周期。</p>
<p>最初，MapDriver 生成数据记录（通过 Collector 收集）并传递给 RecordWriter 对象。RecordWriter 包含一组序列化器，每个消费数据的 Task 分别对应一个。 ChannelSelector 会选择一个或多个序列化器处理记录。例如，如果记录需要被广播，那么就会被交给每一个序列化器进行处理；如果记录是按照 hash 进行分区的，ChannelSelector 会计算记录的哈希值，然后选择对应的序列化器。</p>
<p>序列化器会将记录序列化为二进制数据，并将其存放在固定大小的 buffer 中（一条记录可能需要跨越多个 buffer）。这些 buffer 被交给 BufferWriter 处理，写入到 ResulePartition（RP）中。 RP 有多个子分区（ResultSubpartitions - RSs）构成，每一个子分区都只收集特定消费者需要的数据。在上图中，需要被第二个 reducer （在 TaskManager 2 中）消费的记录被放在 RS2 中。由于第一个 Buffer 已经生成，RS2 就变成可被消费的状态了（注意，这个行为实现了一个 streaming shuffle），接着它通知 JobManager。</p>
<p>JobManager查找RS2的消费者，然后通知 TaskManager 2 一个数据块已经可以访问了。通知TM2的消息会被发送到InputChannel，该inputchannel被认为是接收这个buffer的，接着通知RS2可以初始化一个网络传输了。然后，RS2通过TM1的网络栈请求该buffer，然后双方基于 Netty 准备进行数据传输。网络连接是在TaskManager（而非特定的task）之间长时间存在的。</p>
<p>JobManager 查找 RS2 的消费者，并通知 TM2 一个数据块已经可以被访问了。通知 TM2 的消息被传递给 InputChannel，这个 InputChannel 负责接受这个 buffer。紧接着就通知 RS2 可以发起一起网络传输。 RS2 将 buffer 交给 TM1 的网络栈，然后基于 Netty 进行数据传输。网络连接是在 TM 之间长期存在在，而不是在独立的 Task 之间。</p>
<p>一旦 Buffer 被 TM2 接收，它同样会经过一个类似的结构，起始于 InputChannel，进入 InputGate（它包含多个IC），最终进入一个反序列化器（RecordDeserializer），它会从 buffer 中将记录还原成指定类型的对象，然后将其传递给接收数据的 Task。</p>
<h2 id="几个基本概念"><a href="#几个基本概念" class="headerlink" title="几个基本概念"></a>几个基本概念</h2><p>在开始介绍 Flink 中数据交换机制的具体实现之前，我们有必要先对几个重要的概念进行一下梳理。这几个概念主要是到对 Flink 作业运行时产生的中间结果的抽象。</p>
<h3 id="IntermediateDataset"><a href="#IntermediateDataset" class="headerlink" title="IntermediateDataset"></a>IntermediateDataset</h3><p><code>IntermediateDataset</code> 是在 <code>JobGraph</code> 中对中间结果的抽象。我们知道，<code>JobGraph</code> 是对 <code>StreamGraph</code> 进一步进行优化后得到的逻辑图，它尽量把可以 chain 到一起 operator 合并为一个 <code>JobVertex</code>，而 <code>IntermediateDataset</code> 就表示一个 <code>JobVertex</code> 的输出结果。<code>JobVertex</code> 的输入是 <code>JobEdge</code>，而 <code>JobEdge</code> 可以看作是 <code>IntermediateDataset</code> 的消费者。一个 <code>JobVertex</code> 也可能产生多个 <code>IntermediateDataset</code>。需要说明的一点是，目前一个 <code>IntermediateDataset</code> 实际上只会有一个 <code>JobEdge</code> 作为消费者，也就是说，一个 <code>JobVertex</code> 的下游有多少 <code>JobVertex</code> 需要依赖当前节点的数据，那么当前节点就有对应数量的 <code>IntermediateDataset</code>。</p>
<h3 id="IntermediateResult-和-IntermediateResultpartition"><a href="#IntermediateResult-和-IntermediateResultpartition" class="headerlink" title="IntermediateResult 和 IntermediateResultpartition"></a>IntermediateResult 和 IntermediateResultpartition</h3><p>在 JobManager 中，<code>JobGraph</code> 被进一步转换成可以被调度的并行化版本的执行图，即 <code>ExecutionGraph</code>。在 <code>ExecutionGraph</code> 中，和 <code>JobVertex</code> 对应的节点是 <code>ExecutionJobVertex</code>，和 <code>IntermediateDataset</code> 对应的则是 <code>IntermediataResult</code>。由于一个节点在实际运行时可能有多个并行子任务同时运行，所以 <code>ExecutionJobVertex</code> 按照并行度的设置被拆分为多个 <code>ExecutionVertex</code>，每一个表示一个并行的子任务。同样的，一个 <code>IntermediataResult</code> 也会被拆分为多个 <code>IntermediateResultPartition</code>，<code>IntermediateResultPartition</code> 对应 <code>ExecutionVertex</code> 的输出结果。一个 <code>IntermediateDataset</code> 只有一个消费者，那么一个 <code>IntermediataResult</code> 也只会有一个消费者；但是到了 <code>IntermediateResultPartition</code> 这里，由于节点被拆分成了并行化的节点，所以一个 <code>IntermediateResultPartition</code> 可能会有多个 <code>ExecutionEdge</code> 作为消费者。</p>
<h3 id="ResultPartition-和-ResultSubpartition"><a href="#ResultPartition-和-ResultSubpartition" class="headerlink" title="ResultPartition 和 ResultSubpartition"></a>ResultPartition 和 ResultSubpartition</h3><p><code>ExecutionGraph</code> 还是 JobManager 中用于描述作业拓扑的一种逻辑上的数据结构，其中表示并行子任务的 <code>ExecutionVertex</code> 会被调度到 TaskManager 中执行，一个 <code>Task</code> 对应一个 <code>ExecutionVertex</code>。同 <code>ExecutionVertex</code> 的输出结果 <code>IntermediateResultPartition</code> 相对应的则是 <code>ResultPartition</code>。<code>IntermediateResultPartition</code> 可能会有多个 <code>ExecutionEdge</code> 作为消费者，那么在 Task 这里，<code>ResultPartition</code> 就会被拆分为多个 <code>ResultSubpartition</code>，下游每一个需要从当前 <code>ResultPartition</code> 消费数据的 Task 都会有一个专属的 <code>ResultSubpartition</code>。</p>
<p><code>ResultPartitionType</code> 指定了 <code>ResultPartition</code> 的不同属性，这些属性包括<strong>是否流水线模式</strong>、<strong>是否会产生反压</strong>以及<strong>是否限制使用的 Network buffer 的数量</strong>。<code>ResultPartitionType</code> 有三个枚举值：</p>
<ul>
<li><code>BLOCKING</code>：非流水线模式，无反压，不限制使用的网络缓冲的数量</li>
<li><code>PIPELINED</code>：流水线模式，有反压，不限制使用的网络缓冲的数量</li>
<li><code>PIPELINED_BOUNDED</code>：流水线模式，有反压，限制使用的网络缓冲的数量</li>
</ul>
<p>其中<strong>是否流水线模式</strong>这个属性会对消费行为产生很大的影响：如果是流水线模式，那么在 ResultPartition 接收到第一个 Buffer 时，消费者任务就可以进行准备消费；而如果非流水线模式，那么消费者将等到生产端任务生产完数据之后才进行消费。目前在 Stream 模式下使用的类型是 <code>PIPELINED_BOUNDED</code>。</p>
<h3 id="InputGate-和-InputChannel"><a href="#InputGate-和-InputChannel" class="headerlink" title="InputGate 和 InputChannel"></a>InputGate 和 InputChannel</h3><p>在 Task 中，<code>InputGate</code> 是对输入的封装，<code>InputGate</code> 是和 JobGraph 中 <code>JobEdge</code> 一一对应的。也就是说，<code>InputGate</code> 实际上对应的是该 Task 依赖的上游算子（包含多个并行子任务），每个 <code>InputGate</code> 消费了一个或多个 <code>ResultPartition</code>。<code>InputGate</code> 由 <code>InputChannel</code> 构成，<code>InputChannel</code> 和 ExecutionGraph 中的 <code>ExecutionEdge</code> 一一对应；也就是说， <code>InputChannel</code> 和 <code>ResultSubpartition</code> 一一相连，一个 <code>InputChannel</code> 接收一个 <code>ResultSubpartition</code> 的输出。根据读取的 <code>ResultSubpartition</code> 的位置，<code>InputChannel</code> 有 <code>LocalInputChannel</code> 和 <code>RemoteInputChannel</code> 两种不同的实现。</p>
<h2 id="数据交换机制的具体实现"><a href="#数据交换机制的具体实现" class="headerlink" title="数据交换机制的具体实现"></a>数据交换机制的具体实现</h2><p>数据交换从本质上来说就是一个典型的<strong>生产者-消费者</strong>模型，上游算子生产数据到 <code>ResultPartition</code> 中，下游算子通过 <code>InputGate</code> 消费数据。由于不同的 <code>Task</code> 可能在同一个 TaskManager 中运行，也可能在不同的 TaskManager 中运行：对于前者，不同的 Task 其实就是同一个 TaskManager 进程中的不同的线程，它们的数据交换就是在本地不同线程间进行的；对于后者，必须要通过网络进行通信。我们分别来介绍下这两个不同场景下数据交换的具体实现。通过合理的设计和抽象，Flink 确保本地数据交换和通过网络进行数据交换可以复用同一套代码。</p>
<h3 id="Task-的输入和输出"><a href="#Task-的输入和输出" class="headerlink" title="Task 的输入和输出"></a>Task 的输入和输出</h3><h4 id="Task-的输出"><a href="#Task-的输出" class="headerlink" title="Task 的输出"></a>Task 的输出</h4><p>Task 产出的每一个 <code>ResultPartition</code> 都有一个关联的 <code>ResultPartitionWriter</code>，同时也都有一个独立的 <code>LocalBufferPool</code> 负责提供写入数据所需的 buffer。<code>ResultPartion</code> 实现了 <code>ResultPartitionWriter</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultPartition</span> <span class="keyword">implements</span> <span class="title">ResultPartitionWriter</span>, <span class="title">BufferPoolOwner</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Type of this partition. Defines the concrete subpartition implementation to use. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultPartitionType partitionType;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ResultPartition 由 ResultSubpartition 构成，</span></span><br><span class="line">  <span class="comment">// ResultSubpartition 的数量由下游消费 Task 数和 DistributionPattern 来决定。</span></span><br><span class="line">  <span class="comment">// 例如，如果是 FORWARD，则下游只有一个消费者；如果是 SHUFFLE，则下游消费者的数量和下游算子的并行度一样</span></span><br><span class="line">  <span class="comment">/** The subpartitions of this partition. At least one. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultSubpartition[] subpartitions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//ResultPartitionManager 管理当前 TaskManager 所有的 ResultPartition</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultPartitionManager partitionManager;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通知当前ResultPartition有数据可供消费的回调函数回调</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultPartitionConsumableNotifier partitionConsumableNotifier;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> BufferPool bufferPool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在有数据产出时，是否需要发送消息来调度或更新消费者（Stream模式下调度模式为 ScheduleMode.EAGER，无需发通知）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> sendScheduleOrUpdateConsumersMessage;</span><br><span class="line">  <span class="comment">//是否已经通知了消费者</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasNotifiedPipelinedConsumers;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ResultPartition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		String owningTaskName,</span></span></span><br><span class="line"><span class="function"><span class="params">		TaskActions taskActions, // actions on the owning task</span></span></span><br><span class="line"><span class="function"><span class="params">		JobID jobId,</span></span></span><br><span class="line"><span class="function"><span class="params">		ResultPartitionID partitionId,</span></span></span><br><span class="line"><span class="function"><span class="params">		ResultPartitionType partitionType,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> numberOfSubpartitions,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> numTargetKeyGroups,</span></span></span><br><span class="line"><span class="function"><span class="params">		ResultPartitionManager partitionManager,</span></span></span><br><span class="line"><span class="function"><span class="params">		ResultPartitionConsumableNotifier partitionConsumableNotifier,</span></span></span><br><span class="line"><span class="function"><span class="params">		IOManager ioManager,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> sendScheduleOrUpdateConsumersMessage)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.owningTaskName = checkNotNull(owningTaskName);</span><br><span class="line">    <span class="keyword">this</span>.taskActions = checkNotNull(taskActions);</span><br><span class="line">    <span class="keyword">this</span>.jobId = checkNotNull(jobId);</span><br><span class="line">    <span class="keyword">this</span>.partitionId = checkNotNull(partitionId);</span><br><span class="line">    <span class="keyword">this</span>.partitionType = checkNotNull(partitionType);</span><br><span class="line">    <span class="keyword">this</span>.subpartitions = <span class="keyword">new</span> ResultSubpartition[numberOfSubpartitions];</span><br><span class="line">    <span class="keyword">this</span>.numTargetKeyGroups = numTargetKeyGroups;</span><br><span class="line">    <span class="keyword">this</span>.partitionManager = checkNotNull(partitionManager);</span><br><span class="line">    <span class="keyword">this</span>.partitionConsumableNotifier = checkNotNull(partitionConsumableNotifier);</span><br><span class="line">    <span class="keyword">this</span>.sendScheduleOrUpdateConsumersMessage = sendScheduleOrUpdateConsumersMessage;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the subpartitions.</span></span><br><span class="line">    <span class="keyword">switch</span> (partitionType) &#123;</span><br><span class="line">      <span class="comment">// Batch 模式，SpillableSubpartition，在 Buffer 不充足时将结果写入磁盘</span></span><br><span class="line">      <span class="keyword">case</span> BLOCKING:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subpartitions.length; i++) &#123;</span><br><span class="line">          subpartitions[i] = <span class="keyword">new</span> SpillableSubpartition(i, <span class="keyword">this</span>, ioManager);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Streaming 模式，PipelinedSubpartition</span></span><br><span class="line">      <span class="keyword">case</span> PIPELINED:</span><br><span class="line">      <span class="keyword">case</span> PIPELINED_BOUNDED:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; subpartitions.length; i++) &#123;</span><br><span class="line">          subpartitions[i] = <span class="keyword">new</span> PipelinedSubpartition(i, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unsupported result partition type."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initially, partitions should be consumed once before release.</span></span><br><span class="line">    pin();</span><br><span class="line">    LOG.debug(<span class="string">"&#123;&#125;: Initialized &#123;&#125;"</span>, owningTaskName, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task 启动的时候会向 <code>NetworkEnvironment</code> 进行注册，这里会为每一个 <code>ResultPartition</code> 分配 <code>LocalBufferPool</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkEnvironment</span> </span>&#123;</span><br><span class="line">  <span class="comment">//注册一个Task，要给这个Task的输入和输出分配 buffer pool</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerTask</span><span class="params">(Task task)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResultPartition[] producedPartitions = task.getProducedPartitions();</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">      ......</span><br><span class="line">      <span class="comment">//输出</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">final</span> ResultPartition partition : producedPartitions) &#123;</span><br><span class="line">        setupPartition(partition);</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupPartition</span><span class="params">(ResultPartition partition)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferPool bufferPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果PartitionType 是 unbounded，则不限制buffer pool 的最大大小，否则为 sub-partition * taskmanager.network.memory.buffers-per-channel</span></span><br><span class="line">      <span class="keyword">int</span> maxNumberOfMemorySegments = partition.getPartitionType().isBounded() ?</span><br><span class="line">        partition.getNumberOfSubpartitions() * config.networkBuffersPerChannel() +</span><br><span class="line">          config.floatingNetworkBuffersPerGate() : Integer.MAX_VALUE;</span><br><span class="line">      <span class="comment">// If the partition type is back pressure-free, we register with the buffer pool for</span></span><br><span class="line">      <span class="comment">// callbacks to release memory.</span></span><br><span class="line">      <span class="comment">//创建一个 LocalBufferPool，请求的最少的 MemeorySegment 数量和 sub-partition 一致</span></span><br><span class="line">      <span class="comment">//如果没有反压，则需要自己处理 buffer 的回收（主要是在batch模式）</span></span><br><span class="line">      bufferPool = networkBufferPool.createBufferPool(partition.getNumberOfSubpartitions(),</span><br><span class="line">        maxNumberOfMemorySegments,</span><br><span class="line">        partition.getPartitionType().hasBackPressure() ? Optional.empty() : Optional.of(partition));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//给这个 ResultPartition 分配 LocalBufferPool</span></span><br><span class="line">      partition.registerBufferPool(bufferPool);</span><br><span class="line">      <span class="comment">//向 ResultPartitionManager 注册</span></span><br><span class="line">      resultPartitionManager.registerResultPartition(partition);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task 通过 <code>RecordWriter</code> 将结果写入 <code>ResultPartition</code> 中。<code>RecordWriter</code> 是对 <code>ResultPartitionWriter</code> 的一层封装，并负责将记录对象序列化到 buffer 中。先来看一下 <code>RecordWriter</code> 的成员变量和构造函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordWriter</span> </span>&#123;</span><br><span class="line">  <span class="comment">//底层的 ResultPartition</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultPartitionWriter targetPartition;</span><br><span class="line">  <span class="comment">//决定一条记录应该写入哪一个channel， 即 sub-partition</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ChannelSelector&lt;T&gt; channelSelector;</span><br><span class="line">  <span class="comment">//channel的数量，即 sub-partition的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numberOfChannels;</span><br><span class="line">  <span class="comment">//broadcast记录</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] broadcastChannels;</span><br><span class="line">  <span class="comment">//序列化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> RecordSerializer&lt;T&gt; serializer;</span><br><span class="line">  <span class="comment">//供每一个 channel 写入数据使用</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;BufferBuilder&gt;[] bufferBuilders;</span><br><span class="line">  <span class="comment">//定时强制 flush 输出buffer</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Optional&lt;OutputFlusher&gt; outputFlusher;</span><br><span class="line"></span><br><span class="line">  RecordWriter(ResultPartitionWriter writer, ChannelSelector&lt;T&gt; channelSelector, <span class="keyword">long</span> timeout, String taskName) &#123;</span><br><span class="line">    <span class="keyword">this</span>.targetPartition = writer;</span><br><span class="line">    <span class="keyword">this</span>.channelSelector = channelSelector;</span><br><span class="line">    <span class="keyword">this</span>.numberOfChannels = writer.getNumberOfSubpartitions();</span><br><span class="line">    <span class="keyword">this</span>.channelSelector.setup(numberOfChannels);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化器，用于指的一提将一条记录序列化到多个buffer中</span></span><br><span class="line">    <span class="keyword">this</span>.serializer = <span class="keyword">new</span> SpanningRecordSerializer&lt;T&gt;();</span><br><span class="line">    <span class="keyword">this</span>.bufferBuilders = <span class="keyword">new</span> Optional[numberOfChannels];</span><br><span class="line">    <span class="keyword">this</span>.broadcastChannels = <span class="keyword">new</span> <span class="keyword">int</span>[numberOfChannels];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numberOfChannels; i++) &#123;</span><br><span class="line">      broadcastChannels[i] = i;</span><br><span class="line">      bufferBuilders[i] = Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    checkArgument(timeout &gt;= -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">this</span>.flushAlways = (timeout == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (timeout == -<span class="number">1</span> || timeout == <span class="number">0</span>) &#123;</span><br><span class="line">      outputFlusher = Optional.empty();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//根据超时时间创建一个定时 flush 输出 buffer 的线程</span></span><br><span class="line">      String threadName = taskName == <span class="keyword">null</span> ?</span><br><span class="line">        DEFAULT_OUTPUT_FLUSH_THREAD_NAME :</span><br><span class="line">        DEFAULT_OUTPUT_FLUSH_THREAD_NAME + <span class="string">" for "</span> + taskName;</span><br><span class="line">      outputFlusher = Optional.of(<span class="keyword">new</span> OutputFlusher(threadName, timeout));</span><br><span class="line">      outputFlusher.get().start();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Task 通过 <code>RecordWriter</code> 输出一条记录时，主要流程为：</p>
<ol>
<li>通过 ChannelSelector 确定写入的目标 channel</li>
<li>使用 RecordSerializer 对记录进行序列化</li>
<li>向 ResultPartition 请求 BufferBuilder，用于写入序列化结果</li>
<li>向 ResultPartition 添加 BufferConsumer，用于读取写入 Buffer 的数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RecordWriter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(T record)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    checkErroneous();</span><br><span class="line">    <span class="comment">//channelSelector确定目标channel</span></span><br><span class="line">    emit(record, channelSelector.selectChannel(record));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">emit</span><span class="params">(T record, <span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    serializer.serializeRecord(record);</span><br><span class="line">    <span class="comment">//将序列化结果写入buffer</span></span><br><span class="line">    <span class="keyword">if</span> (copyFromSerializerToTargetChannel(targetChannel)) &#123;</span><br><span class="line">      <span class="comment">//清除序列化使用的buffer（这个是序列化时临时写入的byte[]）,减少内存占用</span></span><br><span class="line">      serializer.prune();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将序列化结果写入buffer</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">copyFromSerializerToTargetChannel</span><span class="params">(<span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// We should reset the initial position of the intermediate serialization buffer before</span></span><br><span class="line">    <span class="comment">// copying, so the serialization results can be copied to multiple target buffers.</span></span><br><span class="line">    serializer.reset();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> pruneTriggered = <span class="keyword">false</span>;</span><br><span class="line">    BufferBuilder bufferBuilder = getBufferBuilder(targetChannel);</span><br><span class="line">    SerializationResult result = serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">    <span class="keyword">while</span> (result.isFullBuffer()) &#123;</span><br><span class="line">      <span class="comment">//buffer 写满了，调用 bufferBuilder.finish 方法</span></span><br><span class="line">      numBytesOut.inc(bufferBuilder.finish());</span><br><span class="line">      numBuffersOut.inc();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If this was a full record, we are done. Not breaking out of the loop at this point</span></span><br><span class="line">      <span class="comment">// will lead to another buffer request before breaking out (that would not be a</span></span><br><span class="line">      <span class="comment">// problem per se, but it can lead to stalls in the pipeline).</span></span><br><span class="line">      <span class="keyword">if</span> (result.isFullRecord()) &#123;</span><br><span class="line">        <span class="comment">//当前这条记录也完整输出了</span></span><br><span class="line">        pruneTriggered = <span class="keyword">true</span>;</span><br><span class="line">        bufferBuilders[targetChannel] = Optional.empty();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//当前这条记录没有写完，申请新的 buffer 写入</span></span><br><span class="line">      bufferBuilder = requestNewBufferBuilder(targetChannel);</span><br><span class="line">      result = serializer.copyToBufferBuilder(bufferBuilder);</span><br><span class="line">    &#125;</span><br><span class="line">    checkState(!serializer.hasSerializedData(), <span class="string">"All data should be written at once"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flushAlways) &#123;</span><br><span class="line">      <span class="comment">//强制刷新结果</span></span><br><span class="line">      targetPartition.flush(targetChannel);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pruneTriggered;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> BufferBuilder <span class="title">getBufferBuilder</span><span class="params">(<span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bufferBuilders[targetChannel].isPresent()) &#123;</span><br><span class="line">      <span class="keyword">return</span> bufferBuilders[targetChannel].get();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> requestNewBufferBuilder(targetChannel);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求新的 BufferBuilder，用于写入数据 如果当前没有可用的 buffer，会阻塞</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> BufferBuilder <span class="title">requestNewBufferBuilder</span><span class="params">(<span class="keyword">int</span> targetChannel)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    checkState(!bufferBuilders[targetChannel].isPresent() || bufferBuilders[targetChannel].get().isFinished());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 LocalBufferPool 中请求 BufferBuilder</span></span><br><span class="line">    BufferBuilder bufferBuilder = targetPartition.getBufferProvider().requestBufferBuilderBlocking();</span><br><span class="line">    bufferBuilders[targetChannel] = Optional.of(bufferBuilder);</span><br><span class="line">    <span class="comment">//添加一个BufferConsumer，用于读取写入到 MemorySegment 的数据</span></span><br><span class="line">    targetPartition.addBufferConsumer(bufferBuilder.createBufferConsumer(), targetChannel);</span><br><span class="line">    <span class="keyword">return</span> bufferBuilder;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>向 <code>ResultPartition</code> 添加一个 <code>BufferConsumer</code>， <code>ResultPartition</code> 会将其转交给对应的 <code>ResultSubpartition</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultPartition</span> <span class="title">implement</span> <span class="title">ResultPartitionWriter</span> </span>&#123;</span><br><span class="line"><span class="comment">//向指定的 subpartition 添加一个 buffer</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBufferConsumer</span><span class="params">(BufferConsumer bufferConsumer, <span class="keyword">int</span> subpartitionIndex)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkNotNull(bufferConsumer);</span><br><span class="line"></span><br><span class="line">    ResultSubpartition subpartition;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      checkInProduceState();</span><br><span class="line">      subpartition = subpartitions[subpartitionIndex];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      bufferConsumer.close();</span><br><span class="line">      <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//添加 BufferConsumer，说明已经有数据生成了</span></span><br><span class="line">    <span class="keyword">if</span> (subpartition.add(bufferConsumer)) &#123;</span><br><span class="line">      notifyPipelinedConsumers();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Notifies pipelined consumers of this result partition once.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyPipelinedConsumers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对于 Streaming 模式的任务，由于调度模式为 EAGER，所有的 task 都已经部署了，下面的通知不会触发</span></span><br><span class="line">    <span class="keyword">if</span> (sendScheduleOrUpdateConsumersMessage &amp;&amp; !hasNotifiedPipelinedConsumers &amp;&amp; partitionType.isPipelined()) &#123;</span><br><span class="line">      <span class="comment">//对于 PIPELINE 类型的 ResultPartition，在第一条记录产生时，</span></span><br><span class="line">      <span class="comment">//会告知 JobMaster 当前 ResultPartition 可被消费，这会触发下游消费者 Task 的部署</span></span><br><span class="line">      partitionConsumableNotifier.notifyPartitionConsumable(jobId, partitionId, taskActions);</span><br><span class="line">      hasNotifiedPipelinedConsumers = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面已经看到，根据 <code>ResultPartitionType</code> 的不同，<code>ResultSubpartition</code> 的实现类也不同。对于 Streaming 模式，使用的是 <code>PipelinedSubpartition</code> :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSubpartition</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The index of the subpartition at the parent partition. */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The parent partition this subpartition belongs to. */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ResultPartition parent;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** All buffers of this subpartition. Access to the buffers is synchronized on this object. */</span></span><br><span class="line">  <span class="comment">//当前 subpartiion 堆积的所有的 Buffer 的队列</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ArrayDeque&lt;BufferConsumer&gt; buffers = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The number of non-event buffers currently in this subpartition. */</span></span><br><span class="line">  <span class="comment">//当前 subpartiion 中堆积的 buffer 的数量</span></span><br><span class="line">  <span class="meta">@GuardedBy</span>(<span class="string">"buffers"</span>)</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> buffersInBacklog;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelinedSubpartition</span> <span class="keyword">extends</span> <span class="title">ResultSubpartition</span> </span>&#123;</span><br><span class="line">  <span class="comment">//用于消费写入的 Buffer</span></span><br><span class="line">  <span class="keyword">private</span> PipelinedSubpartitionView readView;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//index 是当前 sub-paritition 的索引</span></span><br><span class="line">  PipelinedSubpartition(<span class="keyword">int</span> index, ResultPartition parent) &#123;</span><br><span class="line">    <span class="keyword">super</span>(index, parent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(BufferConsumer bufferConsumer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> add(bufferConsumer, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加一个新的BufferConsumer</span></span><br><span class="line">  <span class="comment">//这个参数里的 finish 指的是整个 subpartition 都完成了</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(BufferConsumer bufferConsumer, <span class="keyword">boolean</span> finish)</span> </span>&#123;</span><br><span class="line">    checkNotNull(bufferConsumer);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> notifyDataAvailable;</span><br><span class="line">    <span class="keyword">synchronized</span> (buffers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isFinished || isReleased) &#123;</span><br><span class="line">        bufferConsumer.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Add the bufferConsumer and update the stats</span></span><br><span class="line">      buffers.add(bufferConsumer);</span><br><span class="line">      updateStatistics(bufferConsumer);</span><br><span class="line">      <span class="comment">//更新 backlog 的数量，只有 buffer 才会使得 buffersInBacklog + 1，事件不会增加 buffersInBacklog</span></span><br><span class="line">      increaseBuffersInBacklog(bufferConsumer);</span><br><span class="line">      notifyDataAvailable = shouldNotifyDataAvailable() || finish;</span><br><span class="line"></span><br><span class="line">      isFinished |= finish;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (notifyDataAvailable) &#123;</span><br><span class="line">      <span class="comment">//通知数据可以被消费</span></span><br><span class="line">      notifyDataAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//只在第一个 buffer 为 finish 的时候才通知</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">shouldNotifyDataAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Notify only when we added first finished buffer.</span></span><br><span class="line">    <span class="keyword">return</span> readView != <span class="keyword">null</span> &amp;&amp; !flushRequested &amp;&amp; getNumberOfFinishedBuffers() == <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通知readView，有数据可用了</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyDataAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (readView != <span class="keyword">null</span>) &#123;</span><br><span class="line">      readView.notifyDataAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> notifyDataAvailable;</span><br><span class="line">    <span class="keyword">synchronized</span> (buffers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (buffers.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// if there is more then 1 buffer, we already notified the reader</span></span><br><span class="line">      <span class="comment">// (at the latest when adding the second buffer)</span></span><br><span class="line">      notifyDataAvailable = !flushRequested &amp;&amp; buffers.size() == <span class="number">1</span>;</span><br><span class="line">      flushRequested = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (notifyDataAvailable) &#123;</span><br><span class="line">      notifyDataAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在强制进行 flush 的时候，也会发出数据可用的通知。这是因为，假如产出的数据记录较少无法完整地填充一个 <code>MemorySegment</code>，那么 <code>ResultSubpartition</code> 可能会一直处于不可被消费的状态。而为了保证产出的记录能够及时被消费，就需要及时进行 flush，从而确保下游能更及时地处理数据。在 <code>RecordWriter</code> 中有一个 <code>OutputFlusher</code> 会定时触发 flush，间隔可以通过 <code>DataStream.setBufferTimeout()</code> 来控制。</p>
<p>写入的 Buffer 最终被保存在 <code>ResultSubpartition</code> 中维护的一个队列中，如果需要消费这些 Buffer，就需要依赖 <code>ResultSubpartitionView</code>。当需要消费一个 <code>ResultSubpartition</code> 的结果时，需要创建一个 <code>ResultSubpartitionView</code> 对象，并关联到 <code>ResultSubpartition</code> 中；当数据可以被消费时，会通过对应的回调接口告知 <code>ResultSubpartitionView</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A view to consume a &#123;<span class="doctag">@link</span> ResultSubpartition&#125; instance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResultSubpartitionView</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Returns the next &#123;<span class="doctag">@link</span> Buffer&#125; instance of this queue iterator.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;If there is currently no instance available, it will return &lt;code&gt;null&lt;/code&gt;.</span></span><br><span class="line"><span class="comment">	 * This might happen for example when a pipelined queue producer is slower</span></span><br><span class="line"><span class="comment">	 * than the consumer or a spilled queue needs to read in more data.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * &lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: The consumer has to make sure that each</span></span><br><span class="line"><span class="comment">	 * buffer instance will eventually be recycled with &#123;<span class="doctag">@link</span> Buffer#recycleBuffer()&#125;</span></span><br><span class="line"><span class="comment">	 * after it has been consumed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">BufferAndBacklog <span class="title">getNextBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通知 ResultSubpartition 的数据可供消费</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyDataAvailable</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//已经完成对 ResultSubpartition 的消费</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifySubpartitionConsumed</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">nextBufferIsEvent</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">//........</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PipelinedSubpartitionView</span> <span class="keyword">implements</span> <span class="title">ResultSubpartitionView</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The subpartition this view belongs to. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PipelinedSubpartition parent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> BufferAvailabilityListener availabilityListener;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Flag indicating whether this view has been released. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicBoolean isReleased;</span><br><span class="line"></span><br><span class="line">  PipelinedSubpartitionView(PipelinedSubpartition parent, BufferAvailabilityListener listener) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parent = checkNotNull(parent);</span><br><span class="line">    <span class="keyword">this</span>.availabilityListener = checkNotNull(listener);</span><br><span class="line">    <span class="keyword">this</span>.isReleased = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BufferAndBacklog <span class="title">getNextBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent.pollBuffer();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyDataAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回调接口</span></span><br><span class="line">    availabilityListener.notifyDataAvailable();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifySubpartitionConsumed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    releaseAllResources();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseAllResources</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isReleased.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">      <span class="comment">// The view doesn't hold any resources and the parent cannot be restarted. Therefore,</span></span><br><span class="line">      <span class="comment">// it's OK to notify about consumption as well.</span></span><br><span class="line">      parent.onConsumedSubpartition();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReleased</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isReleased.get() || parent.isReleased();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">nextBufferIsEvent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent.nextBufferIsEvent();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> parent.isAvailable();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当需要创建一个 <code>ResultSubpartition</code> 的消费者时，需要通过 <code>ResultPartitionManager</code> 来创建。<code>ResultPartitionManager</code> 会管理当前 Task 的所有 <code>ResultPartition</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResultPartitionManager</span> <span class="keyword">implements</span> <span class="title">ResultPartitionProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">//管理所有的 ResultPartition，使用的时 Guava 提供的支持多级映射的哈希表</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> Table&lt;ExecutionAttemptID, IntermediateResultPartitionID, ResultPartition&gt;</span><br><span class="line">      registeredPartitions = HashBasedTable.create();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//一个 Task 在向 NetworkEnvironment 注册的时候就会逐一注册所有的ResultPartition</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerResultPartition</span><span class="params">(ResultPartition partition)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (registeredPartitions) &#123;</span><br><span class="line">      checkState(!isShutdown, <span class="string">"Result partition manager already shut down."</span>);</span><br><span class="line"></span><br><span class="line">      ResultPartitionID partitionId = partition.getPartitionId();</span><br><span class="line"></span><br><span class="line">      ResultPartition previous = registeredPartitions.put(</span><br><span class="line">          partitionId.getProducerId(), partitionId.getPartitionId(), partition);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Result partition already registered."</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      LOG.debug(<span class="string">"Registered &#123;&#125;."</span>, partition);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在指定的 ResultSubpartition 中创建一个 ResultSubpartitionView，用于消费数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSubpartitionView <span class="title">createSubpartitionView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ResultPartitionID partitionId,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> subpartitionIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">			BufferAvailabilityListener availabilityListener)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (registeredPartitions) &#123;</span><br><span class="line">      <span class="keyword">final</span> ResultPartition partition = registeredPartitions.get(partitionId.getProducerId(),</span><br><span class="line">          partitionId.getPartitionId());</span><br><span class="line">      <span class="comment">//创建 ResultSubpartitionView，可以看作是 ResultSubpartition 的消费者</span></span><br><span class="line">      <span class="keyword">return</span> partition.createSubpartitionView(subpartitionIndex, availabilityListener);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，我们已经了解了一个 Task 如何输出结果到 <code>ResultPartition</code> 中，以及如何去消费不同 <code>ResultSubpartition</code> 中的这些用于保存序列化结果的 Buffer。</p>
<h4 id="Task-的输入"><a href="#Task-的输入" class="headerlink" title="Task 的输入"></a>Task 的输入</h4><p>在了解了 Task 如何输出结果以后，接下来我们把目光投向 Task 的输入端。</p>
<p>前面已经介绍过，Task 的输入被抽象为 <code>InputGate</code>, 而 <code>InputGate</code> 则由 <code>InputChannel</code> 组成， <code>InputChannel</code> 和该 Task 需要消费的 <code>ResultSubpartition</code> 是一一对应的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputGate</span> <span class="keyword">extends</span> <span class="title">AutoCloseable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getNumberOfInputChannels</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">String <span class="title">getOwningTaskName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isFinished</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求消费 ResultPartition</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">requestPartitions</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Blocking call waiting for next &#123;<span class="doctag">@link</span> BufferOrEvent&#125;.</span></span><br><span class="line"><span class="comment">	 * 阻塞调用</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Optional.empty()&#125; if &#123;<span class="doctag">@link</span> #isFinished()&#125; returns true.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function">Optional&lt;BufferOrEvent&gt; <span class="title">getNextBufferOrEvent</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Poll the &#123;<span class="doctag">@link</span> BufferOrEvent&#125;.</span></span><br><span class="line"><span class="comment">	 * 非阻塞调用</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Optional.empty()&#125; if there is no data to return or if &#123;<span class="doctag">@link</span> #isFinished()&#125; returns true.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="function">Optional&lt;BufferOrEvent&gt; <span class="title">pollNextBufferOrEvent</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendTaskEvent</span><span class="params">(TaskEvent event)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">registerListener</span><span class="params">(InputGateListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getPageSize</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Task 通过循环调用 <code>InputGate.getNextBufferOrEvent</code> 方法获取输入数据，并将获取的数据交给它所封装的算子进行处理，这构成了一个 Task 的基本运行逻辑。 <code>InputGate</code> 有两个具体的实现，分别为 <code>SingleInputGate</code> 和 <code>UnionInputGate</code>, <code>UnionInputGate</code> 有多个 <code>SingleInputGate</code> 联合构成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInputGate</span> </span>&#123;</span><br><span class="line">  <span class="comment">//该 InputGate 包含的所有 InputChannel</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;IntermediateResultPartitionID, InputChannel&gt; inputChannels;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Channels, which notified this input gate about available data. */</span></span><br><span class="line">  <span class="comment">//InputChannel 构成的队列，这些 InputChannel 中都有有可供消费的数据</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;InputChannel&gt; inputChannelsWithData = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Buffer pool for incoming buffers. Incoming data from remote channels is copied to buffers</span></span><br><span class="line"><span class="comment">	 * from this pool.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="comment">//用于接收输入的缓冲池</span></span><br><span class="line">  <span class="keyword">private</span> BufferPool bufferPool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Global network buffer pool to request and recycle exclusive buffers (only for credit-based). */</span></span><br><span class="line">  <span class="comment">//全局网络缓冲池</span></span><br><span class="line">  <span class="keyword">private</span> NetworkBufferPool networkBufferPool;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Registered listener to forward buffer notifications to. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> InputGateListener inputGateListener;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Optional&lt;BufferOrEvent&gt; <span class="title">getNextBufferOrEvent</span><span class="params">(<span class="keyword">boolean</span> blocking)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasReceivedAllEndOfPartitionEvents) &#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isReleased) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Released"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先尝试请求分区，实际的请求只会执行一次</span></span><br><span class="line">    requestPartitions();</span><br><span class="line"></span><br><span class="line">    InputChannel currentChannel;</span><br><span class="line">    <span class="keyword">boolean</span> moreAvailable;</span><br><span class="line">    Optional&lt;BufferAndAvailability&gt; result = Optional.empty();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (inputChannelsWithData) &#123;</span><br><span class="line">        <span class="comment">//从 inputChannelsWithData 队列中获取有数据的 channel，经典的生产者-消费者模式</span></span><br><span class="line">        <span class="keyword">while</span> (inputChannelsWithData.size() == <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (isReleased) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Released"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (blocking) &#123;</span><br><span class="line">            inputChannelsWithData.wait();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.empty();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentChannel = inputChannelsWithData.remove();</span><br><span class="line">        enqueuedInputChannelsWithData.clear(currentChannel.getChannelIndex());</span><br><span class="line">        <span class="comment">//是否还有更多的数据</span></span><br><span class="line">        moreAvailable = !inputChannelsWithData.isEmpty();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      result = currentChannel.getNextBuffer();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!result.isPresent());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this channel was now removed from the non-empty channels queue</span></span><br><span class="line">    <span class="comment">// we re-add it in case it has more data, because in that case no "non-empty" notification</span></span><br><span class="line">    <span class="comment">// will come for that channel</span></span><br><span class="line">    <span class="keyword">if</span> (result.get().moreAvailable()) &#123;</span><br><span class="line">      <span class="comment">//如果这个channel还有更多的数据，继续加入到队列中</span></span><br><span class="line">      queueChannel(currentChannel);</span><br><span class="line">      moreAvailable = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Buffer buffer = result.get().buffer();</span><br><span class="line">    <span class="keyword">if</span> (buffer.isBuffer()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> BufferOrEvent(buffer, currentChannel.getChannelIndex(), moreAvailable));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> AbstractEvent event = EventSerializer.fromBuffer(buffer, getClass().getClassLoader());</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果是 EndOfPartitionEvent 事件，那么如果所有的 InputChannel 都接收到这个事件了</span></span><br><span class="line">      <span class="comment">//将 hasReceivedAllEndOfPartitionEvents 标记为 true，此后不再能获取到数据</span></span><br><span class="line">      <span class="keyword">if</span> (event.getClass() == EndOfPartitionEvent.class) &#123;</span><br><span class="line">        channelsWithEndOfPartitionEvents.set(currentChannel.getChannelIndex());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (channelsWithEndOfPartitionEvents.cardinality() == numberOfInputChannels) &#123;</span><br><span class="line">          <span class="comment">// Because of race condition between:</span></span><br><span class="line">          <span class="comment">// 1. releasing inputChannelsWithData lock in this method and reaching this place</span></span><br><span class="line">          <span class="comment">// 2. empty data notification that re-enqueues a channel</span></span><br><span class="line">          <span class="comment">// we can end up with moreAvailable flag set to true, while we expect no more data.</span></span><br><span class="line">          checkState(!moreAvailable || !pollNextBufferOrEvent().isPresent());</span><br><span class="line">          moreAvailable = <span class="keyword">false</span>;</span><br><span class="line">          hasReceivedAllEndOfPartitionEvents = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentChannel.notifySubpartitionConsumed();</span><br><span class="line"></span><br><span class="line">        currentChannel.releaseAllResources();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> BufferOrEvent(event, currentChannel.getChannelIndex(), moreAvailable));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当一个 InputChannel 有数据时的回调</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyChannelNonEmpty</span><span class="params">(InputChannel channel)</span> </span>&#123;</span><br><span class="line">    queueChannel(checkNotNull(channel));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将新的channel加入队列</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">queueChannel</span><span class="params">(InputChannel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> availableChannels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (inputChannelsWithData) &#123;</span><br><span class="line">      <span class="comment">//判断这个channel是否已经在队列中</span></span><br><span class="line">      <span class="keyword">if</span> (enqueuedInputChannelsWithData.get(channel.getChannelIndex())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      availableChannels = inputChannelsWithData.size();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//加入队列</span></span><br><span class="line">      inputChannelsWithData.add(channel);</span><br><span class="line">      enqueuedInputChannelsWithData.set(channel.getChannelIndex());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (availableChannels == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果之前队列中没有channel，这个channel加入后，通知等待的线程</span></span><br><span class="line">        inputChannelsWithData.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (availableChannels == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//如果之前队列中没有channel，这个channel加入后，通知InputGateListener</span></span><br><span class="line">      <span class="comment">//表明这个 InputGate 中有数据了</span></span><br><span class="line">      InputGateListener listener = inputGateListener;</span><br><span class="line">      <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.notifyInputGateNonEmpty(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求分区</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestPartitions</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">      <span class="comment">//只请求一次</span></span><br><span class="line">      <span class="keyword">if</span> (!requestedPartitionsFlag) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isReleased) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already released."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Sanity checks</span></span><br><span class="line">        <span class="keyword">if</span> (numberOfInputChannels != inputChannels.size()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bug in input gate setup logic: mismatch between "</span> +</span><br><span class="line">              <span class="string">"number of total input channels and the currently set number of input "</span> +</span><br><span class="line">              <span class="string">"channels."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">          <span class="comment">//每一个channel都请求对应的子分区</span></span><br><span class="line">          inputChannel.requestSubpartition(consumedSubpartitionIndex);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      requestedPartitionsFlag = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SingleInputGate</code> 的逻辑还比较清晰，它通过内部维护的一个队列形成一个生产者-消费者的模型，当 <code>InputChannel</code> 中有数据时就加入到队列中，在需要获取数据时从队列中取出一个 channel，获取 channel 中的数据。</p>
<p><code>UnionInputGate</code> 时多个 <code>SingleInputGate</code> 联合组成，它的内部有一个 <code>inputGatesWithData</code> 队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnionInputGate</span> <span class="keyword">implements</span> <span class="title">InputGate</span>, <span class="title">InputGateListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The input gates to union. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InputGate[] inputGates;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Gates, which notified this input gate about available data. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;InputGate&gt; inputGatesWithData = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;BufferOrEvent&gt; <span class="title">getNextBufferOrEvent</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (inputGatesWithRemainingData.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure to request the partitions, if they have not been requested before.</span></span><br><span class="line">    requestPartitions();</span><br><span class="line"></span><br><span class="line">    InputGateWithData inputGateWithData = waitAndGetNextInputGate();</span><br><span class="line">    InputGate inputGate = inputGateWithData.inputGate;</span><br><span class="line">    BufferOrEvent bufferOrEvent = inputGateWithData.bufferOrEvent;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferOrEvent.moreAvailable()) &#123;</span><br><span class="line">      <span class="comment">//这个 InputGate 中还有更多的数据，继续加入队列</span></span><br><span class="line">      <span class="comment">// this buffer or event was now removed from the non-empty gates queue</span></span><br><span class="line">      <span class="comment">// we re-add it in case it has more data, because in that case no "non-empty" notification</span></span><br><span class="line">      <span class="comment">// will come for that gate</span></span><br><span class="line">      queueInputGate(inputGate);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bufferOrEvent.isEvent()</span><br><span class="line">      &amp;&amp; bufferOrEvent.getEvent().getClass() == EndOfPartitionEvent.class</span><br><span class="line">      &amp;&amp; inputGate.isFinished()) &#123;</span><br><span class="line"></span><br><span class="line">      checkState(!bufferOrEvent.moreAvailable());</span><br><span class="line">      <span class="keyword">if</span> (!inputGatesWithRemainingData.remove(inputGate)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Couldn't find input gate in set of remaining "</span> +</span><br><span class="line">          <span class="string">"input gates."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the channel index to identify the input channel (across all unioned input gates)</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> channelIndexOffset = inputGateToIndexOffsetMap.get(inputGate);</span><br><span class="line"></span><br><span class="line">    bufferOrEvent.setChannelIndex(channelIndexOffset + bufferOrEvent.getChannelIndex());</span><br><span class="line">    bufferOrEvent.setMoreAvailable(bufferOrEvent.moreAvailable() || inputGateWithData.moreInputGatesAvailable);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Optional.of(bufferOrEvent);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> InputGateWithData <span class="title">waitAndGetNextInputGate</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      InputGate inputGate;</span><br><span class="line">      <span class="keyword">boolean</span> moreInputGatesAvailable;</span><br><span class="line">      <span class="keyword">synchronized</span> (inputGatesWithData) &#123;</span><br><span class="line">        <span class="comment">//等待 inputGatesWithData 队列，经典的生产者-消费者模型</span></span><br><span class="line">        <span class="keyword">while</span> (inputGatesWithData.size() == <span class="number">0</span>) &#123;</span><br><span class="line">          inputGatesWithData.wait();</span><br><span class="line">        &#125;</span><br><span class="line">        inputGate = inputGatesWithData.remove();</span><br><span class="line">        enqueuedInputGatesWithData.remove(inputGate);</span><br><span class="line">        moreInputGatesAvailable = enqueuedInputGatesWithData.size() &gt; <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.</span></span><br><span class="line">      Optional&lt;BufferOrEvent&gt; bufferOrEvent = inputGate.pollNextBufferOrEvent();</span><br><span class="line">      <span class="keyword">if</span> (bufferOrEvent.isPresent()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InputGateWithData(inputGate, bufferOrEvent.get(), moreInputGatesAvailable);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyInputGateNonEmpty</span><span class="params">(InputGate inputGate)</span> </span>&#123;</span><br><span class="line">    queueInputGate(checkNotNull(inputGate));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>InputGate</code> 相当于是对 <code>InputChannel</code> 的一层封装，实际数据的获取还是要依赖于 <code>InputChannel</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputChannel</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> channelIndex;</span><br><span class="line">  <span class="comment">//消费的目标 ResultPartitionID</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> ResultPartitionID partitionId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> SingleInputGate inputGate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//回调函数，告知 InputGate 当前 channel 有数据</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyChannelNonEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    inputGate.notifyChannelNonEmpty(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求ResultSubpartition</span></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">requestSubpartition</span><span class="params">(<span class="keyword">int</span> subpartitionIndex)</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> Optional&lt;BufferAndAvailability&gt; <span class="title">getNextBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendTaskEvent</span><span class="params">(TaskEvent event)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notifySubpartitionConsumed</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">releaseAllResources</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>InputChannel</code> 的基本逻辑也比较简单，它的生命周期按照 <code>requestSubpartition(int subpartitionIndex)</code>, <code>getNextBuffer()</code> 和 <code>releaseAllResources()</code> 这样的顺序进行。</p>
<p>根据 <code>InputChannel</code> 消费的 <code>ResultPartition</code> 的位置，<code>InputChannel</code> 有 <code>LocalInputChannel</code> 和 <code>RemoteInputChannel</code> 两中不同的实现，分别对应本地和远程数据交换。我们将在接下来两节分别进行分析。<code>InputChannel</code> 还有一个实现类是 <code>UnknownInputChannel</code>，相当于是还未确定 <code>ResultPartition</code> 位置的情况下的占位符，最终还是会更新为 <code>LocalInputChannel</code> 或是 <code>RemoteInputChannel</code>。</p>
<h3 id="本地数据交换"><a href="#本地数据交换" class="headerlink" title="本地数据交换"></a>本地数据交换</h3><p>如果一个 <code>InputChannel</code> 和其消费的上游 <code>ResultPartition</code> 所属 Task 都在同一个 TaskManager 中运行，那么它们之间的数据交换就在同一个 JVM 进程内不同线程之间进行，无需通过网络交换。我们已经了解到，<code>ResultSubpartition</code> 中的 buffer 可以通过 <code>ResultSubpartitionView</code> 进行消费。<code>LocalInputChannel</code> 正是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalInputChannel</span> <span class="keyword">extends</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">BufferAvailabilityListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The local partition manager. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultPartitionManager partitionManager;</span><br><span class="line">  <span class="comment">/** Task event dispatcher for backwards events. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TaskEventPublisher taskEventPublisher;</span><br><span class="line">  <span class="comment">/** The consumed subpartition. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> ResultSubpartitionView subpartitionView;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//请求消费对应的子分区</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">requestSubpartition</span><span class="params">(<span class="keyword">int</span> subpartitionIndex)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> retriggerRequest = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// The lock is required to request only once in the presence of retriggered requests.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">      checkState(!isReleased, <span class="string">"LocalInputChannel has been released already"</span>);</span><br><span class="line">      <span class="keyword">if</span> (subpartitionView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//Local，无需网络通信，通过 ResultPartitionManager 创建一个 ResultSubpartitionView</span></span><br><span class="line">          <span class="comment">//LocalInputChannel 实现了 BufferAvailabilityListener</span></span><br><span class="line">          <span class="comment">//在有数据时会得到通知，notifyDataAvailable 会被调用，进而将当前 channel 加到 InputGate 的可用 Channel 队列中</span></span><br><span class="line">          ResultSubpartitionView subpartitionView = partitionManager.createSubpartitionView(</span><br><span class="line">            partitionId, subpartitionIndex, <span class="keyword">this</span>);</span><br><span class="line">          <span class="keyword">if</span> (subpartitionView == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Error requesting subpartition."</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// make the subpartition view visible</span></span><br><span class="line">          <span class="keyword">this</span>.subpartitionView = subpartitionView;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// check if the channel was released in the meantime</span></span><br><span class="line">          <span class="keyword">if</span> (isReleased) &#123;</span><br><span class="line">            subpartitionView.releaseAllResources();</span><br><span class="line">            <span class="keyword">this</span>.subpartitionView = <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PartitionNotFoundException notFound) &#123;</span><br><span class="line">          <span class="keyword">if</span> (increaseBackoff()) &#123;</span><br><span class="line">            retriggerRequest = <span class="keyword">true</span>;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> notFound;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do this outside of the lock scope as this might lead to a</span></span><br><span class="line">    <span class="comment">// deadlock with a concurrent release of the channel via the</span></span><br><span class="line">    <span class="comment">// input gate.</span></span><br><span class="line">    <span class="keyword">if</span> (retriggerRequest) &#123;</span><br><span class="line">      inputGate.retriggerPartitionRequest(partitionId.getPartitionId());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取数据，借助 ResultSubparitionView 消费 ResultSubparition 中的苏剧</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function">Optional&lt;BufferAndAvailability&gt; <span class="title">getNextBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    checkError();</span><br><span class="line">    ResultSubpartitionView subpartitionView = <span class="keyword">this</span>.subpartitionView;</span><br><span class="line">    <span class="keyword">if</span> (subpartitionView == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// There is a possible race condition between writing a EndOfPartitionEvent (1) and flushing (3) the Local</span></span><br><span class="line">      <span class="comment">// channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush notification (4). When</span></span><br><span class="line">      <span class="comment">// they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue LocalInputChannel after (or</span></span><br><span class="line">      <span class="comment">// during) it was released during reading the EndOfPartitionEvent (2).</span></span><br><span class="line">      <span class="keyword">if</span> (isReleased) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// this can happen if the request for the partition was triggered asynchronously</span></span><br><span class="line">      <span class="comment">// by the time trigger</span></span><br><span class="line">      <span class="comment">// would be good to avoid that, by guaranteeing that the requestPartition() and</span></span><br><span class="line">      <span class="comment">// getNextBuffer() always come from the same thread</span></span><br><span class="line">      <span class="comment">// we could do that by letting the timer insert a special "requesting channel" into the input gate's queue</span></span><br><span class="line">      subpartitionView = checkAndWaitForSubpartitionView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 ResultSubparitionView 获取</span></span><br><span class="line">    BufferAndBacklog next = subpartitionView.getNextBuffer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subpartitionView.isReleased()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancelTaskException(<span class="string">"Consumed partition "</span> + subpartitionView + <span class="string">" has been released."</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    numBytesIn.inc(next.buffer().getSizeUnsafe());</span><br><span class="line">    numBuffersIn.inc();</span><br><span class="line">    <span class="keyword">return</span> Optional.of(<span class="keyword">new</span> BufferAndAvailability(next.buffer(), next.isMoreAvailable(), next.buffersInBacklog()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//回调，在 ResultSubparition 通知 ResultSubparitionView 有数据可供消费，</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyDataAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//LocalInputChannel 通知 InputGate</span></span><br><span class="line">    notifyChannelNonEmpty();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">sendTaskEvent</span><span class="params">(TaskEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkError();</span><br><span class="line">    checkState(subpartitionView != <span class="keyword">null</span>, <span class="string">"Tried to send task event to producer before requesting the subpartition."</span>);</span><br><span class="line">    <span class="comment">//事件分发</span></span><br><span class="line">    <span class="keyword">if</span> (!taskEventPublisher.publish(partitionId, event)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Error while publishing event "</span> + event + <span class="string">" to producer. The producer could not be found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的逻辑相对比较简单，<code>LocalInputChannel</code> 实现了 <code>InputChannel</code> 接口，同时也实现了 <code>BufferAvailabilityListener</code> 接口。<code>LocalInputChannel</code> 通过 <code>ResultPartitionManager</code> 请求创建和指定 <code>ResultSubparition</code> 关联的 <code>ResultSubparitionView</code>，并以自身作为 <code>ResultSubparitionView</code> 的回调。这样，一旦 <code>ResultSubparition</code> 有数据产出时，<code>ResultSubparitionView</code> 会得到通知，同时 <code>LocalInputChannel</code> 的回调函数也会被调用，这样消费者这一端就可以及时获取到数据的生产情况，从而及时地去消费数据。</p>
<h3 id="通过网络进行数据交换"><a href="#通过网络进行数据交换" class="headerlink" title="通过网络进行数据交换"></a>通过网络进行数据交换</h3><h4 id="网络栈"><a href="#网络栈" class="headerlink" title="网络栈"></a>网络栈</h4><p>在 Flink 中，不同 Task 之间的网络传输基于 Netty 实现。<code>NetworkEnvironment</code> 中通过 <code>ConnectionManager</code> 来管理所有的网络的连接，而 <code>NettyConnectionManager</code> 就是 <code>ConnectionManager</code> 的具体实现。</p>
<p><code>NettyConnectionManager</code> 在启动的时候会创建并启动 <code>NettyClient</code> 和 <code>NettyServer</code>，<code>NettyServer</code> 会启动一个服务端监听，等待其它 <code>NettyClient</code> 的连接：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyConnectionManager</span> <span class="keyword">implements</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyServer server;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyClient client;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyBufferPool bufferPool;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PartitionRequestClientFactory partitionRequestClientFactory;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isCreditBased;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ResultPartitionProvider partitionProvider, TaskEventPublisher taskEventPublisher)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    NettyProtocol partitionRequestProtocol = <span class="keyword">new</span> NettyProtocol(partitionProvider, taskEventPublisher, isCreditBased);</span><br><span class="line">    <span class="comment">//初始化 Netty Client</span></span><br><span class="line">    client.init(partitionRequestProtocol, bufferPool);</span><br><span class="line">    <span class="comment">//初始化并启动 Netty Server</span></span><br><span class="line">    server.init(partitionRequestProtocol, bufferPool);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NettyProtocal</code> 中提供了 <code>NettyClient</code> 和 <code>NettyServer</code> 引导启动注册的一系列 Channel Handler，这些 Handler 的主要逻辑在后面再进行详细分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyProtocol</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> ChannelHandler[] getServerChannelHandlers() &#123;</span><br><span class="line">    <span class="comment">//netty server 端的 ChannelHandler</span></span><br><span class="line">    PartitionRequestQueue queueOfPartitionQueues = <span class="keyword">new</span> PartitionRequestQueue();</span><br><span class="line">    PartitionRequestServerHandler serverHandler = <span class="keyword">new</span> PartitionRequestServerHandler(</span><br><span class="line">      partitionProvider, taskEventPublisher, queueOfPartitionQueues, creditBasedEnabled);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChannelHandler[] &#123;</span><br><span class="line">      messageEncoder,</span><br><span class="line">      <span class="keyword">new</span> NettyMessage.NettyMessageDecoder(!creditBasedEnabled),</span><br><span class="line">      serverHandler,</span><br><span class="line">      queueOfPartitionQueues</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> ChannelHandler[] getClientChannelHandlers() &#123;</span><br><span class="line">    <span class="comment">//netty client 端的 ChannelHandler</span></span><br><span class="line">    NetworkClientHandler networkClientHandler =</span><br><span class="line">      creditBasedEnabled ? <span class="keyword">new</span> CreditBasedPartitionRequestClientHandler() :</span><br><span class="line">        <span class="keyword">new</span> PartitionRequestClientHandler();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ChannelHandler[] &#123;</span><br><span class="line">      messageEncoder,</span><br><span class="line">      <span class="keyword">new</span> NettyMessage.NettyMessageDecoder(!creditBasedEnabled),</span><br><span class="line">      networkClientHandler&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得一提的是， <code>NettyServer</code> 在启动的时候会配置水位线，如果 Netty 输出缓冲中的字节数超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。通过水位线机制确保不往网络中写入太多数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> NettyProtocol protocol, NettyBufferPool nettyBufferPool)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newLowWaterMark = config.getMemorySegmentSize() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> newHighWaterMark = <span class="number">2</span> * config.getMemorySegmentSize();</span><br><span class="line">    <span class="comment">//配置水位线，确保不往网络中写入太多数据</span></span><br><span class="line">    <span class="comment">//当输出缓冲中的字节数超过高水位值, 则 Channel.isWritable() 会返回false</span></span><br><span class="line">    <span class="comment">//当输出缓存中的字节数低于低水位值, 则 Channel.isWritable() 会重新返回true</span></span><br><span class="line">    bootstrap.childOption(ChannelOption.WRITE_BUFFER_HIGH_WATER_MARK, newHighWaterMark);</span><br><span class="line">    bootstrap.childOption(ChannelOption.WRITE_BUFFER_LOW_WATER_MARK, newLowWaterMark);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当 <code>RemoteInputChannel</code> 请求一个远端的 <code>ResultSubpartition</code> 的时候，<code>NettyClient</code> 就会发起和请求的 <code>ResultSubpartition</code> 所在 Task 的 <code>NettyServer</code> 的连接，后续所有的数据交换都在这个连接上进行。两个 Task 之间只会建立一个连接，这个连接会在不同的 <code>RemoteInputChannel</code> 和 <code>ResultSubpartition</code> 之间进行复用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyConnectionManager</span> <span class="keyword">implements</span> <span class="title">ConnectionManager</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PartitionRequestClient <span class="title">createPartitionRequestClient</span><span class="params">(ConnectionID connectionId)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//这里实际上会建立和其它 Task 的 Server 的连接</span></span><br><span class="line">    <span class="comment">//返回的 PartitionRequestClient 中封装了 netty channel 和 channel handler</span></span><br><span class="line">    <span class="keyword">return</span> partitionRequestClientFactory.createPartitionRequestClient(connectionId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestClientFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> NettyClient nettyClient;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;ConnectionID, Object&gt; clients = <span class="keyword">new</span> ConcurrentHashMap&lt;ConnectionID, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function">PartitionRequestClient <span class="title">createPartitionRequestClient</span><span class="params">(ConnectionID connectionId)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    Object entry;</span><br><span class="line">    PartitionRequestClient client = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (client == <span class="keyword">null</span>) &#123;</span><br><span class="line">      entry = clients.get(connectionId);</span><br><span class="line">      <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//连接已经建立</span></span><br><span class="line">        <span class="comment">// Existing channel or connecting channel</span></span><br><span class="line">        <span class="keyword">if</span> (entry <span class="keyword">instanceof</span> PartitionRequestClient) &#123;</span><br><span class="line">          client = (PartitionRequestClient) entry;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          ConnectingChannel future = (ConnectingChannel) entry;</span><br><span class="line">          client = future.waitForChannel();</span><br><span class="line">          clients.replace(connectionId, future, client);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// No channel yet. Create one, but watch out for a race.</span></span><br><span class="line">        <span class="comment">// We create a "connecting future" and atomically add it to the map.</span></span><br><span class="line">        <span class="comment">// Only the thread that really added it establishes the channel.</span></span><br><span class="line">        <span class="comment">// The others need to wait on that original establisher's future.</span></span><br><span class="line">        <span class="comment">// 连接创建成功后会回调 handInChannel 方法</span></span><br><span class="line">        ConnectingChannel connectingChannel = <span class="keyword">new</span> ConnectingChannel(connectionId, <span class="keyword">this</span>);</span><br><span class="line">        Object old = clients.putIfAbsent(connectionId, connectingChannel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (old == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//连接到 Netty Server</span></span><br><span class="line">          nettyClient.connect(connectionId.getAddress()).addListener(connectingChannel);</span><br><span class="line">          client = connectingChannel.waitForChannel();</span><br><span class="line">          clients.replace(connectionId, connectingChannel, client);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (old <span class="keyword">instanceof</span> ConnectingChannel) &#123;</span><br><span class="line">          client = ((ConnectingChannel) old).waitForChannel();</span><br><span class="line">          clients.replace(connectionId, old, client);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          client = (PartitionRequestClient) old;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Make sure to increment the reference count before handing a client</span></span><br><span class="line">      <span class="comment">// out to ensure correct bookkeeping for channel closing.</span></span><br><span class="line">      <span class="keyword">if</span> (!client.incrementReferenceCounter()) &#123;</span><br><span class="line">        destroyPartitionRequestClient(connectionId, client);</span><br><span class="line">        client = <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> client;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，Flink Buffer 的实现类 <code>NetworkBuffer</code> 直接继承了 Netty 的 <code>AbstractReferenceCountedByteBuf</code>，这样使得 Netty 可以直接使用 Flink 的 Buffer，从而避免了在 Flink Buffers 和 Netty Buffers 之间的数据拷贝：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkBuffer</span> <span class="keyword">extends</span> <span class="title">AbstractReferenceCountedByteBuf</span> <span class="keyword">implements</span> <span class="title">Buffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MemorySegment memorySegment;</span><br><span class="line">  <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//回收当前buffer， LocalBufferPool 实现了 BufferRecycler 接口</span></span><br><span class="line">    recycler.recycle(memorySegment);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h4><p>Flink 在两个 Task 之间建立 Netty 连接进行数据传输，每一个 Task 会分配两个缓冲池，一个用于输出数据，一个用于接收数据。当一个 Task 的缓冲池用尽之后，网络连接就处于阻塞状态，上游 Task 无法产出数据，下游 Task 无法接收数据，也就是我们所说的“反压”状态。这是一种非常自然的“反压”的机制，但是过程也相对比较粗暴。由于 TaskManager 之间的网络连接是由不同 Task 复用的，一旦网络处于阻塞状态，所有 Task 都无法向 TCP 连接中写入数据或者从中读取数据，即便其它 Task 关联的缓冲池仍然存在空余。此外，由于网络发生了阻塞，诸如 <code>CheckpointBarrier</code> 等事件也无法在 Task 之间进行流转。</p>
<p>为了解决上述问题，Flink 1.5 重构了网络栈，引入了“基于信用值的流量控制算法”（Credit-based Flow Control），确保 TaskManager 之间的网络连接始终不会处于阻塞状态。Credit-based Flow Control 的思路其实也比较简单，它是在接收端和发送端之间建立一种类似“信用评级”的机制，发送端向接收端发送的数据永远不会超过接收端的信用值的大小。在 Flink 这里，信用值就是接收端可用的 Buffer 的数量，这样就可以保证发送端不会向 TCP 连接中发送超出接收端缓冲区可用容量的数据。</p>
<p>相比于之前所有的 InputChannel 共享同一个本地缓冲池的方式，在重构网络栈之后，Flink 会为每一个 InputChannel 分配一批独占的缓冲（exclusive buffers），而本地缓冲池中的 buffer 则作为流动的（floating buffers），可以被所有的 InputChannel 使用。</p>
<p>Credit-based Flow Control 的具体机制为：</p>
<ul>
<li>接收端向发送端声明可用的 Credit（一个可用的 buffer 对应一点 credit）；</li>
<li>当发送端获得了 X 点 Credit，表明它可以向网络中发送 X 个 buffer；当接收端分配了 X 点 Credit 给发送端，表明它有 X 个空闲的 buffer 可以接收数据；</li>
<li>只有在 Credit &gt; 0 的情况下发送端才发送 buffer；发送端每发送一个 buffer，Credit 也相应地减少一点</li>
<li>由于 <code>CheckpointBarrier</code>，<code>EndOfPartitionEvent</code> 等事件可以被立即处理，因而事件可以立即发送，无需使用 Credit</li>
<li>当发送端发送 buffer 的时候，它同样把当前堆积的 buffer 数量（backlog size）告知接收端；接收端根据发送端堆积的数量来申请 floating buffer</li>
</ul>
<p>这种流量控制机制可以有效地改善网络的利用率，不会因为 buffer 长时间停留在网络链路中进而导致整个所有的 Task 都无法继续处理数据，也无法进行 Checkpoint 操作。但是它的一个潜在的缺点是增加了上下游之间的通信成本（需要发送 credit 和 backlog 信息）。在目前的版本中可以通过 <code>taskmanager.network.credit-model: false</code> 来禁用，但后续应该会移除这个配置项。</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>在了解了 Flink 的网络栈和流量控制机制后，下面我们就来具体看一下 Flink 是如何在不同 Task 之间通过网络进行数据交换的。</p>
<h5 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h5><p>首先，在向 <code>NetworkEnvironment</code> 注册的时候，会为 <code>InputGate</code> 分配本地缓冲池，还会为 <code>RemoteInputChannel</code> 分配独占的 buffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkEnvironment</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setupInputGate</span><span class="params">(SingleInputGate gate)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferPool bufferPool = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> maxNumberOfMemorySegments;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (config.isCreditBased()) &#123; <span class="comment">//使用 Credit-based Flow Control</span></span><br><span class="line">        <span class="comment">//本地缓冲池使用的 buffer 数量，如果是 bounded，则缓冲池的大小最大为 taskmanager.network.memory.floating-buffers-per-gate</span></span><br><span class="line">        maxNumberOfMemorySegments = gate.getConsumedPartitionType().isBounded() ?</span><br><span class="line">          config.floatingNetworkBuffersPerGate() : Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// assign exclusive buffers to input channels directly and use the rest for floating buffers</span></span><br><span class="line">        <span class="comment">// 独占的buffer，不包含在分配的 LocalBufferPool 中</span></span><br><span class="line">        gate.assignExclusiveSegments(networkBufferPool, config.networkBuffersPerChannel());</span><br><span class="line">        bufferPool = networkBufferPool.createBufferPool(<span class="number">0</span>, maxNumberOfMemorySegments);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        maxNumberOfMemorySegments = gate.getConsumedPartitionType().isBounded() ?</span><br><span class="line">          gate.getNumberOfInputChannels() * config.networkBuffersPerChannel() +</span><br><span class="line">            config.floatingNetworkBuffersPerGate() : Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">        bufferPool = networkBufferPool.createBufferPool(gate.getNumberOfInputChannels(),</span><br><span class="line">          maxNumberOfMemorySegments);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//分配 LocalBufferPool 本地缓冲池，这是所有 channel 共享的</span></span><br><span class="line">      gate.setBufferPool(bufferPool);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (bufferPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bufferPool.lazyDestroy();</span><br><span class="line">      &#125;</span><br><span class="line">      ExceptionUtils.rethrowIOException(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleInputGate</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">assignExclusiveSegments</span><span class="params">(NetworkBufferPool networkBufferPool, <span class="keyword">int</span> networkBuffersPerChannel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    checkState(<span class="keyword">this</span>.isCreditBased, <span class="string">"Bug in input gate setup logic: exclusive buffers only exist with credit-based flow control."</span>);</span><br><span class="line">    checkState(<span class="keyword">this</span>.networkBufferPool == <span class="keyword">null</span>, <span class="string">"Bug in input gate setup logic: global buffer pool has"</span> +</span><br><span class="line">      <span class="string">"already been set for this input gate."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.networkBufferPool = checkNotNull(networkBufferPool);</span><br><span class="line">    <span class="keyword">this</span>.networkBuffersPerChannel = networkBuffersPerChannel;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">      <span class="keyword">for</span> (InputChannel inputChannel : inputChannels.values()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inputChannel <span class="keyword">instanceof</span> RemoteInputChannel) &#123;</span><br><span class="line">          <span class="comment">//RemoteInputChannel 请求独占的 buffer</span></span><br><span class="line">          ((RemoteInputChannel) inputChannel).assignExclusiveSegments(</span><br><span class="line">            networkBufferPool.requestMemorySegments(networkBuffersPerChannel));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="RemoteInputChannel-管理可用-buffer"><a href="#RemoteInputChannel-管理可用-buffer" class="headerlink" title="RemoteInputChannel 管理可用 buffer"></a>RemoteInputChannel 管理可用 buffer</h5><p>在 <code>RemoteInputChannel</code> 内部使用 <code>AvailableBufferQueue</code> 来管理所有可用的 buffer：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteInputChannel</span> <span class="keyword">extends</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">BufferRecycler</span>, <span class="title">BufferListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可用的 buffer 队列，包含 exclusive + floating</span></span><br><span class="line">  <span class="comment">/** The available buffer queue wraps both exclusive and requested floating buffers. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AvailableBufferQueue bufferQueue = <span class="keyword">new</span> AvailableBufferQueue();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//分配独占的 buffer</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">assignExclusiveSegments</span><span class="params">(List&lt;MemorySegment&gt; segments)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.initialCredit = segments.size();</span><br><span class="line">    <span class="keyword">this</span>.numRequiredBuffers = segments.size();</span><br><span class="line">    <span class="keyword">synchronized</span> (bufferQueue) &#123;</span><br><span class="line">      <span class="keyword">for</span> (MemorySegment segment : segments) &#123;</span><br><span class="line">        <span class="comment">//注意这个 NetworkBuffer 的回收器是 RemoteInputChannel 自身</span></span><br><span class="line">        bufferQueue.addExclusiveBuffer(<span class="keyword">new</span> NetworkBuffer(segment, <span class="keyword">this</span>), numRequiredBuffers);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//独占的 buffer 释放后会直接被 RemoteInputChannel 回收</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">(MemorySegment segment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numAddedBuffers;</span><br><span class="line">    <span class="keyword">synchronized</span> (bufferQueue) &#123;</span><br><span class="line">      <span class="comment">// Similar to notifyBufferAvailable(), make sure that we never add a buffer</span></span><br><span class="line">      <span class="comment">// after releaseAllResources() released all buffers (see below for details).</span></span><br><span class="line">      <span class="keyword">if</span> (isReleased.get()) &#123;</span><br><span class="line">        <span class="comment">//如果这个 channle 已经被释放</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//这个 MemorySegment 会被归还给 NetworkBufferPool</span></span><br><span class="line">          inputGate.returnExclusiveSegments(Collections.singletonList(segment));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          ExceptionUtils.rethrow(t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//重新加入到 AvailableBufferQueue 中</span></span><br><span class="line">      numAddedBuffers = bufferQueue.addExclusiveBuffer(<span class="keyword">new</span> NetworkBuffer(segment, <span class="keyword">this</span>), numRequiredBuffers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numAddedBuffers &gt; <span class="number">0</span> &amp;&amp; unannouncedCredit.getAndAdd(numAddedBuffers) == <span class="number">0</span>) &#123;</span><br><span class="line">      notifyCreditAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Manages the exclusive and floating buffers of this channel, and handles the</span></span><br><span class="line"><span class="comment">	 * internal buffer related logic.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AvailableBufferQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这部分是流动的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;Buffer&gt; floatingBuffers;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这部分是独占的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;Buffer&gt; exclusiveBuffers;</span><br><span class="line"></span><br><span class="line">    AvailableBufferQueue() &#123;</span><br><span class="line">      <span class="keyword">this</span>.exclusiveBuffers = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">      <span class="keyword">this</span>.floatingBuffers = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个独占的buffer，如果当前可用的 buffer 总量超出了要求的数量，则向本地缓冲池归还一个流动的buffer</span></span><br><span class="line">    <span class="comment">//返回值是新增的 buffer 数量</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">addExclusiveBuffer</span><span class="params">(Buffer buffer, <span class="keyword">int</span> numRequiredBuffers)</span> </span>&#123;</span><br><span class="line">      exclusiveBuffers.add(buffer);</span><br><span class="line">      <span class="keyword">if</span> (getAvailableBufferSize() &gt; numRequiredBuffers) &#123;</span><br><span class="line">        Buffer floatingBuffer = floatingBuffers.poll();</span><br><span class="line">        floatingBuffer.recycleBuffer();</span><br><span class="line">        <span class="comment">//加一个，归还一个，相当于没加</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加一个流动的buffer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFloatingBuffer</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">      floatingBuffers.add(buffer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优先取流动的buffer</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function">Buffer <span class="title">takeBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (floatingBuffers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> floatingBuffers.poll();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> exclusiveBuffers.poll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getAvailableBufferSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> floatingBuffers.size() + exclusiveBuffers.size();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="请求远端子分区"><a href="#请求远端子分区" class="headerlink" title="请求远端子分区"></a>请求远端子分区</h5><p><code>RemoteInputChannel</code> 请求远端的 <code>ResultSubpartition</code>，会创建一个 <code>PartitionRequestClient</code>，并通过 Netty 发送 <code>PartitionRequest</code> 请求，这时会带上当前 InputChannel 的 id 和初始的 credit 信息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteInputChannel</span> <span class="keyword">extends</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">BufferRecycler</span>, <span class="title">BufferListener</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestSubpartition</span><span class="params">(<span class="keyword">int</span> subpartitionIndex)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//REMOTE，需要网络通信，使用 Netty 建立网络</span></span><br><span class="line">    <span class="comment">//通过 ConnectionManager 来建立连接：创建 PartitionRequestClient，通过 PartitionRequestClient 发起请求</span></span><br><span class="line">    <span class="keyword">if</span> (partitionRequestClient == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// Create a client and request the partition</span></span><br><span class="line">      partitionRequestClient = connectionManager</span><br><span class="line">        .createPartitionRequestClient(connectionId);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//请求分区，通过 netty 发起请求</span></span><br><span class="line">      partitionRequestClient.requestSubpartition(partitionId, subpartitionIndex, <span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestClient</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">requestSubpartition</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> ResultPartitionID partitionId,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> <span class="keyword">int</span> subpartitionIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> RemoteInputChannel inputChannel,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">int</span> delayMs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//向 NetworkClientHandler 注册当前 RemoteInputChannel</span></span><br><span class="line">    <span class="comment">//单个 Task 所有的 RemoteInputChannel 的数据传输都通过这个 PartitionRequestClient 处理</span></span><br><span class="line">    clientHandler.addInputChannel(inputChannel);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PartitionRequest封装了请求的 sub-partition 的信息，当前 input channel 的 ID，以及初始 credit</span></span><br><span class="line">    <span class="keyword">final</span> PartitionRequest request = <span class="keyword">new</span> PartitionRequest(</span><br><span class="line">        partitionId, subpartitionIndex, inputChannel.getInputChannelId(), inputChannel.getInitialCredit());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ChannelFutureListener listener = <span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">          <span class="comment">//如果请求发送失败，要移除当前的 inputChannel</span></span><br><span class="line">          clientHandler.removeInputChannel(inputChannel);</span><br><span class="line">          SocketAddress remoteAddr = future.channel().remoteAddress();</span><br><span class="line">          inputChannel.onError(</span><br><span class="line">              <span class="keyword">new</span> LocalTransportException(</span><br><span class="line">                String.format(<span class="string">"Sending the partition request to '%s' failed."</span>, remoteAddr),</span><br><span class="line">                future.channel().localAddress(), future.cause()</span><br><span class="line">              ));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 netty 发送请求</span></span><br><span class="line">    <span class="keyword">if</span> (delayMs == <span class="number">0</span>) &#123;</span><br><span class="line">      ChannelFuture f = tcpChannel.writeAndFlush(request);</span><br><span class="line">      f.addListener(listener);</span><br><span class="line">      <span class="keyword">return</span> f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> ChannelFuture[] f = <span class="keyword">new</span> ChannelFuture[<span class="number">1</span>];</span><br><span class="line">      tcpChannel.eventLoop().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          f[<span class="number">0</span>] = tcpChannel.writeAndFlush(request);</span><br><span class="line">          f[<span class="number">0</span>].addListener(listener);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, delayMs, TimeUnit.MILLISECONDS);</span><br><span class="line">      <span class="keyword">return</span> f[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="生产端的处理流程"><a href="#生产端的处理流程" class="headerlink" title="生产端的处理流程"></a>生产端的处理流程</h5><p>生产者端即 <code>ResultSubpartition</code> 一侧，在网络通信中对应 <code>NettyServer</code>。<code>NettyServer</code> 有两个重要的 <code>ChannelHandler</code>，即 <code>PartitionRequestServerHandler</code> 和 <code>PartitionRequestQueue</code>。其中，<code>PartitionRequestServerHandler</code> 负责处理消费端通过 <code>PartitionRequestClient</code> 发送的 <code>PartitionRequest</code> 和 <code>AddCredit</code> 等请求；<code>PartitionRequestQueue</code> 则包含了一个可以从中读取数据的 <code>NetworkSequenceViewReader</code> 队列，它会监听 Netty Channel 的可写入状态，一旦可以写入数据，就会从 <code>NetworkSequenceViewReader</code> 消费数据写入 Netty Channel。</p>
<p>首先，当 <code>NettyServer</code> 接收到 <code>PartitionRequest</code> 消息后，<code>PartitionRequestServerHandler</code> 会创建一个 <code>NetworkSequenceViewReader</code> 对象，请求创建 <code>ResultSubpartitionView</code>, 并将 <code>NetworkSequenceViewReader</code> 保存在 <code>PartitionRequestQueue</code> 中。<code>PartitionRequestQueue</code> 会持有所有请求消费数据的 <code>RemoteInputChannel</code> 的 ID 和 <code>NetworkSequenceViewReader</code> 之间的映射关系。</p>
<p>我们已经知道，<code>ResultSubpartitionView</code> 用来消费 <code>ResultSubpartition</code> 中的数据，并在 <code>ResultSubpartition</code> 中有数据可用时获得提醒；<code>NetworkSequenceViewReader</code> 则相当于对 <code>ResultSubpartition</code> 的一层包装，她会按顺序为读取的每一个 buffer 分配一个序列号，并且记录了接收数据的 <code>RemoteInputChannel</code> 的 ID。在使用 Credit-based Flow Control 的情况下，<code>NetworkSequenceViewReader</code> 的具体实现对应为 <code>CreditBasedSequenceNumberingViewReader</code>。 <code>CreditBasedSequenceNumberingViewReader</code> 同时还实现了 <code>BufferAvailabilityListener</code> 接口，因而可以作为 <code>PipelinedSubpartitionView</code> 的回调对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">NettyMessage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, NettyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Class&lt;?&gt; msgClazz = msg.getClass();</span><br><span class="line">      <span class="keyword">if</span> (msgClazz == PartitionRequest.class) &#123;</span><br><span class="line">        <span class="comment">//Server 端接收到 client 发送的 PartitionRequest</span></span><br><span class="line">        PartitionRequest request = (PartitionRequest) msg;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          NetworkSequenceViewReader reader;</span><br><span class="line">          <span class="keyword">if</span> (creditBasedEnabled) &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> CreditBasedSequenceNumberingViewReader(</span><br><span class="line">              request.receiverId,</span><br><span class="line">              request.credit,</span><br><span class="line">              outboundQueue);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reader = <span class="keyword">new</span> SequenceNumberingViewReader(</span><br><span class="line">              request.receiverId,</span><br><span class="line">              outboundQueue);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//通过 ResultPartitionProvider（实际上就是 ResultPartitionManager）创建 ResultSubpartitionView</span></span><br><span class="line">          <span class="comment">//在有可被消费的数据产生后，PartitionRequestQueue.notifyReaderNonEmpty 会被回调，进而在 netty channelPipeline 上触发一次 fireUserEventTriggered</span></span><br><span class="line">          reader.requestSubpartitionView(</span><br><span class="line">            partitionProvider,</span><br><span class="line">            request.partitionId,</span><br><span class="line">            request.queueIndex);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//通知 PartitionRequestQueue 创建了一个 NetworkSequenceViewReader</span></span><br><span class="line">          outboundQueue.notifyReaderCreated(reader);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (PartitionNotFoundException notFound) &#123;</span><br><span class="line">          respondWithError(ctx, notFound, request.receiverId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      respondWithError(ctx, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditBasedSequenceNumberingViewReader</span> <span class="keyword">implements</span> <span class="title">BufferAvailabilityListener</span>, <span class="title">NetworkSequenceViewReader</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> InputChannelID receiverId; <span class="comment">//对应的 RemoteInputChannel 的 ID</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PartitionRequestQueue requestQueue;</span><br><span class="line">  <span class="comment">//消费 ResultSubpartition 的数据，并在 ResultSubpartition 有数据可用时获得通知</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> ResultSubpartitionView subpartitionView;</span><br><span class="line">  <span class="comment">//numCreditsAvailable的值是消费端还能够容纳的buffer的数量，也就是允许生产端发送的buffer的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> numCreditsAvailable;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> sequenceNumber = -<span class="number">1</span>; <span class="comment">//序列号，自增</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建一个 ResultSubpartitionView，用于读取数据，并在有数据可用时获得通知</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestSubpartitionView</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ResultPartitionProvider partitionProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">		ResultPartitionID resultPartitionId,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">int</span> subPartitionIndex)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (requestLock) &#123;</span><br><span class="line">      <span class="keyword">if</span> (subpartitionView == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.subpartitionView = partitionProvider.createSubpartitionView(</span><br><span class="line">          resultPartitionId,</span><br><span class="line">          subPartitionIndex,</span><br><span class="line">          <span class="keyword">this</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Subpartition already requested"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> BufferAndAvailability <span class="title">getNextBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">    BufferAndBacklog next = subpartitionView.getNextBuffer(); <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">      sequenceNumber++; <span class="comment">//序列号</span></span><br><span class="line">      <span class="comment">//要发送一个buffer，对应的 numCreditsAvailable 要减 1</span></span><br><span class="line">      <span class="keyword">if</span> (next.buffer().isBuffer() &amp;&amp; --numCreditsAvailable &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"no credit available"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BufferAndAvailability(</span><br><span class="line">        next.buffer(), isAvailable(next), next.buffersInBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否还可以消费数据：</span></span><br><span class="line">  <span class="comment">// 1. ResultSubpartition 中有更多的数据</span></span><br><span class="line">  <span class="comment">// 2. credit &gt; 0 或者下一条数据是事件(事件不需要消耗credit)</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!</span></span><br><span class="line">    <span class="keyword">return</span> hasBuffersAvailable() &amp;&amp;</span><br><span class="line">      <span class="comment">//要求 numCreditsAvailable &gt; 0 或者是 Event</span></span><br><span class="line">      (numCreditsAvailable &gt; <span class="number">0</span> || subpartitionView.nextBufferIsEvent());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasBuffersAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subpartitionView.isAvailable();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//和上面 isAvailable() 是等价的</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isAvailable</span><span class="params">(BufferAndBacklog bufferAndBacklog)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// BEWARE: this must be in sync with #isAvailable()!</span></span><br><span class="line">    <span class="keyword">return</span> bufferAndBacklog.isMoreAvailable() &amp;&amp;</span><br><span class="line">      (numCreditsAvailable &gt; <span class="number">0</span> || bufferAndBacklog.nextBufferIsEvent());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//在 ResultSubparition 中有数据时会回调该方法</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyDataAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//告知 PartitionRequestQueue 当前 ViewReader 有数据可读</span></span><br><span class="line">    requestQueue.notifyReaderNonEmpty(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PartitionRequestQueue</code> 负责将 <code>ResultSubparition</code> 中的数据通过网络发送给 <code>RemoteInputChannel</code>。在 <code>PartitionRequestQueue</code> 中保存了所有的 <code>NetworkSequenceViewReader</code> 和 <code>InputChannelID</code> 之间的映射关系，以及一个 <code>ArrayDeque&lt;NetworkSequenceViewReader&gt; availableReaders</code> 队列。当一个 <code>NetworkSequenceViewReader</code> 中有数据可以被消费时，就会被加入到 <code>availableReaders</code> 队列中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestQueue</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The readers which are already enqueued available for transferring data. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ArrayDeque&lt;NetworkSequenceViewReader&gt; availableReaders = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">  <span class="comment">/** All the readers created for the consumers' partition requests. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;InputChannelID, NetworkSequenceViewReader&gt; allReaders = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//添加新的 NetworkSequenceViewReader</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyReaderCreated</span><span class="params">(<span class="keyword">final</span> NetworkSequenceViewReader reader)</span> </span>&#123;</span><br><span class="line">    allReaders.put(reader.getReceiverId(), reader);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//通知 NetworkSequenceViewReader 有数据可读取</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyReaderNonEmpty</span><span class="params">(<span class="keyword">final</span> NetworkSequenceViewReader reader)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//触发一次用户自定义事件</span></span><br><span class="line">    ctx.executor().execute(() -&gt; ctx.pipeline().fireUserEventTriggered(reader));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//自定义用户事件的处理</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// The user event triggered event loop callback is used for thread-safe</span></span><br><span class="line">    <span class="comment">// hand over of reader queues and cancelled producers.</span></span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> NetworkSequenceViewReader) &#123;</span><br><span class="line">      <span class="comment">//NetworkSequenceViewReader有数据可读取，加入队列中</span></span><br><span class="line">      enqueueAvailableReader((NetworkSequenceViewReader) msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msg.getClass() == InputChannelID.class) &#123;</span><br><span class="line">      <span class="comment">// 对应的 RemoteInputChannel 请求取消消费</span></span><br><span class="line">      <span class="comment">// Release partition view that get a cancel request.</span></span><br><span class="line">      InputChannelID toCancel = (InputChannelID) msg;</span><br><span class="line">      <span class="keyword">if</span> (released.contains(toCancel)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Cancel the request for the input channel</span></span><br><span class="line">      <span class="keyword">int</span> size = availableReaders.size();</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        NetworkSequenceViewReader reader = pollAvailableReader();</span><br><span class="line">        <span class="keyword">if</span> (reader.getReceiverId().equals(toCancel)) &#123;</span><br><span class="line">          reader.releaseAllResources();</span><br><span class="line">          markAsReleased(reader.getReceiverId());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          registerAvailableReader(reader);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      allReaders.remove(toCancel);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.fireUserEventTriggered(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//加入队列</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueueAvailableReader</span><span class="params">(<span class="keyword">final</span> NetworkSequenceViewReader reader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (reader.isRegisteredAsAvailable() || !reader.isAvailable()) &#123;</span><br><span class="line">      <span class="comment">//已经被注册到队列中，或者暂时没有 buffer 或没有 credit 可用</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> triggerWrite = availableReaders.isEmpty();</span><br><span class="line">    registerAvailableReader(reader);</span><br><span class="line">    <span class="keyword">if</span> (triggerWrite) &#123;</span><br><span class="line">      <span class="comment">//如果这是队列中第一个元素，调用 writeAndFlushNextMessageIfPossible 发送数据</span></span><br><span class="line">      writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>PartitionRequestQueue</code> 会监听 Netty Channel 的可写入状态，当 Channel 可写入时，就会从 <code>availableReaders</code> 队列中取出 <code>NetworkSequenceViewReader</code>，读取数据并写入网络。可写入状态是 Netty 通过水位线进行控制的，<code>NettyServer</code> 在启动的时候会配置水位线，如果 Netty 输出缓冲中的字节数超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。通过水位线机制确保不往网络中写入太多数据。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestQueue</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//当前channel的读写状态发生变化</span></span><br><span class="line">    writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeAndFlushNextMessageIfPossible</span><span class="params">(<span class="keyword">final</span> Channel channel)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fatalError || !channel.isWritable()) &#123;</span><br><span class="line">      <span class="comment">//如果当前不可写入，则直接返回</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    BufferAndAvailability next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">//取出一个 reader</span></span><br><span class="line">        NetworkSequenceViewReader reader = pollAvailableReader();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reader == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        next = reader.getNextBuffer();</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//没有读到数据</span></span><br><span class="line">          <span class="keyword">if</span> (!reader.isReleased()) &#123;</span><br><span class="line">            <span class="comment">//还没有释放当前 subpartition，继续处理下一个 reader</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          markAsReleased(reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">          <span class="comment">//出错了</span></span><br><span class="line">          Throwable cause = reader.getFailureCause();</span><br><span class="line">          <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ErrorResponse msg = <span class="keyword">new</span> ErrorResponse(</span><br><span class="line">              <span class="keyword">new</span> ProducerFailedException(cause),</span><br><span class="line">              reader.getReceiverId());</span><br><span class="line"></span><br><span class="line">            ctx.writeAndFlush(msg);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 读到了数据</span></span><br><span class="line">          <span class="keyword">if</span> (next.moreAvailable()) &#123;</span><br><span class="line">            <span class="comment">//这个 reader 还可以读到更多的数据，继续加入队列</span></span><br><span class="line">            registerAvailableReader(reader);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          BufferResponse msg = <span class="keyword">new</span> BufferResponse(</span><br><span class="line">            next.buffer(),</span><br><span class="line">            reader.getSequenceNumber(),</span><br><span class="line">            reader.getReceiverId(),</span><br><span class="line">            next.buffersInBacklog());</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 向 client 发送数据，发送成功之后通过 writeListener 的回调触发下一次发送</span></span><br><span class="line">          channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">if</span> (next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        next.buffer().recycleBuffer();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(t.getMessage(), t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteAndFlushNextMessageIfPossibleListener</span> <span class="keyword">implements</span> <span class="title">ChannelFutureListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">          <span class="comment">//发送成功，再次尝试写入</span></span><br><span class="line">          writeAndFlushNextMessageIfPossible(future.channel());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          handleException(future.channel(), future.cause());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          handleException(future.channel(), <span class="keyword">new</span> IllegalStateException(<span class="string">"Sending cancelled by user."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleException(future.channel(), t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Credit-based Flow Control 算法中，每发送一个 buffer 就会消耗一点 credit，在消费端有空闲 buffer 可用时会发送 <code>AddCrdit</code> 消息。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">NettyMessage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, NettyMessage msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (msgClazz == AddCredit.class) &#123;</span><br><span class="line">        <span class="comment">//增加 credit</span></span><br><span class="line">        AddCredit request = (AddCredit) msg;</span><br><span class="line">        outboundQueue.addCredit(request.receiverId, request.credit);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RequestReaderQueue</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addCredit</span><span class="params">(InputChannelID receiverId, <span class="keyword">int</span> credit)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fatalError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    NetworkSequenceViewReader reader = allReaders.get(receiverId);</span><br><span class="line">    <span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//增加 credit</span></span><br><span class="line">      reader.addCredit(credit);</span><br><span class="line">      <span class="comment">//因为增加了credit，可能可以继续处理数据，因此把 reader 加入队列</span></span><br><span class="line">      enqueueAvailableReader(reader);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No reader for receiverId = "</span> + receiverId + <span class="string">" exists."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="消费端处理流程"><a href="#消费端处理流程" class="headerlink" title="消费端处理流程"></a>消费端处理流程</h5><p>消费端即 <code>RemoteInputChannel</code> 一侧，在网络通信中对应 <code>NettyClient</code>。同样地，我们从 <code>ChannelHandler</code> 作为入口进行分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">NetworkClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelHandler</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">addInputChannel</span><span class="params">(RemoteInputChannel inputChannel)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">removeInputChannel</span><span class="params">(RemoteInputChannel inputChannel)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancelRequestFor</span><span class="params">(InputChannelID inputChannelId)</span></span>;</span><br><span class="line">  <span class="comment">//通知有新的的 credit 可用</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifyCreditAvailable</span><span class="params">(<span class="keyword">final</span> RemoteInputChannel inputChannel)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>NetworkClientHanlder</code> 对应的实现类为 <code>CreditBasedPartitionRequestClientHandler</code>，<code>CreditBasedPartitionRequestClientHandler</code> 负责接收服务端通过 Netty channel 发送的数据，解析数据后交给对应的 <code>RemoteInputChannle</code> 进行处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditBasedPartitionRequestClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">NetworkClientHandler</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//从netty channel中接收到数据</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//解析消息</span></span><br><span class="line">      decodeMsg(msg);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      notifyAllChannelsOfErrorAndClose(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeMsg</span><span class="params">(Object msg)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; msgClazz = msg.getClass();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ---- Buffer --------------------------------------------------------</span></span><br><span class="line">    <span class="keyword">if</span> (msgClazz == NettyMessage.BufferResponse.class) &#123;</span><br><span class="line">      <span class="comment">//正常的数据</span></span><br><span class="line">      NettyMessage.BufferResponse bufferOrEvent = (NettyMessage.BufferResponse) msg;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//根据 ID 定位到对应的 RemoteInputChannel</span></span><br><span class="line">      RemoteInputChannel inputChannel = inputChannels.get(bufferOrEvent.receiverId);</span><br><span class="line">      <span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有对应的 RemoteInputChannel</span></span><br><span class="line">        bufferOrEvent.releaseBuffer();</span><br><span class="line">        <span class="comment">//取消对给定 receiverId 的订阅</span></span><br><span class="line">        cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//解析消息，是buffer还是event</span></span><br><span class="line">      decodeBufferOrEvent(inputChannel, bufferOrEvent);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (msgClazz == NettyMessage.ErrorResponse.class) &#123;</span><br><span class="line">      <span class="comment">// ---- Error ---------------------------------------------------------</span></span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Received unknown message from producer: "</span> + msg.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeBufferOrEvent</span><span class="params">(RemoteInputChannel inputChannel, NettyMessage.BufferResponse bufferOrEvent)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ByteBuf nettyBuffer = bufferOrEvent.getNettyBuffer();</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> receivedSize = nettyBuffer.readableBytes();</span><br><span class="line">      <span class="keyword">if</span> (bufferOrEvent.isBuffer()) &#123;</span><br><span class="line">        <span class="comment">// ---- Buffer ------------------------------------------------</span></span><br><span class="line">        <span class="comment">// Early return for empty buffers. Otherwise Netty's readBytes() throws an</span></span><br><span class="line">        <span class="comment">// IndexOutOfBoundsException.</span></span><br><span class="line">        <span class="keyword">if</span> (receivedSize == <span class="number">0</span>) &#123;</span><br><span class="line">          inputChannel.onEmptyBuffer(bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从对应的 RemoteInputChannel 中请求一个 Buffer</span></span><br><span class="line">        Buffer buffer = inputChannel.requestBuffer();</span><br><span class="line">        <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//将接收的数据写入buffer</span></span><br><span class="line">          nettyBuffer.readBytes(buffer.asByteBuf(), receivedSize);</span><br><span class="line"></span><br><span class="line">          <span class="comment">//通知对应的channel，backlog是生产者那边堆积的buffer数量</span></span><br><span class="line">          inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputChannel.isReleased()) &#123;</span><br><span class="line">          cancelRequestFor(bufferOrEvent.receiverId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"No buffer available in credit-based input channel."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ---- Event -------------------------------------------------</span></span><br><span class="line">        <span class="comment">// TODO We can just keep the serialized data in the Netty buffer and release it later at the reader</span></span><br><span class="line">        <span class="keyword">byte</span>[] byteArray = <span class="keyword">new</span> <span class="keyword">byte</span>[receivedSize];</span><br><span class="line">        nettyBuffer.readBytes(byteArray);</span><br><span class="line"></span><br><span class="line">        MemorySegment memSeg = MemorySegmentFactory.wrap(byteArray);</span><br><span class="line">        <span class="comment">//是一个事件，不需要从 RemoteInputChannel 中申请 buffer</span></span><br><span class="line">        Buffer buffer = <span class="keyword">new</span> NetworkBuffer(memSeg, FreeingBufferRecycler.INSTANCE, <span class="keyword">false</span>, receivedSize);</span><br><span class="line">        <span class="comment">//通知对应的channel，backlog是生产者那边堆积的buffer数量</span></span><br><span class="line">        inputChannel.onBuffer(buffer, bufferOrEvent.sequenceNumber, bufferOrEvent.backlog);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      bufferOrEvent.releaseBuffer();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CreditBasedPartitionRequestClientHandler</code> 从网络中读取数据后交给 <code>RemoteInputChannel</code>， <code>RemoteInputChannel</code> 会将接收到的加入队列中，并根据生产端的堆积申请 floating buffer：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteInputChannel</span> <span class="keyword">extends</span> <span class="title">InputChannel</span> <span class="keyword">implements</span> <span class="title">BufferRecycler</span>, <span class="title">BufferListener</span> </span>&#123;</span><br><span class="line">  <span class="comment">//接收到远程 ResultSubpartition 发送的 Buffer</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBuffer</span><span class="params">(Buffer buffer, <span class="keyword">int</span> sequenceNumber, <span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> recycleBuffer = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">boolean</span> wasEmpty;</span><br><span class="line">      <span class="keyword">synchronized</span> (receivedBuffers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isReleased.get()) &#123;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//序号需要匹配</span></span><br><span class="line">        <span class="keyword">if</span> (expectedSequenceNumber != sequenceNumber) &#123;</span><br><span class="line">          onError(<span class="keyword">new</span> BufferReorderingException(expectedSequenceNumber, sequenceNumber));</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加入 receivedBuffers 队列中</span></span><br><span class="line">        wasEmpty = receivedBuffers.isEmpty();</span><br><span class="line">        receivedBuffers.add(buffer);</span><br><span class="line">        recycleBuffer = <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      ++expectedSequenceNumber;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (wasEmpty) &#123;</span><br><span class="line">        <span class="comment">//通知 InputGate，当前 channel 有新数据</span></span><br><span class="line">        notifyChannelNonEmpty();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (backlog &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//根据客户端的积压申请float buffer</span></span><br><span class="line">        onSenderBacklog(backlog);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (recycleBuffer) &#123;</span><br><span class="line">        buffer.recycleBuffer();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//backlog 是发送端的堆积 的 buffer 数量，</span></span><br><span class="line">  <span class="comment">//如果 bufferQueue 中 buffer 的数量不足，就去须从 LocalBufferPool 中请求 floating buffer</span></span><br><span class="line">  <span class="comment">//在请求了新的 buffer 后，通知生产者有 credit 可用</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">onSenderBacklog</span><span class="params">(<span class="keyword">int</span> backlog)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> numRequestedBuffers = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (bufferQueue) &#123;</span><br><span class="line">      <span class="comment">// Similar to notifyBufferAvailable(), make sure that we never add a buffer</span></span><br><span class="line">      <span class="comment">// after releaseAllResources() released all buffers (see above for details).</span></span><br><span class="line">      <span class="keyword">if</span> (isReleased.get()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//需要的 buffer 数量是 backlog + initialCredit, backlog 是生产者当前的积压</span></span><br><span class="line">      numRequiredBuffers = backlog + initialCredit;</span><br><span class="line">      <span class="keyword">while</span> (bufferQueue.getAvailableBufferSize() &lt; numRequiredBuffers &amp;&amp; !isWaitingForFloatingBuffers) &#123;</span><br><span class="line">        <span class="comment">//不停地请求新的 floating buffer</span></span><br><span class="line">        Buffer buffer = inputGate.getBufferPool().requestBuffer();</span><br><span class="line">        <span class="keyword">if</span> (buffer != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//从 buffer poll 中请求到 buffer</span></span><br><span class="line">          bufferQueue.addFloatingBuffer(buffer);</span><br><span class="line">          numRequestedBuffers++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (inputGate.getBufferProvider().addBufferListener(<span class="keyword">this</span>)) &#123;</span><br><span class="line">          <span class="comment">// buffer pool 没有 buffer 了，加一个监听，当 LocalBufferPool 中有新的 buffer 时会回调 notifyBufferAvailable</span></span><br><span class="line">          <span class="comment">// If the channel has not got enough buffers, register it as listener to wait for more floating buffers.</span></span><br><span class="line">          isWaitingForFloatingBuffers = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (numRequestedBuffers &gt; <span class="number">0</span> &amp;&amp; unannouncedCredit.getAndAdd(numRequestedBuffers) == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//请求了新的floating buffer，要更新 credit</span></span><br><span class="line">      notifyCreditAvailable();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyCreditAvailable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    checkState(partitionRequestClient != <span class="keyword">null</span>, <span class="string">"Tried to send task event to producer before requesting a queue."</span>);</span><br><span class="line">    <span class="comment">//通知当前 channel 有新的 credit</span></span><br><span class="line">    partitionRequestClient.notifyCreditAvailable(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//LocalBufferPool 通知有 buffer 可用</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> NotificationResult <span class="title">notifyBufferAvailable</span><span class="params">(Buffer buffer)</span> </span>&#123;</span><br><span class="line">    NotificationResult notificationResult = NotificationResult.BUFFER_NOT_USED;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (bufferQueue) &#123;</span><br><span class="line">        checkState(isWaitingForFloatingBuffers,</span><br><span class="line">          <span class="string">"This channel should be waiting for floating buffers."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Important: make sure that we never add a buffer after releaseAllResources()</span></span><br><span class="line">        <span class="comment">// released all buffers. Following scenarios exist:</span></span><br><span class="line">        <span class="comment">// 1) releaseAllResources() already released buffers inside bufferQueue</span></span><br><span class="line">        <span class="comment">// -&gt; then isReleased is set correctly</span></span><br><span class="line">        <span class="comment">// 2) releaseAllResources() did not yet release buffers from bufferQueue</span></span><br><span class="line">        <span class="comment">// -&gt; we may or may not have set isReleased yet but will always wait for the</span></span><br><span class="line">        <span class="comment">// lock on bufferQueue to release buffers</span></span><br><span class="line">        <span class="keyword">if</span> (isReleased.get() || bufferQueue.getAvailableBufferSize() &gt;= numRequiredBuffers) &#123;</span><br><span class="line">          isWaitingForFloatingBuffers = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">return</span> notificationResult;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//增加floating buffer</span></span><br><span class="line">        bufferQueue.addFloatingBuffer(buffer);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bufferQueue.getAvailableBufferSize() == numRequiredBuffers) &#123;</span><br><span class="line">          <span class="comment">//bufferQueue中有足够多的 buffer 了</span></span><br><span class="line">          isWaitingForFloatingBuffers = <span class="keyword">false</span>;</span><br><span class="line">          notificationResult = NotificationResult.BUFFER_USED_NO_NEED_MORE;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//bufferQueue 中 buffer 仍然不足</span></span><br><span class="line">          notificationResult = NotificationResult.BUFFER_USED_NEED_MORE;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (unannouncedCredit.getAndAdd(<span class="number">1</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        notifyCreditAvailable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      setError(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> notificationResult;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦 <code>RemoteInputChannel</code> 申请到新的 buffer，就需要通知生产者更新 credit，这需要发送一条 <code>AddCredit</code> 消息：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PartitionRequestClient</span> </span>&#123;</span><br><span class="line">  <span class="comment">//交给 NetworkClientHandler 处理</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyCreditAvailable</span><span class="params">(RemoteInputChannel inputChannel)</span> </span>&#123;</span><br><span class="line">    clientHandler.notifyCreditAvailable(inputChannel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditBasedPartitionRequestClientHandler</span> <span class="keyword">extends</span> <span class="title">ChannelInboundHandlerAdapter</span> <span class="keyword">implements</span> <span class="title">NetworkClientHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//有新的credit</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyCreditAvailable</span><span class="params">(<span class="keyword">final</span> RemoteInputChannel inputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//触发一次自定义事件</span></span><br><span class="line">    ctx.executor().execute(() -&gt; ctx.pipeline().fireUserEventTriggered(inputChannel));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelWritabilityChanged</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> RemoteInputChannel) &#123;</span><br><span class="line">      <span class="comment">//有新的credit会触发</span></span><br><span class="line">      <span class="keyword">boolean</span> triggerWrite = inputChannelsWithCredit.isEmpty();</span><br><span class="line"></span><br><span class="line">      <span class="comment">//加入到队列中</span></span><br><span class="line">      inputChannelsWithCredit.add((RemoteInputChannel) msg);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (triggerWrite) &#123;</span><br><span class="line">        writeAndFlushNextMessageIfPossible(ctx.channel());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      ctx.fireUserEventTriggered(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeAndFlushNextMessageIfPossible</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (channelError.get() != <span class="keyword">null</span> || !channel.isWritable()) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从队列中取出 RemoteInputChannel， 发送消息</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      RemoteInputChannel inputChannel = inputChannelsWithCredit.poll();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The input channel may be null because of the write callbacks</span></span><br><span class="line">      <span class="comment">// that are executed after each write.</span></span><br><span class="line">      <span class="keyword">if</span> (inputChannel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//It is no need to notify credit for the released channel.</span></span><br><span class="line">      <span class="keyword">if</span> (!inputChannel.isReleased()) &#123;</span><br><span class="line">        <span class="comment">//发送 AddCredit 的消息</span></span><br><span class="line">        AddCredit msg = <span class="keyword">new</span> AddCredit(</span><br><span class="line">          inputChannel.getPartitionId(),</span><br><span class="line">          inputChannel.getAndResetUnannouncedCredit(), <span class="comment">//获取并重置新增的credit</span></span><br><span class="line">          inputChannel.getInputChannelId());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write and flush and wait until this is done before</span></span><br><span class="line">        <span class="comment">// trying to continue with the next input channel.</span></span><br><span class="line">        channel.writeAndFlush(msg).addListener(writeListener);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteAndFlushNextMessageIfPossibleListener</span> <span class="keyword">implements</span> <span class="title">ChannelFutureListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">          writeAndFlushNextMessageIfPossible(future.channel());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (future.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">          notifyAllChannelsOfErrorAndClose(future.cause());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          notifyAllChannelsOfErrorAndClose(<span class="keyword">new</span> IllegalStateException(<span class="string">"Sending cancelled by user."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        notifyAllChannelsOfErrorAndClose(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="反压"><a href="#反压" class="headerlink" title="反压"></a>反压</h2><p>在上面几节，我们已经详细地分析了 Task 之间的数据交换机制和它们的实现原理，理解这这些实际上就已经理解了 Flink 的“反压”机制。</p>
<p>所谓“反压”，就是指在流处理系统中，下游任务的处理速度跟不上上游任务的数据生产速度。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。反压机制就是指系统能够自己检测到被阻塞的算子，然后系统自适应地降低源头或者上游的发送速率。在 Flink 中，应对“反压”是一种极其自然的方式，因为 Flink 中的数据传输机制已经提供了应对反压的措施。</p>
<p>在本地数据交换的情况下，两个 Task 实际上是同一个 JVM 中的两个线程，Task1 产生的 Buffer 直接被 Task2 使用，当 Task2 处理完之后这个 Buffer 就会被回收到本地缓冲池中。一旦 Task2 的处理速度比 Task2 产生 Buffer 的速度慢，那么缓冲池中 Buffer 渐渐地就会被耗尽，Task1 无法申请到新的 Buffer 自然就会阻塞，因而会导致 Task1 的降速。</p>
<p>在网络数据交换的情况下，如果下游 Task 的处理速度较慢，下游 Task 的接收缓冲池逐渐耗尽后就无法从网络中读取新的数据，这回导致上游 Task 无法将缓冲池中的 Buffer 发送到网络中，因此上游 Task 的缓冲池也会被耗尽，进而导致上游任务的降速。为了解决网络连接阻塞导致所有 Task 都无法处理数据的情况，Flink 还引入了 Credit-based Flow Control 算法，在上游生产者下游消费只之间通过“信用点”来协调发送速度，确保网络连接永远不会被阻塞。同时，Flink 的网络栈基于 Netty 构建，通过 Netty 的水位线机制也可以控制发送端的发送速率。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文详细地分析在 Flink 作业中，不同的 Task 之间是如何进行数据交换的。我们先介绍了 Flink 数据交换机制的整体流程，然后分别对本地数据交换和网络数据交换的情况进行了细致的分析。在最后，我们也概括了 Flink 是如何应对“背压”的。总的来说，通过合理地利用缓冲池和流量控制算法，Flink 可以高效地在不同 Task 之间进行数据传输，并优雅地达到了自适应调整速度效果。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cwiki.apache.org/confluence/display/FLINK/Data+exchange+between+tasks?src=contextnavpagetreemode" target="_blank" rel="noopener">Data exchange between tasks</a></li>
<li><a href="https://docs.google.com/document/d/1chTOuOqe0sBsjldA_r-wXYeSIhU2zRGpUaTaik7QZ84/edit#heading=h.pjh6mv7m2hjn" target="_blank" rel="noopener">FLIP- Network Stack Improvements</a></li>
<li><a href="http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/" target="_blank" rel="noopener">Flink 原理与实现：如何处理反压问题</a></li>
<li><a href="https://www.ververica.com/blog/how-flink-handles-backpressure" target="_blank" rel="noopener">How Apache Flink™ handles backpressure</a></li>
</ul>
<p>-EOF-</p>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flink/" rel="tag">#Flink</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/flink-source-code-task-lifecycle/" rel="prev">Flink 源码阅读笔记（9）- Task 的生命周期</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/flink-source-code-memory-management/" rel="next">Flink 源码阅读笔记（7）- 内存管理</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.png" alt="JR" itemprop="image"/>
          <p class="site-author-name" itemprop="name">JR</p>
        </div>
        <p class="site-description motion-element" itemprop="description">想入非非就是寻找神奇</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">43</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">21</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jrthe42" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jrthe42" target="_blank">Weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://music.jrwang.me" target="_blank">Music</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://wiki.jrwang.me" target="_blank">Wiki</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jrwang.me" target="_blank">Site</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#概览"><span class="nav-number">1.</span> <span class="nav-text">概览</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据交换的控制流"><span class="nav-number">1.1.</span> <span class="nav-text">数据交换的控制流</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节缓冲区在两个-Task-之间的传输"><span class="nav-number">1.2.</span> <span class="nav-text">字节缓冲区在两个 Task 之间的传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#几个基本概念"><span class="nav-number">2.</span> <span class="nav-text">几个基本概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#IntermediateDataset"><span class="nav-number">2.1.</span> <span class="nav-text">IntermediateDataset</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IntermediateResult-和-IntermediateResultpartition"><span class="nav-number">2.2.</span> <span class="nav-text">IntermediateResult 和 IntermediateResultpartition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResultPartition-和-ResultSubpartition"><span class="nav-number">2.3.</span> <span class="nav-text">ResultPartition 和 ResultSubpartition</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#InputGate-和-InputChannel"><span class="nav-number">2.4.</span> <span class="nav-text">InputGate 和 InputChannel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据交换机制的具体实现"><span class="nav-number">3.</span> <span class="nav-text">数据交换机制的具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Task-的输入和输出"><span class="nav-number">3.1.</span> <span class="nav-text">Task 的输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Task-的输出"><span class="nav-number">3.1.1.</span> <span class="nav-text">Task 的输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Task-的输入"><span class="nav-number">3.1.2.</span> <span class="nav-text">Task 的输入</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#本地数据交换"><span class="nav-number">3.2.</span> <span class="nav-text">本地数据交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过网络进行数据交换"><span class="nav-number">3.3.</span> <span class="nav-text">通过网络进行数据交换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#网络栈"><span class="nav-number">3.3.1.</span> <span class="nav-text">网络栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#流量控制"><span class="nav-number">3.3.2.</span> <span class="nav-text">流量控制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#具体实现"><span class="nav-number">3.3.3.</span> <span class="nav-text">具体实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#初始化"><span class="nav-number">3.3.3.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RemoteInputChannel-管理可用-buffer"><span class="nav-number">3.3.3.2.</span> <span class="nav-text">RemoteInputChannel 管理可用 buffer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#请求远端子分区"><span class="nav-number">3.3.3.3.</span> <span class="nav-text">请求远端子分区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#生产端的处理流程"><span class="nav-number">3.3.3.4.</span> <span class="nav-text">生产端的处理流程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#消费端处理流程"><span class="nav-number">3.3.3.5.</span> <span class="nav-text">消费端处理流程</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反压"><span class="nav-number">4.</span> <span class="nav-text">反压</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JR</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="powered-by">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  Modified By <a class="theme-link" href="http://jrwang.me">JR</a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
