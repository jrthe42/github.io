<!DOCTYPE html>
<html lang="zh-cn">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Flink 源码阅读笔记（8）- Task 之间的数据传输 - JR&#39;s Blog</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="jrthe42" /><meta name="description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中" /><meta name="keywords" content="jrthe42, Blog, Programming" />






<meta name="generator" content="Hugo 0.59.0 with theme even" />


<link rel="canonical" href="https://blog.jrwang.me/2019/flink-source-code-data-exchange/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">


<link href="/dist/even.7d171193.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="Flink 源码阅读笔记（8）- Task 之间的数据传输" />
<meta property="og:description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.jrwang.me/2019/flink-source-code-data-exchange/" />
<meta property="article:published_time" content="2019-05-25T20:03:00+00:00" />
<meta property="article:modified_time" content="2019-09-12T16:25:21+08:00" />
<meta itemprop="name" content="Flink 源码阅读笔记（8）- Task 之间的数据传输">
<meta itemprop="description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中">


<meta itemprop="datePublished" content="2019-05-25T20:03:00&#43;00:00" />
<meta itemprop="dateModified" content="2019-09-12T16:25:21&#43;08:00" />
<meta itemprop="wordCount" content="19501">



<meta itemprop="keywords" content="Flink," />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Flink 源码阅读笔记（8）- Task 之间的数据传输"/>
<meta name="twitter:description" content="在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">JRTHE42</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/about/">
        <li class="mobile-menu-item">About</li>
      </a>
  </ul>
</nav>
  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">JRTHE42</a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about/">About</a>
      </li>
  </ul>
</nav>
    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Flink 源码阅读笔记（8）- Task 之间的数据传输</h1>

      <div class="post-meta">
        <span class="post-time"> 2019-05-25 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">文章目录</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
<ul>
<li>
<ul>
<li><a href="#概览">概览</a>
<ul>
<li><a href="#数据交换的控制流">数据交换的控制流</a></li>
<li><a href="#字节缓冲区在两个-task-之间的传输">字节缓冲区在两个 Task 之间的传输</a></li>
</ul></li>
<li><a href="#几个基本概念">几个基本概念</a>
<ul>
<li><a href="#intermediatedataset">IntermediateDataset</a></li>
<li><a href="#intermediateresult-和-intermediateresultpartition">IntermediateResult 和 IntermediateResultpartition</a></li>
<li><a href="#resultpartition-和-resultsubpartition">ResultPartition 和 ResultSubpartition</a></li>
<li><a href="#inputgate-和-inputchannel">InputGate 和 InputChannel</a></li>
</ul></li>
<li><a href="#数据交换机制的具体实现">数据交换机制的具体实现</a>
<ul>
<li><a href="#task-的输入和输出">Task 的输入和输出</a>
<ul>
<li><a href="#task-的输出">Task 的输出</a></li>
<li><a href="#task-的输入">Task 的输入</a></li>
</ul></li>
<li><a href="#本地数据交换">本地数据交换</a></li>
<li><a href="#通过网络进行数据交换">通过网络进行数据交换</a>
<ul>
<li><a href="#网络栈">网络栈</a></li>
<li><a href="#流量控制">流量控制</a></li>
<li><a href="#具体实现">具体实现</a>
<ul>
<li><a href="#初始化">初始化</a></li>
<li><a href="#remoteinputchannel-管理可用-buffer">RemoteInputChannel 管理可用 buffer</a></li>
<li><a href="#请求远端子分区">请求远端子分区</a></li>
<li><a href="#生产端的处理流程">生产端的处理流程</a></li>
<li><a href="#消费端处理流程">消费端处理流程</a></li>
</ul></li>
</ul></li>
</ul></li>
<li><a href="#反压">反压</a></li>
<li><a href="#小结">小结</a></li>
<li><a href="#参考">参考</a></li>
</ul></li>
</ul>
</nav>
  </div>
</div>
    <div class="post-content">
      

<p>在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中必然涉及到网络通信，文中也会对 Flink 的网络栈的实现，包括反压机制等，进行分析。</p>

<h2 id="概览">概览</h2>

<p>Flink 的数据交换机制在设计时遵循两个基本原则：
1. 数据交换的控制流（例如，为初始化数据交换而发出的消息）是由接收端发起的
2. 数据交换的数据流（例如，在网络中实际传输的数据被抽象为 IntermediateResult 的概念）是可插拔的。这意味着系统基于相同的实现逻辑既可以支持 Streaming 模式也可以支持 Batch 模式下数据的传输</p>

<p>我们知道，在一个 TaskManager 中可能会同时并行运行多个 Task，每个 Task 都在单独的线程中运行。在不同的 TaskManager 中运行的 Task 之间进行数据传输要基于网络进行通信。实际上，是 TaskManager 和另一个 TaskManager 之间通过网络进行通信，通信是基于 Netty 创建的标准的 TCP 连接，同一个 TaskManager 内运行的不同 Task 会复用网络连接。</p>

<p>关于 Flink 的数据交换机制的具体流程，Flink 的 <a href="https://cwiki.apache.org/confluence/display/FLINK/Data+exchange+between+tasks">wiki</a> 中给出了一个比较详细的说明，在这里引述一下其中的内容，对我们后续分析具体的实现细节很有帮助。</p>

<h3 id="数据交换的控制流">数据交换的控制流</h3>

<p><img src="https://cwiki.apache.org/confluence/download/attachments/53741520/controlflow.png?version=1&amp;modificationDate=1426849323000&amp;api=v2" alt="controlflow" />
上图代表了一个简单的 map-reduce 类型的作业，有两个并行的任务。有两个 TaskManager，每个 TaskManager 都分别运行一个 map Task 和一个 reduce Task。我们重点观察 M1 和 R2 这两个 Task 之间的数据传输的发起过程。数据传输用粗箭头表示，消息用细箭头表示。首先，M1 产出了一个 ResultPartition(RP1)（箭头1）。当这个 RP 可以被消费是，会告知 JobManager（箭头2）。JobManager 会通知想要接收这个 RP 分区数据的接收者（tasks R1 and R2）当前分区数据已经准备好。如果接受放还没有被调度，这将会触发对应任务的部署（箭头 3a，3b）。接着，接受方会从 RP 中请求数据（箭头 4a，4b）。这将会初始化 Task 之间的数据传输（5a,5b）,数据传输可能是本地的(5a)，也可能是通过 TaskManager 的网络栈进行（5b）。对于一个 RP 什么时候告知 JobManager 当前已经出于可用状态，在这个过程中是有充分的自由度的：例如，如果在 RP1 在告知 JM 之前已经完整地产出了所有的数据（甚至可能写入了本地文件），那么相应的数据传输更类似于 Batch 的批交换；如果 RP1 在第一条记录产出时就告知 JM，那么就是 Streaming 流交换。</p>

<h3 id="字节缓冲区在两个-task-之间的传输">字节缓冲区在两个 Task 之间的传输</h3>

<p><img src="https://cwiki.apache.org/confluence/download/attachments/53741520/transfer.png?version=1&amp;modificationDate=1426849435000&amp;api=v2" alt="datatransfer" /></p>

<p>上面这张图展示了一个细节更加丰富的流程，描述了一条数据记录从生产者传输到消费者的完整生命周期。</p>

<p>最初，MapDriver 生成数据记录（通过 Collector 收集）并传递给 RecordWriter 对象。RecordWriter 包含一组序列化器，每个消费数据的 Task 分别对应一个。 ChannelSelector 会选择一个或多个序列化器处理记录。例如，如果记录需要被广播，那么就会被交给每一个序列化器进行处理；如果记录是按照 hash 进行分区的，ChannelSelector 会计算记录的哈希值，然后选择对应的序列化器。</p>

<p>序列化器会将记录序列化为二进制数据，并将其存放在固定大小的 buffer 中（一条记录可能需要跨越多个 buffer）。这些 buffer 被交给 BufferWriter 处理，写入到 ResulePartition（RP）中。 RP 有多个子分区（ResultSubpartitions - RSs）构成，每一个子分区都只收集特定消费者需要的数据。在上图中，需要被第二个 reducer （在 TaskManager 2 中）消费的记录被放在 RS2 中。由于第一个 Buffer 已经生成，RS2 就变成可被消费的状态了（注意，这个行为实现了一个 streaming shuffle），接着它通知 JobManager。</p>

<p>JobManager查找RS2的消费者，然后通知 TaskManager 2 一个数据块已经可以访问了。通知TM2的消息会被发送到InputChannel，该inputchannel被认为是接收这个buffer的，接着通知RS2可以初始化一个网络传输了。然后，RS2通过TM1的网络栈请求该buffer，然后双方基于 Netty 准备进行数据传输。网络连接是在TaskManager（而非特定的task）之间长时间存在的。</p>

<p>JobManager 查找 RS2 的消费者，并通知 TM2 一个数据块已经可以被访问了。通知 TM2 的消息被传递给 InputChannel，这个 InputChannel 负责接受这个 buffer。紧接着就通知 RS2 可以发起一起网络传输。 RS2 将 buffer 交给 TM1 的网络栈，然后基于 Netty 进行数据传输。网络连接是在 TM 之间长期存在在，而不是在独立的 Task 之间。</p>

<p>一旦 Buffer 被 TM2 接收，它同样会经过一个类似的结构，起始于 InputChannel，进入 InputGate（它包含多个IC），最终进入一个反序列化器（RecordDeserializer），它会从 buffer 中将记录还原成指定类型的对象，然后将其传递给接收数据的 Task。</p>

<h2 id="几个基本概念">几个基本概念</h2>

<p>在开始介绍 Flink 中数据交换机制的具体实现之前，我们有必要先对几个重要的概念进行一下梳理。这几个概念主要是到对 Flink 作业运行时产生的中间结果的抽象。</p>

<h3 id="intermediatedataset">IntermediateDataset</h3>

<p><code>IntermediateDataset</code> 是在 <code>JobGraph</code> 中对中间结果的抽象。我们知道，<code>JobGraph</code> 是对 <code>StreamGraph</code> 进一步进行优化后得到的逻辑图，它尽量把可以 chain 到一起 operator 合并为一个 <code>JobVertex</code>，而 <code>IntermediateDataset</code> 就表示一个 <code>JobVertex</code> 的输出结果。<code>JobVertex</code> 的输入是 <code>JobEdge</code>，而 <code>JobEdge</code> 可以看作是 <code>IntermediateDataset</code> 的消费者。一个 <code>JobVertex</code> 也可能产生多个 <code>IntermediateDataset</code>。需要说明的一点是，目前一个 <code>IntermediateDataset</code> 实际上只会有一个 <code>JobEdge</code> 作为消费者，也就是说，一个 <code>JobVertex</code> 的下游有多少 <code>JobVertex</code> 需要依赖当前节点的数据，那么当前节点就有对应数量的 <code>IntermediateDataset</code>。</p>

<h3 id="intermediateresult-和-intermediateresultpartition">IntermediateResult 和 IntermediateResultpartition</h3>

<p>在 JobManager 中，<code>JobGraph</code> 被进一步转换成可以被调度的并行化版本的执行图，即 <code>ExecutionGraph</code>。在 <code>ExecutionGraph</code> 中，和 <code>JobVertex</code> 对应的节点是 <code>ExecutionJobVertex</code>，和 <code>IntermediateDataset</code> 对应的则是 <code>IntermediataResult</code>。由于一个节点在实际运行时可能有多个并行子任务同时运行，所以 <code>ExecutionJobVertex</code> 按照并行度的设置被拆分为多个 <code>ExecutionVertex</code>，每一个表示一个并行的子任务。同样的，一个 <code>IntermediataResult</code> 也会被拆分为多个 <code>IntermediateResultPartition</code>，<code>IntermediateResultPartition</code> 对应 <code>ExecutionVertex</code> 的输出结果。一个 <code>IntermediateDataset</code> 只有一个消费者，那么一个 <code>IntermediataResult</code> 也只会有一个消费者；但是到了 <code>IntermediateResultPartition</code> 这里，由于节点被拆分成了并行化的节点，所以一个 <code>IntermediateResultPartition</code> 可能会有多个 <code>ExecutionEdge</code> 作为消费者。</p>

<h3 id="resultpartition-和-resultsubpartition">ResultPartition 和 ResultSubpartition</h3>

<p><code>ExecutionGraph</code> 还是 JobManager 中用于描述作业拓扑的一种逻辑上的数据结构，其中表示并行子任务的 <code>ExecutionVertex</code> 会被调度到 TaskManager 中执行，一个 <code>Task</code> 对应一个 <code>ExecutionVertex</code>。同 <code>ExecutionVertex</code> 的输出结果 <code>IntermediateResultPartition</code> 相对应的则是 <code>ResultPartition</code>。<code>IntermediateResultPartition</code> 可能会有多个 <code>ExecutionEdge</code> 作为消费者，那么在 Task 这里，<code>ResultPartition</code> 就会被拆分为多个 <code>ResultSubpartition</code>，下游每一个需要从当前 <code>ResultPartition</code> 消费数据的 Task 都会有一个专属的 <code>ResultSubpartition</code>。</p>

<p><code>ResultPartitionType</code> 指定了 <code>ResultPartition</code> 的不同属性，这些属性包括<strong>是否流水线模式</strong>、<strong>是否会产生反压</strong>以及<strong>是否限制使用的 Network buffer 的数量</strong>。<code>ResultPartitionType</code> 有三个枚举值：</p>

<ul>
<li><code>BLOCKING</code>：非流水线模式，无反压，不限制使用的网络缓冲的数量</li>
<li><code>PIPELINED</code>：流水线模式，有反压，不限制使用的网络缓冲的数量</li>
<li><code>PIPELINED_BOUNDED</code>：流水线模式，有反压，限制使用的网络缓冲的数量</li>
</ul>

<p>其中<strong>是否流水线模式</strong>这个属性会对消费行为产生很大的影响：如果是流水线模式，那么在 ResultPartition 接收到第一个 Buffer 时，消费者任务就可以进行准备消费；而如果非流水线模式，那么消费者将等到生产端任务生产完数据之后才进行消费。目前在 Stream 模式下使用的类型是 <code>PIPELINED_BOUNDED</code>。</p>

<h3 id="inputgate-和-inputchannel">InputGate 和 InputChannel</h3>

<p>在 Task 中，<code>InputGate</code> 是对输入的封装，<code>InputGate</code> 是和 JobGraph 中 <code>JobEdge</code> 一一对应的。也就是说，<code>InputGate</code> 实际上对应的是该 Task 依赖的上游算子（包含多个并行子任务），每个 <code>InputGate</code> 消费了一个或多个 <code>ResultPartition</code>。<code>InputGate</code> 由 <code>InputChannel</code> 构成，<code>InputChannel</code> 和 ExecutionGraph 中的 <code>ExecutionEdge</code> 一一对应；也就是说， <code>InputChannel</code> 和 <code>ResultSubpartition</code> 一一相连，一个 <code>InputChannel</code> 接收一个 <code>ResultSubpartition</code> 的输出。根据读取的 <code>ResultSubpartition</code> 的位置，<code>InputChannel</code> 有 <code>LocalInputChannel</code> 和 <code>RemoteInputChannel</code> 两种不同的实现。</p>

<h2 id="数据交换机制的具体实现">数据交换机制的具体实现</h2>

<p>数据交换从本质上来说就是一个典型的<strong>生产者-消费者</strong>模型，上游算子生产数据到 <code>ResultPartition</code> 中，下游算子通过 <code>InputGate</code> 消费数据。由于不同的 <code>Task</code> 可能在同一个 TaskManager 中运行，也可能在不同的 TaskManager 中运行：对于前者，不同的 Task 其实就是同一个 TaskManager 进程中的不同的线程，它们的数据交换就是在本地不同线程间进行的；对于后者，必须要通过网络进行通信。我们分别来介绍下这两个不同场景下数据交换的具体实现。通过合理的设计和抽象，Flink 确保本地数据交换和通过网络进行数据交换可以复用同一套代码。</p>

<h3 id="task-的输入和输出">Task 的输入和输出</h3>

<h4 id="task-的输出">Task 的输出</h4>

<p>Task 产出的每一个 <code>ResultPartition</code> 都有一个关联的 <code>ResultPartitionWriter</code>，同时也都有一个独立的 <code>LocalBufferPool</code> 负责提供写入数据所需的 buffer。<code>ResultPartion</code> 实现了 <code>ResultPartitionWriter</code> 接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">ResultPartition</span> <span class="nf">implements</span> <span class="n">ResultPartitionWriter</span><span class="p">,</span> <span class="n">BufferPoolOwner</span> <span class="p">{</span>
	<span class="cm">/** Type of this partition. Defines the concrete subpartition implementation to use. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultPartitionType</span> <span class="nf">partitionType</span><span class="p">;</span>

	<span class="c1">// ResultPartition 由 ResultSubpartition 构成，
</span><span class="c1"></span>	<span class="c1">// ResultSubpartition 的数量由下游消费 Task 数和 DistributionPattern 来决定。
</span><span class="c1"></span>	<span class="c1">// 例如，如果是 FORWARD，则下游只有一个消费者；如果是 SHUFFLE，则下游消费者的数量和下游算子的并行度一样
</span><span class="c1"></span>	<span class="cm">/** The subpartitions of this partition. At least one. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultSubpartition</span><span class="p">[]</span> <span class="nf">subpartitions</span><span class="p">;</span>

	<span class="c1">//ResultPartitionManager 管理当前 TaskManager 所有的 ResultPartition
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultPartitionManager</span> <span class="nf">partitionManager</span><span class="p">;</span>

	<span class="c1">//通知当前ResultPartition有数据可供消费的回调函数回调
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultPartitionConsumableNotifier</span> <span class="nf">partitionConsumableNotifier</span><span class="p">;</span>

	<span class="kd">private</span> <span class="nf">BufferPool</span> <span class="n">bufferPool</span><span class="p">;</span>

	<span class="c1">//在有数据产出时，是否需要发送消息来调度或更新消费者（Stream模式下调度模式为 ScheduleMode.EAGER，无需发通知）
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">boolean</span> <span class="nf">sendScheduleOrUpdateConsumersMessage</span><span class="p">;</span>
	<span class="c1">//是否已经通知了消费者
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">boolean</span> <span class="n">hasNotifiedPipelinedConsumers</span><span class="p">;</span>

	<span class="kd">public</span> <span class="nf">ResultPartition</span><span class="p">(</span>
		<span class="n">String</span> <span class="nf">owningTaskName</span><span class="p">,</span>
		<span class="n">TaskActions</span> <span class="nf">taskActions</span><span class="p">,</span> <span class="c1">// actions on the owning task
</span><span class="c1"></span>		<span class="n">JobID</span> <span class="nf">jobId</span><span class="p">,</span>
		<span class="n">ResultPartitionID</span> <span class="nf">partitionId</span><span class="p">,</span>
		<span class="n">ResultPartitionType</span> <span class="nf">partitionType</span><span class="p">,</span>
		<span class="kt">int</span> <span class="nf">numberOfSubpartitions</span><span class="p">,</span>
		<span class="kt">int</span> <span class="nf">numTargetKeyGroups</span><span class="p">,</span>
		<span class="n">ResultPartitionManager</span> <span class="nf">partitionManager</span><span class="p">,</span>
		<span class="n">ResultPartitionConsumableNotifier</span> <span class="nf">partitionConsumableNotifier</span><span class="p">,</span>
		<span class="n">IOManager</span> <span class="nf">ioManager</span><span class="p">,</span>
		<span class="kt">boolean</span> <span class="nf">sendScheduleOrUpdateConsumersMessage</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">this</span><span class="p">.</span><span class="na">owningTaskName</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">owningTaskName</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">taskActions</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">taskActions</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">jobId</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">jobId</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">partitionId</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">partitionId</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">partitionType</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">partitionType</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">subpartitions</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ResultSubpartition</span><span class="p">[</span><span class="n">numberOfSubpartitions</span><span class="p">];</span>
		<span class="k">this</span><span class="p">.</span><span class="na">numTargetKeyGroups</span> <span class="o">=</span> <span class="n">numTargetKeyGroups</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="na">partitionManager</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">partitionManager</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">partitionConsumableNotifier</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">partitionConsumableNotifier</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">sendScheduleOrUpdateConsumersMessage</span> <span class="o">=</span> <span class="n">sendScheduleOrUpdateConsumersMessage</span><span class="p">;</span>

		<span class="c1">// Create the subpartitions.
</span><span class="c1"></span>		<span class="k">switch</span> <span class="p">(</span><span class="n">partitionType</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Batch 模式，SpillableSubpartition，在 Buffer 不充足时将结果写入磁盘
</span><span class="c1"></span>			<span class="k">case</span> <span class="n">BLOCKING</span><span class="o">:</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">subpartitions</span><span class="p">.</span><span class="na">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">subpartitions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpillableSubpartition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">ioManager</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="c1">// Streaming 模式，PipelinedSubpartition
</span><span class="c1"></span>			<span class="k">case</span> <span class="n">PIPELINED</span><span class="o">:</span>
			<span class="k">case</span> <span class="n">PIPELINED_BOUNDED</span><span class="o">:</span>
				<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">subpartitions</span><span class="p">.</span><span class="na">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">subpartitions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PipelinedSubpartition</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
<span class="nl">
</span><span class="nl">			default:</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalArgumentException</span><span class="p">(</span><span class="s">&#34;Unsupported result partition type.&#34;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">// Initially, partitions should be consumed once before release.
</span><span class="c1"></span>		<span class="n">pin</span><span class="p">();</span>
		<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;{}: Initialized {}&#34;</span><span class="p">,</span> <span class="n">owningTaskName</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Task 启动的时候会向 <code>NetworkEnvironment</code> 进行注册，这里会为每一个 <code>ResultPartition</code> 分配 <code>LocalBufferPool</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">NetworkEnvironment</span> <span class="p">{</span>
	<span class="c1">//注册一个Task，要给这个Task的输入和输出分配 buffer pool
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">void</span> <span class="n">registerTask</span><span class="p">(</span><span class="n">Task</span> <span class="nf">task</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">ResultPartition</span><span class="p">[]</span> <span class="n">producedPartitions</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="na">getProducedPartitions</span><span class="p">();</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">......</span>
			<span class="c1">//输出
</span><span class="c1"></span>			<span class="k">for</span> <span class="p">(</span><span class="kd">final</span> <span class="nf">ResultPartition</span> <span class="n">partition</span> <span class="o">:</span> <span class="n">producedPartitions</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">setupPartition</span><span class="p">(</span><span class="n">partition</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="p">......</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">public</span> <span class="nf">void</span> <span class="n">setupPartition</span><span class="p">(</span><span class="n">ResultPartition</span> <span class="nf">partition</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="n">BufferPool</span> <span class="nf">bufferPool</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">//如果PartitionType 是 unbounded，则不限制buffer pool 的最大大小，否则为 sub-partition * taskmanager.network.memory.buffers-per-channel
</span><span class="c1"></span>			<span class="kt">int</span> <span class="nf">maxNumberOfMemorySegments</span> <span class="o">=</span> <span class="n">partition</span><span class="p">.</span><span class="na">getPartitionType</span><span class="p">().</span><span class="na">isBounded</span><span class="p">()</span> <span class="o">?</span>
				<span class="n">partition</span><span class="p">.</span><span class="na">getNumberOfSubpartitions</span><span class="p">()</span> <span class="o">*</span> <span class="n">config</span><span class="p">.</span><span class="na">networkBuffersPerChannel</span><span class="p">()</span> <span class="o">+</span>
					<span class="n">config</span><span class="p">.</span><span class="na">floatingNetworkBuffersPerGate</span><span class="p">()</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span>
			<span class="c1">// If the partition type is back pressure-free, we register with the buffer pool for
</span><span class="c1"></span>			<span class="c1">// callbacks to release memory.
</span><span class="c1"></span>			<span class="c1">//创建一个 LocalBufferPool，请求的最少的 MemeorySegment 数量和 sub-partition 一致
</span><span class="c1"></span>			<span class="c1">//如果没有反压，则需要自己处理 buffer 的回收（主要是在batch模式）
</span><span class="c1"></span>			<span class="n">bufferPool</span> <span class="o">=</span> <span class="n">networkBufferPool</span><span class="p">.</span><span class="na">createBufferPool</span><span class="p">(</span><span class="n">partition</span><span class="p">.</span><span class="na">getNumberOfSubpartitions</span><span class="p">(),</span>
				<span class="n">maxNumberOfMemorySegments</span><span class="p">,</span>
				<span class="n">partition</span><span class="p">.</span><span class="na">getPartitionType</span><span class="p">().</span><span class="na">hasBackPressure</span><span class="p">()</span> <span class="o">?</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">()</span> <span class="o">:</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">partition</span><span class="p">));</span>

			<span class="c1">//给这个 ResultPartition 分配 LocalBufferPool
</span><span class="c1"></span>			<span class="n">partition</span><span class="p">.</span><span class="na">registerBufferPool</span><span class="p">(</span><span class="n">bufferPool</span><span class="p">);</span>
			<span class="c1">//向 ResultPartitionManager 注册
</span><span class="c1"></span>			<span class="n">resultPartitionManager</span><span class="p">.</span><span class="na">registerResultPartition</span><span class="p">(</span><span class="n">partition</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="p">......</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Task 通过 <code>RecordWriter</code> 将结果写入 <code>ResultPartition</code> 中。<code>RecordWriter</code> 是对 <code>ResultPartitionWriter</code> 的一层封装，并负责将记录对象序列化到 buffer 中。先来看一下 <code>RecordWriter</code> 的成员变量和构造函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">RecordWriter</span> <span class="p">{</span>
	<span class="c1">//底层的 ResultPartition
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultPartitionWriter</span> <span class="nf">targetPartition</span><span class="p">;</span>
	<span class="c1">//决定一条记录应该写入哪一个channel， 即 sub-partition
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ChannelSelector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">channelSelector</span><span class="p">;</span>
	<span class="c1">//channel的数量，即 sub-partition的数量
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">int</span> <span class="nf">numberOfChannels</span><span class="p">;</span>
	<span class="c1">//broadcast记录
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">int</span><span class="p">[]</span> <span class="nf">broadcastChannels</span><span class="p">;</span>
	<span class="c1">//序列化
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">RecordSerializer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">serializer</span><span class="p">;</span>
	<span class="c1">//供每一个 channel 写入数据使用
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferBuilder</span><span class="o">&gt;</span><span class="p">[]</span> <span class="nf">bufferBuilders</span><span class="p">;</span>
	<span class="c1">//定时强制 flush 输出buffer
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">Optional</span><span class="o">&lt;</span><span class="n">OutputFlusher</span><span class="o">&gt;</span> <span class="nf">outputFlusher</span><span class="p">;</span>

	<span class="n">RecordWriter</span><span class="p">(</span><span class="n">ResultPartitionWriter</span> <span class="nf">writer</span><span class="p">,</span> <span class="n">ChannelSelector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nf">channelSelector</span><span class="p">,</span> <span class="kt">long</span> <span class="nf">timeout</span><span class="p">,</span> <span class="n">String</span> <span class="nf">taskName</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="na">targetPartition</span> <span class="o">=</span> <span class="n">writer</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="na">channelSelector</span> <span class="o">=</span> <span class="n">channelSelector</span><span class="p">;</span>
		<span class="k">this</span><span class="p">.</span><span class="na">numberOfChannels</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="na">getNumberOfSubpartitions</span><span class="p">();</span>
		<span class="k">this</span><span class="p">.</span><span class="na">channelSelector</span><span class="p">.</span><span class="na">setup</span><span class="p">(</span><span class="n">numberOfChannels</span><span class="p">);</span>

		<span class="c1">//序列化器，用于指的一提将一条记录序列化到多个buffer中
</span><span class="c1"></span>		<span class="k">this</span><span class="p">.</span><span class="na">serializer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SpanningRecordSerializer</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
		<span class="k">this</span><span class="p">.</span><span class="na">bufferBuilders</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Optional</span><span class="p">[</span><span class="n">numberOfChannels</span><span class="p">];</span>
		<span class="k">this</span><span class="p">.</span><span class="na">broadcastChannels</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">numberOfChannels</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numberOfChannels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">broadcastChannels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">bufferBuilders</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="n">checkArgument</span><span class="p">(</span><span class="n">timeout</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="n">1</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">flushAlways</span> <span class="o">=</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="n">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">==</span> <span class="o">-</span><span class="n">1</span> <span class="o">||</span> <span class="n">timeout</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">outputFlusher</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">//根据超时时间创建一个定时 flush 输出 buffer 的线程
</span><span class="c1"></span>			<span class="n">String</span> <span class="nf">threadName</span> <span class="o">=</span> <span class="n">taskName</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span>
				<span class="n">DEFAULT_OUTPUT_FLUSH_THREAD_NAME</span> <span class="o">:</span>
				<span class="n">DEFAULT_OUTPUT_FLUSH_THREAD_NAME</span> <span class="o">+</span> <span class="s">&#34; for &#34;</span> <span class="o">+</span> <span class="n">taskName</span><span class="p">;</span>
			<span class="n">outputFlusher</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="k">new</span> <span class="n">OutputFlusher</span><span class="p">(</span><span class="n">threadName</span><span class="p">,</span> <span class="n">timeout</span><span class="p">));</span>
			<span class="n">outputFlusher</span><span class="p">.</span><span class="na">get</span><span class="p">().</span><span class="na">start</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当 Task 通过 <code>RecordWriter</code> 输出一条记录时，主要流程为：</p>

<ol>
<li>通过 ChannelSelector 确定写入的目标 channel</li>
<li>使用 RecordSerializer 对记录进行序列化</li>
<li>向 ResultPartition 请求 BufferBuilder，用于写入序列化结果</li>
<li>向 ResultPartition 添加 BufferConsumer，用于读取写入 Buffer 的数据</li>
</ol>

<p>代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">RecordWriter</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">emit</span><span class="p">(</span><span class="n">T</span> <span class="nf">record</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="n">checkErroneous</span><span class="p">();</span>
		<span class="c1">//channelSelector确定目标channel
</span><span class="c1"></span>		<span class="n">emit</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">channelSelector</span><span class="p">.</span><span class="na">selectChannel</span><span class="p">(</span><span class="n">record</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">emit</span><span class="p">(</span><span class="n">T</span> <span class="nf">record</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">targetChannel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="c1">//序列化
</span><span class="c1"></span>		<span class="n">serializer</span><span class="p">.</span><span class="na">serializeRecord</span><span class="p">(</span><span class="n">record</span><span class="p">);</span>
		<span class="c1">//将序列化结果写入buffer
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">copyFromSerializerToTargetChannel</span><span class="p">(</span><span class="n">targetChannel</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">//清除序列化使用的buffer（这个是序列化时临时写入的byte[]）,减少内存占用
</span><span class="c1"></span>			<span class="n">serializer</span><span class="p">.</span><span class="na">prune</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//将序列化结果写入buffer
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">boolean</span> <span class="n">copyFromSerializerToTargetChannel</span><span class="p">(</span><span class="kt">int</span> <span class="nf">targetChannel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="c1">// We should reset the initial position of the intermediate serialization buffer before
</span><span class="c1"></span>		<span class="c1">// copying, so the serialization results can be copied to multiple target buffers.
</span><span class="c1"></span>		<span class="n">serializer</span><span class="p">.</span><span class="na">reset</span><span class="p">();</span>

		<span class="kt">boolean</span> <span class="nf">pruneTriggered</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
		<span class="n">BufferBuilder</span> <span class="nf">bufferBuilder</span> <span class="o">=</span> <span class="n">getBufferBuilder</span><span class="p">(</span><span class="n">targetChannel</span><span class="p">);</span>
		<span class="n">SerializationResult</span> <span class="nf">result</span> <span class="o">=</span> <span class="n">serializer</span><span class="p">.</span><span class="na">copyToBufferBuilder</span><span class="p">(</span><span class="n">bufferBuilder</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="na">isFullBuffer</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//buffer 写满了，调用 bufferBuilder.finish 方法
</span><span class="c1"></span>			<span class="n">numBytesOut</span><span class="p">.</span><span class="na">inc</span><span class="p">(</span><span class="n">bufferBuilder</span><span class="p">.</span><span class="na">finish</span><span class="p">());</span>
			<span class="n">numBuffersOut</span><span class="p">.</span><span class="na">inc</span><span class="p">();</span>

			<span class="c1">// If this was a full record, we are done. Not breaking out of the loop at this point
</span><span class="c1"></span>			<span class="c1">// will lead to another buffer request before breaking out (that would not be a
</span><span class="c1"></span>			<span class="c1">// problem per se, but it can lead to stalls in the pipeline).
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="na">isFullRecord</span><span class="p">())</span> <span class="p">{</span>
				<span class="c1">//当前这条记录也完整输出了
</span><span class="c1"></span>				<span class="n">pruneTriggered</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
				<span class="n">bufferBuilders</span><span class="p">[</span><span class="n">targetChannel</span><span class="p">]</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">//当前这条记录没有写完，申请新的 buffer 写入
</span><span class="c1"></span>			<span class="n">bufferBuilder</span> <span class="o">=</span> <span class="n">requestNewBufferBuilder</span><span class="p">(</span><span class="n">targetChannel</span><span class="p">);</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">serializer</span><span class="p">.</span><span class="na">copyToBufferBuilder</span><span class="p">(</span><span class="n">bufferBuilder</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">checkState</span><span class="p">(</span><span class="o">!</span><span class="n">serializer</span><span class="p">.</span><span class="na">hasSerializedData</span><span class="p">(),</span> <span class="s">&#34;All data should be written at once&#34;</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flushAlways</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//强制刷新结果
</span><span class="c1"></span>			<span class="n">targetPartition</span><span class="p">.</span><span class="na">flush</span><span class="p">(</span><span class="n">targetChannel</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">pruneTriggered</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">BufferBuilder</span> <span class="n">getBufferBuilder</span><span class="p">(</span><span class="kt">int</span> <span class="nf">targetChannel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bufferBuilders</span><span class="p">[</span><span class="n">targetChannel</span><span class="p">].</span><span class="na">isPresent</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">bufferBuilders</span><span class="p">[</span><span class="n">targetChannel</span><span class="p">].</span><span class="na">get</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">requestNewBufferBuilder</span><span class="p">(</span><span class="n">targetChannel</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//请求新的 BufferBuilder，用于写入数据 如果当前没有可用的 buffer，会阻塞
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">BufferBuilder</span> <span class="n">requestNewBufferBuilder</span><span class="p">(</span><span class="kt">int</span> <span class="nf">targetChannel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="n">checkState</span><span class="p">(</span><span class="o">!</span><span class="n">bufferBuilders</span><span class="p">[</span><span class="n">targetChannel</span><span class="p">].</span><span class="na">isPresent</span><span class="p">()</span> <span class="o">||</span> <span class="n">bufferBuilders</span><span class="p">[</span><span class="n">targetChannel</span><span class="p">].</span><span class="na">get</span><span class="p">().</span><span class="na">isFinished</span><span class="p">());</span>

		<span class="c1">//从 LocalBufferPool 中请求 BufferBuilder
</span><span class="c1"></span>		<span class="n">BufferBuilder</span> <span class="nf">bufferBuilder</span> <span class="o">=</span> <span class="n">targetPartition</span><span class="p">.</span><span class="na">getBufferProvider</span><span class="p">().</span><span class="na">requestBufferBuilderBlocking</span><span class="p">();</span>
		<span class="n">bufferBuilders</span><span class="p">[</span><span class="n">targetChannel</span><span class="p">]</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">bufferBuilder</span><span class="p">);</span>
		<span class="c1">//添加一个BufferConsumer，用于读取写入到 MemorySegment 的数据
</span><span class="c1"></span>		<span class="n">targetPartition</span><span class="p">.</span><span class="na">addBufferConsumer</span><span class="p">(</span><span class="n">bufferBuilder</span><span class="p">.</span><span class="na">createBufferConsumer</span><span class="p">(),</span> <span class="n">targetChannel</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">bufferBuilder</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>向 <code>ResultPartition</code> 添加一个 <code>BufferConsumer</code>， <code>ResultPartition</code> 会将其转交给对应的 <code>ResultSubpartition</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">ResultPartition</span> <span class="n">implement</span> <span class="nf">ResultPartitionWriter</span> <span class="p">{</span>
<span class="c1">//向指定的 subpartition 添加一个 buffer
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">addBufferConsumer</span><span class="p">(</span><span class="n">BufferConsumer</span> <span class="nf">bufferConsumer</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">subpartitionIndex</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="n">checkNotNull</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">);</span>

		<span class="n">ResultSubpartition</span> <span class="nf">subpartition</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="n">checkInProduceState</span><span class="p">();</span>
			<span class="n">subpartition</span> <span class="o">=</span> <span class="n">subpartitions</span><span class="p">[</span><span class="n">subpartitionIndex</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="k">catch</span> <span class="p">(</span><span class="n">Exception</span> <span class="nf">ex</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bufferConsumer</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
			<span class="k">throw</span> <span class="n">ex</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="c1">//添加 BufferConsumer，说明已经有数据生成了
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">subpartition</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">notifyPipelinedConsumers</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/**
</span><span class="cm">	 * Notifies pipelined consumers of this result partition once.
</span><span class="cm">	 */</span>
	<span class="kd">private</span> <span class="nf">void</span> <span class="n">notifyPipelinedConsumers</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//对于 Streaming 模式的任务，由于调度模式为 EAGER，所有的 task 都已经部署了，下面的通知不会触发
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">sendScheduleOrUpdateConsumersMessage</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hasNotifiedPipelinedConsumers</span> <span class="o">&amp;&amp;</span> <span class="n">partitionType</span><span class="p">.</span><span class="na">isPipelined</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//对于 PIPELINE 类型的 ResultPartition，在第一条记录产生时，
</span><span class="c1"></span>			<span class="c1">//会告知 JobMaster 当前 ResultPartition 可被消费，这会触发下游消费者 Task 的部署
</span><span class="c1"></span>			<span class="n">partitionConsumableNotifier</span><span class="p">.</span><span class="na">notifyPartitionConsumable</span><span class="p">(</span><span class="n">jobId</span><span class="p">,</span> <span class="n">partitionId</span><span class="p">,</span> <span class="n">taskActions</span><span class="p">);</span>
			<span class="n">hasNotifiedPipelinedConsumers</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>前面已经看到，根据 <code>ResultPartitionType</code> 的不同，<code>ResultSubpartition</code> 的实现类也不同。对于 Streaming 模式，使用的是 <code>PipelinedSubpartition</code> :</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">ResultSubpartition</span> <span class="p">{</span>
	<span class="cm">/** The index of the subpartition at the parent partition. */</span>
	<span class="kd">protected</span> <span class="nf">final</span> <span class="kt">int</span> <span class="nf">index</span><span class="p">;</span>

	<span class="cm">/** The parent partition this subpartition belongs to. */</span>
	<span class="kd">protected</span> <span class="nf">final</span> <span class="n">ResultPartition</span> <span class="nf">parent</span><span class="p">;</span>

	<span class="cm">/** All buffers of this subpartition. Access to the buffers is synchronized on this object. */</span>
	<span class="c1">//当前 subpartiion 堆积的所有的 Buffer 的队列
</span><span class="c1"></span>	<span class="kd">protected</span> <span class="nf">final</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">BufferConsumer</span><span class="o">&gt;</span> <span class="nf">buffers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="cm">/** The number of non-event buffers currently in this subpartition. */</span>
	<span class="c1">//当前 subpartiion 中堆积的 buffer 的数量
</span><span class="c1"></span>	<span class="nd">@GuardedBy</span><span class="p">(</span><span class="s">&#34;buffers&#34;</span><span class="p">)</span>
	<span class="kd">private</span> <span class="nf">int</span> <span class="n">buffersInBacklog</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nf">PipelinedSubpartition</span> <span class="kd">extends</span> <span class="nf">ResultSubpartition</span> <span class="p">{</span>
	<span class="c1">//用于消费写入的 Buffer
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">PipelinedSubpartitionView</span> <span class="n">readView</span><span class="p">;</span>

	<span class="c1">//index 是当前 sub-paritition 的索引
</span><span class="c1"></span>	<span class="n">PipelinedSubpartition</span><span class="p">(</span><span class="kt">int</span> <span class="nf">index</span><span class="p">,</span> <span class="n">ResultPartition</span> <span class="nf">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="kd">super</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">add</span><span class="p">(</span><span class="n">BufferConsumer</span> <span class="nf">bufferConsumer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//添加一个新的BufferConsumer
</span><span class="c1"></span>	<span class="c1">//这个参数里的 finish 指的是整个 subpartition 都完成了
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">boolean</span> <span class="n">add</span><span class="p">(</span><span class="n">BufferConsumer</span> <span class="nf">bufferConsumer</span><span class="p">,</span> <span class="kt">boolean</span> <span class="nf">finish</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">checkNotNull</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">);</span>

		<span class="kd">final</span> <span class="nf">boolean</span> <span class="n">notifyDataAvailable</span><span class="p">;</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">isFinished</span> <span class="o">||</span> <span class="n">isReleased</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bufferConsumer</span><span class="p">.</span><span class="na">close</span><span class="p">();</span>
				<span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">// Add the bufferConsumer and update the stats
</span><span class="c1"></span>			<span class="n">buffers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">);</span>
			<span class="n">updateStatistics</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">);</span>
			<span class="c1">//更新 backlog 的数量，只有 buffer 才会使得 buffersInBacklog + 1，事件不会增加 buffersInBacklog
</span><span class="c1"></span>			<span class="n">increaseBuffersInBacklog</span><span class="p">(</span><span class="n">bufferConsumer</span><span class="p">);</span>
			<span class="n">notifyDataAvailable</span> <span class="o">=</span> <span class="n">shouldNotifyDataAvailable</span><span class="p">()</span> <span class="o">||</span> <span class="n">finish</span><span class="p">;</span>

			<span class="n">isFinished</span> <span class="o">|=</span> <span class="n">finish</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">notifyDataAvailable</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//通知数据可以被消费
</span><span class="c1"></span>			<span class="n">notifyDataAvailable</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//只在第一个 buffer 为 finish 的时候才通知
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">boolean</span> <span class="n">shouldNotifyDataAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// Notify only when we added first finished buffer.
</span><span class="c1"></span>		<span class="k">return</span> <span class="n">readView</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flushRequested</span> <span class="o">&amp;&amp;</span> <span class="n">getNumberOfFinishedBuffers</span><span class="p">()</span> <span class="o">==</span> <span class="n">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="c1">//通知readView，有数据可用了
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">void</span> <span class="n">notifyDataAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readView</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">readView</span><span class="p">.</span><span class="na">notifyDataAvailable</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">flush</span><span class="p">()</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">boolean</span> <span class="n">notifyDataAvailable</span><span class="p">;</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffers</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">// if there is more then 1 buffer, we already notified the reader
</span><span class="c1"></span>			<span class="c1">// (at the latest when adding the second buffer)
</span><span class="c1"></span>			<span class="n">notifyDataAvailable</span> <span class="o">=</span> <span class="o">!</span><span class="n">flushRequested</span> <span class="o">&amp;&amp;</span> <span class="n">buffers</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">1</span><span class="p">;</span>
			<span class="n">flushRequested</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">notifyDataAvailable</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">notifyDataAvailable</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在强制进行 flush 的时候，也会发出数据可用的通知。这是因为，假如产出的数据记录较少无法完整地填充一个 <code>MemorySegment</code>，那么 <code>ResultSubpartition</code> 可能会一直处于不可被消费的状态。而为了保证产出的记录能够及时被消费，就需要及时进行 flush，从而确保下游能更及时地处理数据。在 <code>RecordWriter</code> 中有一个 <code>OutputFlusher</code> 会定时触发 flush，间隔可以通过 <code>DataStream.setBufferTimeout()</code> 来控制。</p>

<p>写入的 Buffer 最终被保存在 <code>ResultSubpartition</code> 中维护的一个队列中，如果需要消费这些 Buffer，就需要依赖 <code>ResultSubpartitionView</code>。当需要消费一个 <code>ResultSubpartition</code> 的结果时，需要创建一个 <code>ResultSubpartitionView</code> 对象，并关联到 <code>ResultSubpartition</code> 中；当数据可以被消费时，会通过对应的回调接口告知 <code>ResultSubpartitionView</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * A view to consume a {@link ResultSubpartition} instance.
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="nf">interface</span> <span class="n">ResultSubpartitionView</span> <span class="p">{</span>
	<span class="cm">/**
</span><span class="cm">	 * Returns the next {@link Buffer} instance of this queue iterator.
</span><span class="cm">	 *
</span><span class="cm">	 * &lt;p&gt;If there is currently no instance available, it will return &lt;code&gt;null&lt;/code&gt;.
</span><span class="cm">	 * This might happen for example when a pipelined queue producer is slower
</span><span class="cm">	 * than the consumer or a spilled queue needs to read in more data.
</span><span class="cm">	 *
</span><span class="cm">	 * &lt;p&gt;&lt;strong&gt;Important&lt;/strong&gt;: The consumer has to make sure that each
</span><span class="cm">	 * buffer instance will eventually be recycled with {@link Buffer#recycleBuffer()}
</span><span class="cm">	 * after it has been consumed.
</span><span class="cm">	 */</span>
	<span class="nd">@Nullable</span>
	<span class="n">BufferAndBacklog</span> <span class="nf">getNextBuffer</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span><span class="p">;</span>

	<span class="c1">//通知 ResultSubpartition 的数据可供消费
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">notifyDataAvailable</span><span class="p">();</span>

	<span class="c1">//已经完成对 ResultSubpartition 的消费
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">notifySubpartitionConsumed</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">;</span>

	<span class="kt">boolean</span> <span class="nf">nextBufferIsEvent</span><span class="p">();</span>
	<span class="c1">//........
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">class</span> <span class="nf">PipelinedSubpartitionView</span> <span class="kd">implements</span> <span class="nf">ResultSubpartitionView</span> <span class="p">{</span>
	<span class="cm">/** The subpartition this view belongs to. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">PipelinedSubpartition</span> <span class="nf">parent</span><span class="p">;</span>

	<span class="kd">private</span> <span class="nf">final</span> <span class="n">BufferAvailabilityListener</span> <span class="nf">availabilityListener</span><span class="p">;</span>

	<span class="cm">/** Flag indicating whether this view has been released. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">AtomicBoolean</span> <span class="nf">isReleased</span><span class="p">;</span>

	<span class="n">PipelinedSubpartitionView</span><span class="p">(</span><span class="n">PipelinedSubpartition</span> <span class="nf">parent</span><span class="p">,</span> <span class="n">BufferAvailabilityListener</span> <span class="nf">listener</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">this</span><span class="p">.</span><span class="na">parent</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">availabilityListener</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">isReleased</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AtomicBoolean</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Nullable</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">BufferAndBacklog</span> <span class="n">getNextBuffer</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">.</span><span class="na">pollBuffer</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyDataAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//回调接口
</span><span class="c1"></span>		<span class="n">availabilityListener</span><span class="p">.</span><span class="na">notifyDataAvailable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifySubpartitionConsumed</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">releaseAllResources</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">releaseAllResources</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">.</span><span class="na">compareAndSet</span><span class="p">(</span><span class="kc">false</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span> <span class="p">{</span>
			<span class="c1">// The view doesn&#39;t hold any resources and the parent cannot be restarted. Therefore,
</span><span class="c1"></span>			<span class="c1">// it&#39;s OK to notify about consumption as well.
</span><span class="c1"></span>			<span class="n">parent</span><span class="p">.</span><span class="na">onConsumedSubpartition</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">isReleased</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">isReleased</span><span class="p">.</span><span class="na">get</span><span class="p">()</span> <span class="o">||</span> <span class="n">parent</span><span class="p">.</span><span class="na">isReleased</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">nextBufferIsEvent</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">.</span><span class="na">nextBufferIsEvent</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">isAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">parent</span><span class="p">.</span><span class="na">isAvailable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当需要创建一个 <code>ResultSubpartition</code> 的消费者时，需要通过 <code>ResultPartitionManager</code> 来创建。<code>ResultPartitionManager</code> 会管理当前 Task 的所有 <code>ResultPartition</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">ResultPartitionManager</span> <span class="kd">implements</span> <span class="nf">ResultPartitionProvider</span> <span class="p">{</span>
	<span class="c1">//管理所有的 ResultPartition，使用的时 Guava 提供的支持多级映射的哈希表
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">final</span> <span class="n">Table</span><span class="o">&lt;</span><span class="n">ExecutionAttemptID</span><span class="p">,</span> <span class="n">IntermediateResultPartitionID</span><span class="p">,</span> <span class="n">ResultPartition</span><span class="o">&gt;</span>
			<span class="nf">registeredPartitions</span> <span class="o">=</span> <span class="n">HashBasedTable</span><span class="p">.</span><span class="na">create</span><span class="p">();</span>

	<span class="c1">//一个 Task 在向 NetworkEnvironment 注册的时候就会逐一注册所有的ResultPartition
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">void</span> <span class="n">registerResultPartition</span><span class="p">(</span><span class="n">ResultPartition</span> <span class="nf">partition</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">registeredPartitions</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">checkState</span><span class="p">(</span><span class="o">!</span><span class="n">isShutdown</span><span class="p">,</span> <span class="s">&#34;Result partition manager already shut down.&#34;</span><span class="p">);</span>

			<span class="n">ResultPartitionID</span> <span class="nf">partitionId</span> <span class="o">=</span> <span class="n">partition</span><span class="p">.</span><span class="na">getPartitionId</span><span class="p">();</span>

			<span class="n">ResultPartition</span> <span class="nf">previous</span> <span class="o">=</span> <span class="n">registeredPartitions</span><span class="p">.</span><span class="na">put</span><span class="p">(</span>
					<span class="n">partitionId</span><span class="p">.</span><span class="na">getProducerId</span><span class="p">(),</span> <span class="n">partitionId</span><span class="p">.</span><span class="na">getPartitionId</span><span class="p">(),</span> <span class="n">partition</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">previous</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Result partition already registered.&#34;</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">LOG</span><span class="p">.</span><span class="na">debug</span><span class="p">(</span><span class="s">&#34;Registered {}.&#34;</span><span class="p">,</span> <span class="n">partition</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//在指定的 ResultSubpartition 中创建一个 ResultSubpartitionView，用于消费数据
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">ResultSubpartitionView</span> <span class="n">createSubpartitionView</span><span class="p">(</span>
			<span class="n">ResultPartitionID</span> <span class="nf">partitionId</span><span class="p">,</span>
			<span class="kt">int</span> <span class="nf">subpartitionIndex</span><span class="p">,</span>
			<span class="n">BufferAvailabilityListener</span> <span class="nf">availabilityListener</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">registeredPartitions</span><span class="p">)</span> <span class="p">{</span>
			<span class="kd">final</span> <span class="nf">ResultPartition</span> <span class="n">partition</span> <span class="o">=</span> <span class="n">registeredPartitions</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">partitionId</span><span class="p">.</span><span class="na">getProducerId</span><span class="p">(),</span>
					<span class="n">partitionId</span><span class="p">.</span><span class="na">getPartitionId</span><span class="p">());</span>
			<span class="c1">//创建 ResultSubpartitionView，可以看作是 ResultSubpartition 的消费者
</span><span class="c1"></span>			<span class="k">return</span> <span class="n">partition</span><span class="p">.</span><span class="na">createSubpartitionView</span><span class="p">(</span><span class="n">subpartitionIndex</span><span class="p">,</span> <span class="n">availabilityListener</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>至此，我们已经了解了一个 Task 如何输出结果到 <code>ResultPartition</code> 中，以及如何去消费不同 <code>ResultSubpartition</code> 中的这些用于保存序列化结果的 Buffer。</p>

<h4 id="task-的输入">Task 的输入</h4>

<p>在了解了 Task 如何输出结果以后，接下来我们把目光投向 Task 的输入端。</p>

<p>前面已经介绍过，Task 的输入被抽象为 <code>InputGate</code>, 而 <code>InputGate</code> 则由 <code>InputChannel</code> 组成， <code>InputChannel</code> 和该 Task 需要消费的 <code>ResultSubpartition</code> 是一一对应的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">InputGate</span> <span class="nf">extends</span> <span class="n">AutoCloseable</span> <span class="p">{</span>

	<span class="kt">int</span> <span class="nf">getNumberOfInputChannels</span><span class="p">();</span>

	<span class="n">String</span> <span class="nf">getOwningTaskName</span><span class="p">();</span>

	<span class="kt">boolean</span> <span class="nf">isFinished</span><span class="p">();</span>

	<span class="c1">//请求消费 ResultPartition
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">requestPartitions</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span><span class="p">;</span>

	<span class="cm">/**
</span><span class="cm">	 * Blocking call waiting for next {@link BufferOrEvent}.
</span><span class="cm">	 * 阻塞调用
</span><span class="cm">	 * @return {@code Optional.empty()} if {@link #isFinished()} returns true.
</span><span class="cm">	 */</span>
	<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">getNextBufferOrEvent</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span><span class="p">;</span>

	<span class="cm">/**
</span><span class="cm">	 * Poll the {@link BufferOrEvent}.
</span><span class="cm">	 * 非阻塞调用
</span><span class="cm">	 * @return {@code Optional.empty()} if there is no data to return or if {@link #isFinished()} returns true.
</span><span class="cm">	 */</span>
	<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">pollNextBufferOrEvent</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">sendTaskEvent</span><span class="p">(</span><span class="n">TaskEvent</span> <span class="nf">event</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">;</span>

	<span class="kt">void</span> <span class="nf">registerListener</span><span class="p">(</span><span class="n">InputGateListener</span> <span class="nf">listener</span><span class="p">);</span>

	<span class="kt">int</span> <span class="nf">getPageSize</span><span class="p">();</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>Task 通过循环调用 <code>InputGate.getNextBufferOrEvent</code> 方法获取输入数据，并将获取的数据交给它所封装的算子进行处理，这构成了一个 Task 的基本运行逻辑。 <code>InputGate</code> 有两个具体的实现，分别为 <code>SingleInputGate</code> 和 <code>UnionInputGate</code>, <code>UnionInputGate</code> 有多个 <code>SingleInputGate</code> 联合构成。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">SingleInputGate</span> <span class="p">{</span>
	<span class="c1">//该 InputGate 包含的所有 InputChannel
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">IntermediateResultPartitionID</span><span class="p">,</span> <span class="n">InputChannel</span><span class="o">&gt;</span> <span class="nf">inputChannels</span><span class="p">;</span>

	<span class="cm">/** Channels, which notified this input gate about available data. */</span>
	<span class="c1">//InputChannel 构成的队列，这些 InputChannel 中都有有可供消费的数据
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">InputChannel</span><span class="o">&gt;</span> <span class="nf">inputChannelsWithData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="cm">/**
</span><span class="cm">	 * Buffer pool for incoming buffers. Incoming data from remote channels is copied to buffers
</span><span class="cm">	 * from this pool.
</span><span class="cm">	 */</span>
	<span class="c1">//用于接收输入的缓冲池
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">BufferPool</span> <span class="n">bufferPool</span><span class="p">;</span>

	<span class="cm">/** Global network buffer pool to request and recycle exclusive buffers (only for credit-based). */</span>
	<span class="c1">//全局网络缓冲池
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">NetworkBufferPool</span> <span class="n">networkBufferPool</span><span class="p">;</span>

	<span class="cm">/** Registered listener to forward buffer notifications to. */</span>
	<span class="kd">private</span> <span class="nf">volatile</span> <span class="n">InputGateListener</span> <span class="nf">inputGateListener</span><span class="p">;</span>

	<span class="kd">private</span> <span class="nf">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">getNextBufferOrEvent</span><span class="p">(</span><span class="kt">boolean</span> <span class="nf">blocking</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hasReceivedAllEndOfPartitionEvents</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Released&#34;</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">//首先尝试请求分区，实际的请求只会执行一次
</span><span class="c1"></span>		<span class="n">requestPartitions</span><span class="p">();</span>

		<span class="n">InputChannel</span> <span class="nf">currentChannel</span><span class="p">;</span>
		<span class="kt">boolean</span> <span class="nf">moreAvailable</span><span class="p">;</span>
		<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferAndAvailability</span><span class="o">&gt;</span> <span class="nf">result</span> <span class="o">=</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="kd">synchronized</span> <span class="p">(</span><span class="n">inputChannelsWithData</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//从 inputChannelsWithData 队列中获取有数据的 channel，经典的生产者-消费者模式
</span><span class="c1"></span>				<span class="k">while</span> <span class="p">(</span><span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Released&#34;</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="k">if</span> <span class="p">(</span><span class="n">blocking</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span>
					<span class="p">}</span>
					<span class="k">else</span> <span class="p">{</span>
						<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="n">currentChannel</span> <span class="o">=</span> <span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">remove</span><span class="p">();</span>
				<span class="n">enqueuedInputChannelsWithData</span><span class="p">.</span><span class="na">clear</span><span class="p">(</span><span class="n">currentChannel</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>
				<span class="c1">//是否还有更多的数据
</span><span class="c1"></span>				<span class="n">moreAvailable</span> <span class="o">=</span> <span class="o">!</span><span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="n">result</span> <span class="o">=</span> <span class="n">currentChannel</span><span class="p">.</span><span class="na">getNextBuffer</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">.</span><span class="na">isPresent</span><span class="p">());</span>

		<span class="c1">// this channel was now removed from the non-empty channels queue
</span><span class="c1"></span>		<span class="c1">// we re-add it in case it has more data, because in that case no &#34;non-empty&#34; notification
</span><span class="c1"></span>		<span class="c1">// will come for that channel
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="na">get</span><span class="p">().</span><span class="na">moreAvailable</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//如果这个channel还有更多的数据，继续加入到队列中
</span><span class="c1"></span>			<span class="n">queueChannel</span><span class="p">(</span><span class="n">currentChannel</span><span class="p">);</span>
			<span class="n">moreAvailable</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="kd">final</span> <span class="nf">Buffer</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="na">get</span><span class="p">().</span><span class="na">buffer</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="na">isBuffer</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="k">new</span> <span class="n">BufferOrEvent</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">currentChannel</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">(),</span> <span class="n">moreAvailable</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="kd">final</span> <span class="nf">AbstractEvent</span> <span class="n">event</span> <span class="o">=</span> <span class="n">EventSerializer</span><span class="p">.</span><span class="na">fromBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">getClass</span><span class="p">().</span><span class="na">getClassLoader</span><span class="p">());</span>

			<span class="c1">//如果是 EndOfPartitionEvent 事件，那么如果所有的 InputChannel 都接收到这个事件了
</span><span class="c1"></span>			<span class="c1">//将 hasReceivedAllEndOfPartitionEvents 标记为 true，此后不再能获取到数据
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">EndOfPartitionEvent</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">channelsWithEndOfPartitionEvents</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">currentChannel</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">channelsWithEndOfPartitionEvents</span><span class="p">.</span><span class="na">cardinality</span><span class="p">()</span> <span class="o">==</span> <span class="n">numberOfInputChannels</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">// Because of race condition between:
</span><span class="c1"></span>					<span class="c1">// 1. releasing inputChannelsWithData lock in this method and reaching this place
</span><span class="c1"></span>					<span class="c1">// 2. empty data notification that re-enqueues a channel
</span><span class="c1"></span>					<span class="c1">// we can end up with moreAvailable flag set to true, while we expect no more data.
</span><span class="c1"></span>					<span class="n">checkState</span><span class="p">(</span><span class="o">!</span><span class="n">moreAvailable</span> <span class="o">||</span> <span class="o">!</span><span class="n">pollNextBufferOrEvent</span><span class="p">().</span><span class="na">isPresent</span><span class="p">());</span>
					<span class="n">moreAvailable</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
					<span class="n">hasReceivedAllEndOfPartitionEvents</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">currentChannel</span><span class="p">.</span><span class="na">notifySubpartitionConsumed</span><span class="p">();</span>

				<span class="n">currentChannel</span><span class="p">.</span><span class="na">releaseAllResources</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="k">new</span> <span class="n">BufferOrEvent</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">currentChannel</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">(),</span> <span class="n">moreAvailable</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//当一个 InputChannel 有数据时的回调
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">notifyChannelNonEmpty</span><span class="p">(</span><span class="n">InputChannel</span> <span class="nf">channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queueChannel</span><span class="p">(</span><span class="n">checkNotNull</span><span class="p">(</span><span class="n">channel</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="c1">//将新的channel加入队列
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">void</span> <span class="n">queueChannel</span><span class="p">(</span><span class="n">InputChannel</span> <span class="nf">channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="nf">availableChannels</span><span class="p">;</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">inputChannelsWithData</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//判断这个channel是否已经在队列中
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">enqueuedInputChannelsWithData</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">channel</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">()))</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">availableChannels</span> <span class="o">=</span> <span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>

			<span class="c1">//加入队列
</span><span class="c1"></span>			<span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
			<span class="n">enqueuedInputChannelsWithData</span><span class="p">.</span><span class="na">set</span><span class="p">(</span><span class="n">channel</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">availableChannels</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//如果之前队列中没有channel，这个channel加入后，通知等待的线程
</span><span class="c1"></span>				<span class="n">inputChannelsWithData</span><span class="p">.</span><span class="na">notifyAll</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">availableChannels</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//如果之前队列中没有channel，这个channel加入后，通知InputGateListener
</span><span class="c1"></span>			<span class="c1">//表明这个 InputGate 中有数据了
</span><span class="c1"></span>			<span class="n">InputGateListener</span> <span class="nf">listener</span> <span class="o">=</span> <span class="n">inputGateListener</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">listener</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">listener</span><span class="p">.</span><span class="na">notifyInputGateNonEmpty</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//请求分区
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">requestPartitions</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">requestLock</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//只请求一次
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">requestedPartitionsFlag</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Already released.&#34;</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="c1">// Sanity checks
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">numberOfInputChannels</span> <span class="o">!=</span> <span class="n">inputChannels</span><span class="p">.</span><span class="na">size</span><span class="p">())</span> <span class="p">{</span>
					<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Bug in input gate setup logic: mismatch between &#34;</span> <span class="o">+</span>
							<span class="s">&#34;number of total input channels and the currently set number of input &#34;</span> <span class="o">+</span>
							<span class="s">&#34;channels.&#34;</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="k">for</span> <span class="p">(</span><span class="n">InputChannel</span> <span class="nf">inputChannel</span> <span class="o">:</span> <span class="n">inputChannels</span><span class="p">.</span><span class="na">values</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//每一个channel都请求对应的子分区
</span><span class="c1"></span>					<span class="n">inputChannel</span><span class="p">.</span><span class="na">requestSubpartition</span><span class="p">(</span><span class="n">consumedSubpartitionIndex</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">requestedPartitionsFlag</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>SingleInputGate</code> 的逻辑还比较清晰，它通过内部维护的一个队列形成一个生产者-消费者的模型，当 <code>InputChannel</code> 中有数据时就加入到队列中，在需要获取数据时从队列中取出一个 channel，获取 channel 中的数据。</p>

<p><code>UnionInputGate</code> 时多个 <code>SingleInputGate</code> 联合组成，它的内部有一个 <code>inputGatesWithData</code> 队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">UnionInputGate</span> <span class="nf">implements</span> <span class="n">InputGate</span><span class="p">,</span> <span class="n">InputGateListener</span> <span class="p">{</span>
	<span class="cm">/** The input gates to union. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">InputGate</span><span class="p">[]</span> <span class="nf">inputGates</span><span class="p">;</span>

	<span class="cm">/** Gates, which notified this input gate about available data. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">InputGate</span><span class="o">&gt;</span> <span class="nf">inputGatesWithData</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">getNextBufferOrEvent</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inputGatesWithRemainingData</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="c1">// Make sure to request the partitions, if they have not been requested before.
</span><span class="c1"></span>		<span class="n">requestPartitions</span><span class="p">();</span>

		<span class="n">InputGateWithData</span> <span class="nf">inputGateWithData</span> <span class="o">=</span> <span class="n">waitAndGetNextInputGate</span><span class="p">();</span>
		<span class="n">InputGate</span> <span class="nf">inputGate</span> <span class="o">=</span> <span class="n">inputGateWithData</span><span class="p">.</span><span class="na">inputGate</span><span class="p">;</span>
		<span class="n">BufferOrEvent</span> <span class="nf">bufferOrEvent</span> <span class="o">=</span> <span class="n">inputGateWithData</span><span class="p">.</span><span class="na">bufferOrEvent</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">moreAvailable</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//这个 InputGate 中还有更多的数据，继续加入队列
</span><span class="c1"></span>			<span class="c1">// this buffer or event was now removed from the non-empty gates queue
</span><span class="c1"></span>			<span class="c1">// we re-add it in case it has more data, because in that case no &#34;non-empty&#34; notification
</span><span class="c1"></span>			<span class="c1">// will come for that gate
</span><span class="c1"></span>			<span class="n">queueInputGate</span><span class="p">(</span><span class="n">inputGate</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">isEvent</span><span class="p">()</span>
			<span class="o">&amp;&amp;</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getEvent</span><span class="p">().</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">EndOfPartitionEvent</span><span class="p">.</span><span class="na">class</span>
			<span class="o">&amp;&amp;</span> <span class="n">inputGate</span><span class="p">.</span><span class="na">isFinished</span><span class="p">())</span> <span class="p">{</span>

			<span class="n">checkState</span><span class="p">(</span><span class="o">!</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">moreAvailable</span><span class="p">());</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inputGatesWithRemainingData</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">inputGate</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Couldn&#39;t find input gate in set of remaining &#34;</span> <span class="o">+</span>
					<span class="s">&#34;input gates.&#34;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Set the channel index to identify the input channel (across all unioned input gates)
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">int</span> <span class="n">channelIndexOffset</span> <span class="o">=</span> <span class="n">inputGateToIndexOffsetMap</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">inputGate</span><span class="p">);</span>

		<span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">setChannelIndex</span><span class="p">(</span><span class="n">channelIndexOffset</span> <span class="o">+</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getChannelIndex</span><span class="p">());</span>
		<span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">setMoreAvailable</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">moreAvailable</span><span class="p">()</span> <span class="o">||</span> <span class="n">inputGateWithData</span><span class="p">.</span><span class="na">moreInputGatesAvailable</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">InputGateWithData</span> <span class="n">waitAndGetNextInputGate</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">InputGate</span> <span class="nf">inputGate</span><span class="p">;</span>
			<span class="kt">boolean</span> <span class="nf">moreInputGatesAvailable</span><span class="p">;</span>
			<span class="kd">synchronized</span> <span class="p">(</span><span class="n">inputGatesWithData</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//等待 inputGatesWithData 队列，经典的生产者-消费者模型
</span><span class="c1"></span>				<span class="k">while</span> <span class="p">(</span><span class="n">inputGatesWithData</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">inputGatesWithData</span><span class="p">.</span><span class="na">wait</span><span class="p">();</span>
				<span class="p">}</span>
				<span class="n">inputGate</span> <span class="o">=</span> <span class="n">inputGatesWithData</span><span class="p">.</span><span class="na">remove</span><span class="p">();</span>
				<span class="n">enqueuedInputGatesWithData</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">inputGate</span><span class="p">);</span>
				<span class="n">moreInputGatesAvailable</span> <span class="o">=</span> <span class="n">enqueuedInputGatesWithData</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">// In case of inputGatesWithData being inaccurate do not block on an empty inputGate, but just poll the data.
</span><span class="c1"></span>			<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferOrEvent</span><span class="o">&gt;</span> <span class="nf">bufferOrEvent</span> <span class="o">=</span> <span class="n">inputGate</span><span class="p">.</span><span class="na">pollNextBufferOrEvent</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">isPresent</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">return</span> <span class="k">new</span> <span class="n">InputGateWithData</span><span class="p">(</span><span class="n">inputGate</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">get</span><span class="p">(),</span> <span class="n">moreInputGatesAvailable</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyInputGateNonEmpty</span><span class="p">(</span><span class="n">InputGate</span> <span class="nf">inputGate</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">queueInputGate</span><span class="p">(</span><span class="n">checkNotNull</span><span class="p">(</span><span class="n">inputGate</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>InputGate</code> 相当于是对 <code>InputChannel</code> 的一层封装，实际数据的获取还是要依赖于 <code>InputChannel</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">abstract</span> <span class="kd">class</span> <span class="nf">InputChannel</span> <span class="p">{</span>
	<span class="kd">protected</span> <span class="nf">final</span> <span class="kt">int</span> <span class="nf">channelIndex</span><span class="p">;</span>
	<span class="c1">//消费的目标 ResultPartitionID
</span><span class="c1"></span>	<span class="kd">protected</span> <span class="nf">final</span> <span class="n">ResultPartitionID</span> <span class="nf">partitionId</span><span class="p">;</span>

	<span class="kd">protected</span> <span class="nf">final</span> <span class="n">SingleInputGate</span> <span class="nf">inputGate</span><span class="p">;</span>

	<span class="c1">//回调函数，告知 InputGate 当前 channel 有数据
</span><span class="c1"></span>	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">notifyChannelNonEmpty</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">inputGate</span><span class="p">.</span><span class="na">notifyChannelNonEmpty</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//请求ResultSubpartition
</span><span class="c1"></span>	<span class="kd">abstract</span> <span class="nf">void</span> <span class="n">requestSubpartition</span><span class="p">(</span><span class="kt">int</span> <span class="nf">subpartitionIndex</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span><span class="p">;</span>

	<span class="kd">abstract</span> <span class="nf">Optional</span><span class="o">&lt;</span><span class="n">BufferAndAvailability</span><span class="o">&gt;</span> <span class="nf">getNextBuffer</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span><span class="p">;</span>

	<span class="kd">abstract</span> <span class="nf">void</span> <span class="n">sendTaskEvent</span><span class="p">(</span><span class="n">TaskEvent</span> <span class="nf">event</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">;</span>

	<span class="kd">abstract</span> <span class="nf">void</span> <span class="n">notifySubpartitionConsumed</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">;</span>

	<span class="kd">abstract</span> <span class="nf">void</span> <span class="n">releaseAllResources</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">;</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>InputChannel</code> 的基本逻辑也比较简单，它的生命周期按照 <code>requestSubpartition(int subpartitionIndex)</code>, <code>getNextBuffer()</code> 和 <code>releaseAllResources()</code> 这样的顺序进行。</p>

<p>根据 <code>InputChannel</code> 消费的 <code>ResultPartition</code> 的位置，<code>InputChannel</code> 有 <code>LocalInputChannel</code> 和 <code>RemoteInputChannel</code> 两中不同的实现，分别对应本地和远程数据交换。我们将在接下来两节分别进行分析。<code>InputChannel</code> 还有一个实现类是 <code>UnknownInputChannel</code>，相当于是还未确定 <code>ResultPartition</code> 位置的情况下的占位符，最终还是会更新为 <code>LocalInputChannel</code> 或是 <code>RemoteInputChannel</code>。</p>

<h3 id="本地数据交换">本地数据交换</h3>

<p>如果一个 <code>InputChannel</code> 和其消费的上游 <code>ResultPartition</code> 所属 Task 都在同一个 TaskManager 中运行，那么它们之间的数据交换就在同一个 JVM 进程内不同线程之间进行，无需通过网络交换。我们已经了解到，<code>ResultSubpartition</code> 中的 buffer 可以通过 <code>ResultSubpartitionView</code> 进行消费。<code>LocalInputChannel</code> 正是</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">LocalInputChannel</span> <span class="nf">extends</span> <span class="n">InputChannel</span> <span class="nf">implements</span> <span class="n">BufferAvailabilityListener</span> <span class="p">{</span>
	<span class="cm">/** The local partition manager. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ResultPartitionManager</span> <span class="nf">partitionManager</span><span class="p">;</span>
	<span class="cm">/** Task event dispatcher for backwards events. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">TaskEventPublisher</span> <span class="nf">taskEventPublisher</span><span class="p">;</span>
	<span class="cm">/** The consumed subpartition. */</span>
	<span class="kd">private</span> <span class="nf">volatile</span> <span class="n">ResultSubpartitionView</span> <span class="nf">subpartitionView</span><span class="p">;</span>

	<span class="c1">//请求消费对应的子分区
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kt">void</span> <span class="nf">requestSubpartition</span><span class="p">(</span><span class="kt">int</span> <span class="nf">subpartitionIndex</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="kt">boolean</span> <span class="nf">retriggerRequest</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
		<span class="c1">// The lock is required to request only once in the presence of retriggered requests.
</span><span class="c1"></span>		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">requestLock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">checkState</span><span class="p">(</span><span class="o">!</span><span class="n">isReleased</span><span class="p">,</span> <span class="s">&#34;LocalInputChannel has been released already&#34;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">subpartitionView</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">try</span> <span class="p">{</span>
					<span class="c1">//Local，无需网络通信，通过 ResultPartitionManager 创建一个 ResultSubpartitionView
</span><span class="c1"></span>					<span class="c1">//LocalInputChannel 实现了 BufferAvailabilityListener
</span><span class="c1"></span>					<span class="c1">//在有数据时会得到通知，notifyDataAvailable 会被调用，进而将当前 channel 加到 InputGate 的可用 Channel 队列中
</span><span class="c1"></span>					<span class="n">ResultSubpartitionView</span> <span class="nf">subpartitionView</span> <span class="o">=</span> <span class="n">partitionManager</span><span class="p">.</span><span class="na">createSubpartitionView</span><span class="p">(</span>
						<span class="n">partitionId</span><span class="p">,</span> <span class="n">subpartitionIndex</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">subpartitionView</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="p">(</span><span class="s">&#34;Error requesting subpartition.&#34;</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="c1">// make the subpartition view visible
</span><span class="c1"></span>					<span class="k">this</span><span class="p">.</span><span class="na">subpartitionView</span> <span class="o">=</span> <span class="n">subpartitionView</span><span class="p">;</span>

					<span class="c1">// check if the channel was released in the meantime
</span><span class="c1"></span>					<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">subpartitionView</span><span class="p">.</span><span class="na">releaseAllResources</span><span class="p">();</span>
						<span class="k">this</span><span class="p">.</span><span class="na">subpartitionView</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">PartitionNotFoundException</span> <span class="nf">notFound</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">increaseBackoff</span><span class="p">())</span> <span class="p">{</span>
						<span class="n">retriggerRequest</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="k">throw</span> <span class="n">notFound</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">// Do this outside of the lock scope as this might lead to a
</span><span class="c1"></span>		<span class="c1">// deadlock with a concurrent release of the channel via the
</span><span class="c1"></span>		<span class="c1">// input gate.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">retriggerRequest</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inputGate</span><span class="p">.</span><span class="na">retriggerPartitionRequest</span><span class="p">(</span><span class="n">partitionId</span><span class="p">.</span><span class="na">getPartitionId</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//读取数据，借助 ResultSubparitionView 消费 ResultSubparition 中的苏剧
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="n">Optional</span><span class="o">&lt;</span><span class="n">BufferAndAvailability</span><span class="o">&gt;</span> <span class="nf">getNextBuffer</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="n">checkError</span><span class="p">();</span>
		<span class="n">ResultSubpartitionView</span> <span class="nf">subpartitionView</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="na">subpartitionView</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">subpartitionView</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// There is a possible race condition between writing a EndOfPartitionEvent (1) and flushing (3) the Local
</span><span class="c1"></span>			<span class="c1">// channel on the sender side, and reading EndOfPartitionEvent (2) and processing flush notification (4). When
</span><span class="c1"></span>			<span class="c1">// they happen in that order (1 - 2 - 3 - 4), flush notification can re-enqueue LocalInputChannel after (or
</span><span class="c1"></span>			<span class="c1">// during) it was released during reading the EndOfPartitionEvent (2).
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="c1">// this can happen if the request for the partition was triggered asynchronously
</span><span class="c1"></span>			<span class="c1">// by the time trigger
</span><span class="c1"></span>			<span class="c1">// would be good to avoid that, by guaranteeing that the requestPartition() and
</span><span class="c1"></span>			<span class="c1">// getNextBuffer() always come from the same thread
</span><span class="c1"></span>			<span class="c1">// we could do that by letting the timer insert a special &#34;requesting channel&#34; into the input gate&#39;s queue
</span><span class="c1"></span>			<span class="n">subpartitionView</span> <span class="o">=</span> <span class="n">checkAndWaitForSubpartitionView</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="c1">//通过 ResultSubparitionView 获取
</span><span class="c1"></span>		<span class="n">BufferAndBacklog</span> <span class="nf">next</span> <span class="o">=</span> <span class="n">subpartitionView</span><span class="p">.</span><span class="na">getNextBuffer</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">subpartitionView</span><span class="p">.</span><span class="na">isReleased</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">CancelTaskException</span><span class="p">(</span><span class="s">&#34;Consumed partition &#34;</span> <span class="o">+</span> <span class="n">subpartitionView</span> <span class="o">+</span> <span class="s">&#34; has been released.&#34;</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">empty</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">numBytesIn</span><span class="p">.</span><span class="na">inc</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="na">buffer</span><span class="p">().</span><span class="na">getSizeUnsafe</span><span class="p">());</span>
		<span class="n">numBuffersIn</span><span class="p">.</span><span class="na">inc</span><span class="p">();</span>
		<span class="k">return</span> <span class="n">Optional</span><span class="p">.</span><span class="na">of</span><span class="p">(</span><span class="k">new</span> <span class="n">BufferAndAvailability</span><span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="na">buffer</span><span class="p">(),</span> <span class="n">next</span><span class="p">.</span><span class="na">isMoreAvailable</span><span class="p">(),</span> <span class="n">next</span><span class="p">.</span><span class="na">buffersInBacklog</span><span class="p">()));</span>
	<span class="p">}</span>


	<span class="c1">//回调，在 ResultSubparition 通知 ResultSubparitionView 有数据可供消费，
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyDataAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//LocalInputChannel 通知 InputGate
</span><span class="c1"></span>		<span class="n">notifyChannelNonEmpty</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kt">void</span> <span class="nf">sendTaskEvent</span><span class="p">(</span><span class="n">TaskEvent</span> <span class="nf">event</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="n">checkError</span><span class="p">();</span>
		<span class="n">checkState</span><span class="p">(</span><span class="n">subpartitionView</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">,</span> <span class="s">&#34;Tried to send task event to producer before requesting the subpartition.&#34;</span><span class="p">);</span>
		<span class="c1">//事件分发
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">taskEventPublisher</span><span class="p">.</span><span class="na">publish</span><span class="p">(</span><span class="n">partitionId</span><span class="p">,</span> <span class="n">event</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="p">(</span><span class="s">&#34;Error while publishing event &#34;</span> <span class="o">+</span> <span class="n">event</span> <span class="o">+</span> <span class="s">&#34; to producer. The producer could not be found.&#34;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>这里的逻辑相对比较简单，<code>LocalInputChannel</code> 实现了 <code>InputChannel</code> 接口，同时也实现了 <code>BufferAvailabilityListener</code> 接口。<code>LocalInputChannel</code> 通过 <code>ResultPartitionManager</code> 请求创建和指定 <code>ResultSubparition</code> 关联的 <code>ResultSubparitionView</code>，并以自身作为 <code>ResultSubparitionView</code> 的回调。这样，一旦 <code>ResultSubparition</code> 有数据产出时，<code>ResultSubparitionView</code> 会得到通知，同时 <code>LocalInputChannel</code> 的回调函数也会被调用，这样消费者这一端就可以及时获取到数据的生产情况，从而及时地去消费数据。</p>

<h3 id="通过网络进行数据交换">通过网络进行数据交换</h3>

<h4 id="网络栈">网络栈</h4>

<p>在 Flink 中，不同 Task 之间的网络传输基于 Netty 实现。<code>NetworkEnvironment</code> 中通过 <code>ConnectionManager</code> 来管理所有的网络的连接，而 <code>NettyConnectionManager</code> 就是 <code>ConnectionManager</code> 的具体实现。</p>

<p><code>NettyConnectionManager</code> 在启动的时候会创建并启动 <code>NettyClient</code> 和 <code>NettyServer</code>，<code>NettyServer</code> 会启动一个服务端监听，等待其它 <code>NettyClient</code> 的连接：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">NettyConnectionManager</span> <span class="nf">implements</span> <span class="n">ConnectionManager</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">NettyServer</span> <span class="nf">server</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">NettyClient</span> <span class="nf">client</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">NettyBufferPool</span> <span class="nf">bufferPool</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">PartitionRequestClientFactory</span> <span class="nf">partitionRequestClientFactory</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="kt">boolean</span> <span class="nf">isCreditBased</span><span class="p">;</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">start</span><span class="p">(</span><span class="n">ResultPartitionProvider</span> <span class="nf">partitionProvider</span><span class="p">,</span> <span class="n">TaskEventPublisher</span> <span class="nf">taskEventPublisher</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="n">NettyProtocol</span> <span class="nf">partitionRequestProtocol</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NettyProtocol</span><span class="p">(</span><span class="n">partitionProvider</span><span class="p">,</span> <span class="n">taskEventPublisher</span><span class="p">,</span> <span class="n">isCreditBased</span><span class="p">);</span>
		<span class="c1">//初始化 Netty Client
</span><span class="c1"></span>		<span class="n">client</span><span class="p">.</span><span class="na">init</span><span class="p">(</span><span class="n">partitionRequestProtocol</span><span class="p">,</span> <span class="n">bufferPool</span><span class="p">);</span>
		<span class="c1">//初始化并启动 Netty Server
</span><span class="c1"></span>		<span class="n">server</span><span class="p">.</span><span class="na">init</span><span class="p">(</span><span class="n">partitionRequestProtocol</span><span class="p">,</span> <span class="n">bufferPool</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>NettyProtocal</code> 中提供了 <code>NettyClient</code> 和 <code>NettyServer</code> 引导启动注册的一系列 Channel Handler，这些 Handler 的主要逻辑在后面再进行详细分析：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">NettyProtocol</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">ChannelHandler</span><span class="p">[]</span> <span class="n">getServerChannelHandlers</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//netty server 端的 ChannelHandler
</span><span class="c1"></span>		<span class="n">PartitionRequestQueue</span> <span class="nf">queueOfPartitionQueues</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PartitionRequestQueue</span><span class="p">();</span>
		<span class="n">PartitionRequestServerHandler</span> <span class="nf">serverHandler</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PartitionRequestServerHandler</span><span class="p">(</span>
			<span class="n">partitionProvider</span><span class="p">,</span> <span class="n">taskEventPublisher</span><span class="p">,</span> <span class="n">queueOfPartitionQueues</span><span class="p">,</span> <span class="n">creditBasedEnabled</span><span class="p">);</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">ChannelHandler</span><span class="p">[]</span> <span class="p">{</span>
			<span class="n">messageEncoder</span><span class="p">,</span>
			<span class="k">new</span> <span class="n">NettyMessage</span><span class="p">.</span><span class="na">NettyMessageDecoder</span><span class="p">(</span><span class="o">!</span><span class="n">creditBasedEnabled</span><span class="p">),</span>
			<span class="n">serverHandler</span><span class="p">,</span>
			<span class="n">queueOfPartitionQueues</span>
		<span class="p">};</span>
	<span class="p">}</span>

	<span class="kd">public</span> <span class="nf">ChannelHandler</span><span class="p">[]</span> <span class="n">getClientChannelHandlers</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//netty client 端的 ChannelHandler
</span><span class="c1"></span>		<span class="n">NetworkClientHandler</span> <span class="nf">networkClientHandler</span> <span class="o">=</span>
			<span class="n">creditBasedEnabled</span> <span class="o">?</span> <span class="k">new</span> <span class="n">CreditBasedPartitionRequestClientHandler</span><span class="p">()</span> <span class="o">:</span>
				<span class="k">new</span> <span class="n">PartitionRequestClientHandler</span><span class="p">();</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">ChannelHandler</span><span class="p">[]</span> <span class="p">{</span>
			<span class="n">messageEncoder</span><span class="p">,</span>
			<span class="k">new</span> <span class="n">NettyMessage</span><span class="p">.</span><span class="na">NettyMessageDecoder</span><span class="p">(</span><span class="o">!</span><span class="n">creditBasedEnabled</span><span class="p">),</span>
			<span class="n">networkClientHandler</span><span class="p">};</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>值得一提的是， <code>NettyServer</code> 在启动的时候会配置水位线，如果 Netty 输出缓冲中的字节数超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。通过水位线机制确保不往网络中写入太多数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">NettyServer</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kd">final</span> <span class="nf">NettyProtocol</span> <span class="n">protocol</span><span class="p">,</span> <span class="n">NettyBufferPool</span> <span class="nf">nettyBufferPool</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="p">......</span>

		<span class="kd">final</span> <span class="nf">int</span> <span class="n">newLowWaterMark</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="na">getMemorySegmentSize</span><span class="p">()</span> <span class="o">+</span> <span class="n">1</span><span class="p">;</span>
		<span class="kd">final</span> <span class="nf">int</span> <span class="n">newHighWaterMark</span> <span class="o">=</span> <span class="n">2</span> <span class="o">*</span> <span class="n">config</span><span class="p">.</span><span class="na">getMemorySegmentSize</span><span class="p">();</span>
		<span class="c1">//配置水位线，确保不往网络中写入太多数据
</span><span class="c1"></span>		<span class="c1">//当输出缓冲中的字节数超过高水位值, 则 Channel.isWritable() 会返回false
</span><span class="c1"></span>		<span class="c1">//当输出缓存中的字节数低于低水位值, 则 Channel.isWritable() 会重新返回true
</span><span class="c1"></span>		<span class="n">bootstrap</span><span class="p">.</span><span class="na">childOption</span><span class="p">(</span><span class="n">ChannelOption</span><span class="p">.</span><span class="na">WRITE_BUFFER_HIGH_WATER_MARK</span><span class="p">,</span> <span class="n">newHighWaterMark</span><span class="p">);</span>
		<span class="n">bootstrap</span><span class="p">.</span><span class="na">childOption</span><span class="p">(</span><span class="n">ChannelOption</span><span class="p">.</span><span class="na">WRITE_BUFFER_LOW_WATER_MARK</span><span class="p">,</span> <span class="n">newLowWaterMark</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>当 <code>RemoteInputChannel</code> 请求一个远端的 <code>ResultSubpartition</code> 的时候，<code>NettyClient</code> 就会发起和请求的 <code>ResultSubpartition</code> 所在 Task 的 <code>NettyServer</code> 的连接，后续所有的数据交换都在这个连接上进行。两个 Task 之间只会建立一个连接，这个连接会在不同的 <code>RemoteInputChannel</code> 和 <code>ResultSubpartition</code> 之间进行复用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">NettyConnectionManager</span> <span class="nf">implements</span> <span class="n">ConnectionManager</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">PartitionRequestClient</span> <span class="n">createPartitionRequestClient</span><span class="p">(</span><span class="n">ConnectionID</span> <span class="nf">connectionId</span><span class="p">)</span>
			<span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="c1">//这里实际上会建立和其它 Task 的 Server 的连接
</span><span class="c1"></span>		<span class="c1">//返回的 PartitionRequestClient 中封装了 netty channel 和 channel handler
</span><span class="c1"></span>		<span class="k">return</span> <span class="n">partitionRequestClientFactory</span><span class="p">.</span><span class="na">createPartitionRequestClient</span><span class="p">(</span><span class="n">connectionId</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nf">PartitionRequestClientFactory</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">NettyClient</span> <span class="nf">nettyClient</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">ConnectionID</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span> <span class="nf">clients</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;</span><span class="n">ConnectionID</span><span class="p">,</span> <span class="n">Object</span><span class="o">&gt;</span><span class="p">();</span>

	<span class="n">PartitionRequestClient</span> <span class="nf">createPartitionRequestClient</span><span class="p">(</span><span class="n">ConnectionID</span> <span class="nf">connectionId</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="n">Object</span> <span class="nf">entry</span><span class="p">;</span>
		<span class="n">PartitionRequestClient</span> <span class="nf">client</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">client</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">clients</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">connectionId</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//连接已经建立
</span><span class="c1"></span>				<span class="c1">// Existing channel or connecting channel
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="nf">instanceof</span> <span class="n">PartitionRequestClient</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">PartitionRequestClient</span><span class="p">)</span> <span class="n">entry</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">ConnectingChannel</span> <span class="nf">future</span> <span class="o">=</span> <span class="p">(</span><span class="n">ConnectingChannel</span><span class="p">)</span> <span class="n">entry</span><span class="p">;</span>
					<span class="n">client</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="na">waitForChannel</span><span class="p">();</span>
					<span class="n">clients</span><span class="p">.</span><span class="na">replace</span><span class="p">(</span><span class="n">connectionId</span><span class="p">,</span> <span class="n">future</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="c1">// No channel yet. Create one, but watch out for a race.
</span><span class="c1"></span>				<span class="c1">// We create a &#34;connecting future&#34; and atomically add it to the map.
</span><span class="c1"></span>				<span class="c1">// Only the thread that really added it establishes the channel.
</span><span class="c1"></span>				<span class="c1">// The others need to wait on that original establisher&#39;s future.
</span><span class="c1"></span>				<span class="c1">// 连接创建成功后会回调 handInChannel 方法
</span><span class="c1"></span>				<span class="n">ConnectingChannel</span> <span class="nf">connectingChannel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConnectingChannel</span><span class="p">(</span><span class="n">connectionId</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
				<span class="n">Object</span> <span class="nf">old</span> <span class="o">=</span> <span class="n">clients</span><span class="p">.</span><span class="na">putIfAbsent</span><span class="p">(</span><span class="n">connectionId</span><span class="p">,</span> <span class="n">connectingChannel</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">//连接到 Netty Server
</span><span class="c1"></span>					<span class="n">nettyClient</span><span class="p">.</span><span class="na">connect</span><span class="p">(</span><span class="n">connectionId</span><span class="p">.</span><span class="na">getAddress</span><span class="p">()).</span><span class="na">addListener</span><span class="p">(</span><span class="n">connectingChannel</span><span class="p">);</span>
					<span class="n">client</span> <span class="o">=</span> <span class="n">connectingChannel</span><span class="p">.</span><span class="na">waitForChannel</span><span class="p">();</span>
					<span class="n">clients</span><span class="p">.</span><span class="na">replace</span><span class="p">(</span><span class="n">connectionId</span><span class="p">,</span> <span class="n">connectingChannel</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="nf">instanceof</span> <span class="n">ConnectingChannel</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">client</span> <span class="o">=</span> <span class="p">((</span><span class="n">ConnectingChannel</span><span class="p">)</span> <span class="n">old</span><span class="p">).</span><span class="na">waitForChannel</span><span class="p">();</span>
					<span class="n">clients</span><span class="p">.</span><span class="na">replace</span><span class="p">(</span><span class="n">connectionId</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">client</span> <span class="o">=</span> <span class="p">(</span><span class="n">PartitionRequestClient</span><span class="p">)</span> <span class="n">old</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="c1">// Make sure to increment the reference count before handing a client
</span><span class="c1"></span>			<span class="c1">// out to ensure correct bookkeeping for channel closing.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">client</span><span class="p">.</span><span class="na">incrementReferenceCounter</span><span class="p">())</span> <span class="p">{</span>
				<span class="n">destroyPartitionRequestClient</span><span class="p">(</span><span class="n">connectionId</span><span class="p">,</span> <span class="n">client</span><span class="p">);</span>
				<span class="n">client</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">client</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>另外，Flink Buffer 的实现类 <code>NetworkBuffer</code> 直接继承了 Netty 的 <code>AbstractReferenceCountedByteBuf</code>，这样使得 Netty 可以直接使用 Flink 的 Buffer，从而避免了在 Flink Buffers 和 Netty Buffers 之间的数据拷贝：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">NetworkBuffer</span> <span class="nf">extends</span> <span class="n">AbstractReferenceCountedByteBuf</span> <span class="nf">implements</span> <span class="n">Buffer</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">MemorySegment</span> <span class="nf">memorySegment</span><span class="p">;</span>
	<span class="c1">//......
</span><span class="c1"></span>
	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">deallocate</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//回收当前buffer， LocalBufferPool 实现了 BufferRecycler 接口
</span><span class="c1"></span>		<span class="n">recycler</span><span class="p">.</span><span class="na">recycle</span><span class="p">(</span><span class="n">memorySegment</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h4 id="流量控制">流量控制</h4>

<p>Flink 在两个 Task 之间建立 Netty 连接进行数据传输，每一个 Task 会分配两个缓冲池，一个用于输出数据，一个用于接收数据。当一个 Task 的缓冲池用尽之后，网络连接就处于阻塞状态，上游 Task 无法产出数据，下游 Task 无法接收数据，也就是我们所说的“反压”状态。这是一种非常自然的“反压”的机制，但是过程也相对比较粗暴。由于 TaskManager 之间的网络连接是由不同 Task 复用的，一旦网络处于阻塞状态，所有 Task 都无法向 TCP 连接中写入数据或者从中读取数据，即便其它 Task 关联的缓冲池仍然存在空余。此外，由于网络发生了阻塞，诸如 <code>CheckpointBarrier</code> 等事件也无法在 Task 之间进行流转。</p>

<p>为了解决上述问题，Flink 1.5 重构了网络栈，引入了“基于信用值的流量控制算法”（Credit-based Flow Control），确保 TaskManager 之间的网络连接始终不会处于阻塞状态。Credit-based Flow Control 的思路其实也比较简单，它是在接收端和发送端之间建立一种类似“信用评级”的机制，发送端向接收端发送的数据永远不会超过接收端的信用值的大小。在 Flink 这里，信用值就是接收端可用的 Buffer 的数量，这样就可以保证发送端不会向 TCP 连接中发送超出接收端缓冲区可用容量的数据。</p>

<p>相比于之前所有的 InputChannel 共享同一个本地缓冲池的方式，在重构网络栈之后，Flink 会为每一个 InputChannel 分配一批独占的缓冲（exclusive buffers），而本地缓冲池中的 buffer 则作为流动的（floating buffers），可以被所有的 InputChannel 使用。</p>

<p>Credit-based Flow Control 的具体机制为：</p>

<ul>
<li>接收端向发送端声明可用的 Credit（一个可用的 buffer 对应一点 credit）；</li>
<li>当发送端获得了 X 点 Credit，表明它可以向网络中发送 X 个 buffer；当接收端分配了 X 点 Credit 给发送端，表明它有 X 个空闲的 buffer 可以接收数据；</li>
<li>只有在 Credit &gt; 0 的情况下发送端才发送 buffer；发送端每发送一个 buffer，Credit 也相应地减少一点</li>
<li>由于 <code>CheckpointBarrier</code>，<code>EndOfPartitionEvent</code> 等事件可以被立即处理，因而事件可以立即发送，无需使用 Credit</li>
<li>当发送端发送 buffer 的时候，它同样把当前堆积的 buffer 数量（backlog size）告知接收端；接收端根据发送端堆积的数量来申请 floating buffer</li>
</ul>

<p>这种流量控制机制可以有效地改善网络的利用率，不会因为 buffer 长时间停留在网络链路中进而导致整个所有的 Task 都无法继续处理数据，也无法进行 Checkpoint 操作。但是它的一个潜在的缺点是增加了上下游之间的通信成本（需要发送 credit 和 backlog 信息）。在目前的版本中可以通过 <code>taskmanager.network.credit-model: false</code> 来禁用，但后续应该会移除这个配置项。</p>

<h4 id="具体实现">具体实现</h4>

<p>在了解了 Flink 的网络栈和流量控制机制后，下面我们就来具体看一下 Flink 是如何在不同 Task 之间通过网络进行数据交换的。</p>

<h5 id="初始化">初始化</h5>

<p>首先，在向 <code>NetworkEnvironment</code> 注册的时候，会为 <code>InputGate</code> 分配本地缓冲池，还会为 <code>RemoteInputChannel</code> 分配独占的 buffer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">NetworkEnvironment</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">setupInputGate</span><span class="p">(</span><span class="n">SingleInputGate</span> <span class="nf">gate</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="n">BufferPool</span> <span class="nf">bufferPool</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="kt">int</span> <span class="nf">maxNumberOfMemorySegments</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">config</span><span class="p">.</span><span class="na">isCreditBased</span><span class="p">())</span> <span class="p">{</span> <span class="c1">//使用 Credit-based Flow Control
</span><span class="c1"></span>				<span class="c1">//本地缓冲池使用的 buffer 数量，如果是 bounded，则缓冲池的大小最大为 taskmanager.network.memory.floating-buffers-per-gate
</span><span class="c1"></span>				<span class="n">maxNumberOfMemorySegments</span> <span class="o">=</span> <span class="n">gate</span><span class="p">.</span><span class="na">getConsumedPartitionType</span><span class="p">().</span><span class="na">isBounded</span><span class="p">()</span> <span class="o">?</span>
					<span class="n">config</span><span class="p">.</span><span class="na">floatingNetworkBuffersPerGate</span><span class="p">()</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span>

				<span class="c1">// assign exclusive buffers to input channels directly and use the rest for floating buffers
</span><span class="c1"></span>				<span class="c1">// 独占的buffer，不包含在分配的 LocalBufferPool 中
</span><span class="c1"></span>				<span class="n">gate</span><span class="p">.</span><span class="na">assignExclusiveSegments</span><span class="p">(</span><span class="n">networkBufferPool</span><span class="p">,</span> <span class="n">config</span><span class="p">.</span><span class="na">networkBuffersPerChannel</span><span class="p">());</span>
				<span class="n">bufferPool</span> <span class="o">=</span> <span class="n">networkBufferPool</span><span class="p">.</span><span class="na">createBufferPool</span><span class="p">(</span><span class="n">0</span><span class="p">,</span> <span class="n">maxNumberOfMemorySegments</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">maxNumberOfMemorySegments</span> <span class="o">=</span> <span class="n">gate</span><span class="p">.</span><span class="na">getConsumedPartitionType</span><span class="p">().</span><span class="na">isBounded</span><span class="p">()</span> <span class="o">?</span>
					<span class="n">gate</span><span class="p">.</span><span class="na">getNumberOfInputChannels</span><span class="p">()</span> <span class="o">*</span> <span class="n">config</span><span class="p">.</span><span class="na">networkBuffersPerChannel</span><span class="p">()</span> <span class="o">+</span>
						<span class="n">config</span><span class="p">.</span><span class="na">floatingNetworkBuffersPerGate</span><span class="p">()</span> <span class="o">:</span> <span class="n">Integer</span><span class="p">.</span><span class="na">MAX_VALUE</span><span class="p">;</span>

				<span class="n">bufferPool</span> <span class="o">=</span> <span class="n">networkBufferPool</span><span class="p">.</span><span class="na">createBufferPool</span><span class="p">(</span><span class="n">gate</span><span class="p">.</span><span class="na">getNumberOfInputChannels</span><span class="p">(),</span>
					<span class="n">maxNumberOfMemorySegments</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="c1">//分配 LocalBufferPool 本地缓冲池，这是所有 channel 共享的
</span><span class="c1"></span>			<span class="n">gate</span><span class="p">.</span><span class="na">setBufferPool</span><span class="p">(</span><span class="n">bufferPool</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bufferPool</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bufferPool</span><span class="p">.</span><span class="na">lazyDestroy</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">ExceptionUtils</span><span class="p">.</span><span class="na">rethrowIOException</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nf">SingleInputGate</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">assignExclusiveSegments</span><span class="p">(</span><span class="n">NetworkBufferPool</span> <span class="nf">networkBufferPool</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">networkBuffersPerChannel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="n">checkState</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">isCreditBased</span><span class="p">,</span> <span class="s">&#34;Bug in input gate setup logic: exclusive buffers only exist with credit-based flow control.&#34;</span><span class="p">);</span>
		<span class="n">checkState</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="na">networkBufferPool</span> <span class="o">==</span> <span class="kc">null</span><span class="p">,</span> <span class="s">&#34;Bug in input gate setup logic: global buffer pool has&#34;</span> <span class="o">+</span>
			<span class="s">&#34;already been set for this input gate.&#34;</span><span class="p">);</span>

		<span class="k">this</span><span class="p">.</span><span class="na">networkBufferPool</span> <span class="o">=</span> <span class="n">checkNotNull</span><span class="p">(</span><span class="n">networkBufferPool</span><span class="p">);</span>
		<span class="k">this</span><span class="p">.</span><span class="na">networkBuffersPerChannel</span> <span class="o">=</span> <span class="n">networkBuffersPerChannel</span><span class="p">;</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">requestLock</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">InputChannel</span> <span class="nf">inputChannel</span> <span class="o">:</span> <span class="n">inputChannels</span><span class="p">.</span><span class="na">values</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inputChannel</span> <span class="nf">instanceof</span> <span class="n">RemoteInputChannel</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">//RemoteInputChannel 请求独占的 buffer
</span><span class="c1"></span>					<span class="p">((</span><span class="n">RemoteInputChannel</span><span class="p">)</span> <span class="n">inputChannel</span><span class="p">).</span><span class="na">assignExclusiveSegments</span><span class="p">(</span>
						<span class="n">networkBufferPool</span><span class="p">.</span><span class="na">requestMemorySegments</span><span class="p">(</span><span class="n">networkBuffersPerChannel</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h5 id="remoteinputchannel-管理可用-buffer">RemoteInputChannel 管理可用 buffer</h5>

<p>在 <code>RemoteInputChannel</code> 内部使用 <code>AvailableBufferQueue</code> 来管理所有可用的 buffer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">RemoteInputChannel</span> <span class="kd">extends</span> <span class="nf">InputChannel</span> <span class="kd">implements</span> <span class="nf">BufferRecycler</span><span class="p">,</span> <span class="n">BufferListener</span> <span class="p">{</span>
	<span class="c1">//可用的 buffer 队列，包含 exclusive + floating
</span><span class="c1"></span>	<span class="cm">/** The available buffer queue wraps both exclusive and requested floating buffers. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">AvailableBufferQueue</span> <span class="nf">bufferQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AvailableBufferQueue</span><span class="p">();</span>

	<span class="c1">//分配独占的 buffer
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">assignExclusiveSegments</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">MemorySegment</span><span class="o">&gt;</span> <span class="nf">segments</span><span class="p">)</span> <span class="p">{</span>

		<span class="k">this</span><span class="p">.</span><span class="na">initialCredit</span> <span class="o">=</span> <span class="n">segments</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
		<span class="k">this</span><span class="p">.</span><span class="na">numRequiredBuffers</span> <span class="o">=</span> <span class="n">segments</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">bufferQueue</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">MemorySegment</span> <span class="nf">segment</span> <span class="o">:</span> <span class="n">segments</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//注意这个 NetworkBuffer 的回收器是 RemoteInputChannel 自身
</span><span class="c1"></span>				<span class="n">bufferQueue</span><span class="p">.</span><span class="na">addExclusiveBuffer</span><span class="p">(</span><span class="k">new</span> <span class="n">NetworkBuffer</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="n">numRequiredBuffers</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//独占的 buffer 释放后会直接被 RemoteInputChannel 回收
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">recycle</span><span class="p">(</span><span class="n">MemorySegment</span> <span class="nf">segment</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="nf">numAddedBuffers</span><span class="p">;</span>
		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">bufferQueue</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Similar to notifyBufferAvailable(), make sure that we never add a buffer
</span><span class="c1"></span>			<span class="c1">// after releaseAllResources() released all buffers (see below for details).
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">.</span><span class="na">get</span><span class="p">())</span> <span class="p">{</span>
				<span class="c1">//如果这个 channle 已经被释放
</span><span class="c1"></span>				<span class="k">try</span> <span class="p">{</span>
					<span class="c1">//这个 MemorySegment 会被归还给 NetworkBufferPool
</span><span class="c1"></span>					<span class="n">inputGate</span><span class="p">.</span><span class="na">returnExclusiveSegments</span><span class="p">(</span><span class="n">Collections</span><span class="p">.</span><span class="na">singletonList</span><span class="p">(</span><span class="n">segment</span><span class="p">));</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ExceptionUtils</span><span class="p">.</span><span class="na">rethrow</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="c1">//重新加入到 AvailableBufferQueue 中
</span><span class="c1"></span>			<span class="n">numAddedBuffers</span> <span class="o">=</span> <span class="n">bufferQueue</span><span class="p">.</span><span class="na">addExclusiveBuffer</span><span class="p">(</span><span class="k">new</span> <span class="n">NetworkBuffer</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="k">this</span><span class="p">),</span> <span class="n">numRequiredBuffers</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">numAddedBuffers</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">unannouncedCredit</span><span class="p">.</span><span class="na">getAndAdd</span><span class="p">(</span><span class="n">numAddedBuffers</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">notifyCreditAvailable</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>


	<span class="cm">/**
</span><span class="cm">	 * Manages the exclusive and floating buffers of this channel, and handles the
</span><span class="cm">	 * internal buffer related logic.
</span><span class="cm">	 */</span>
	<span class="kd">private</span> <span class="nf">static</span> <span class="kd">class</span> <span class="nf">AvailableBufferQueue</span> <span class="p">{</span>
		<span class="c1">//这部分是流动的
</span><span class="c1"></span>		<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">Buffer</span><span class="o">&gt;</span> <span class="nf">floatingBuffers</span><span class="p">;</span>

		<span class="c1">//这部分是独占的
</span><span class="c1"></span>		<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">Buffer</span><span class="o">&gt;</span> <span class="nf">exclusiveBuffers</span><span class="p">;</span>

		<span class="n">AvailableBufferQueue</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">this</span><span class="p">.</span><span class="na">exclusiveBuffers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>
			<span class="k">this</span><span class="p">.</span><span class="na">floatingBuffers</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>
		<span class="p">}</span>

		<span class="c1">//添加一个独占的buffer，如果当前可用的 buffer 总量超出了要求的数量，则向本地缓冲池归还一个流动的buffer
</span><span class="c1"></span>		<span class="c1">//返回值是新增的 buffer 数量
</span><span class="c1"></span>		<span class="kt">int</span> <span class="nf">addExclusiveBuffer</span><span class="p">(</span><span class="n">Buffer</span> <span class="nf">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">numRequiredBuffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">exclusiveBuffers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">getAvailableBufferSize</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">numRequiredBuffers</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">Buffer</span> <span class="nf">floatingBuffer</span> <span class="o">=</span> <span class="n">floatingBuffers</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
				<span class="n">floatingBuffer</span><span class="p">.</span><span class="na">recycleBuffer</span><span class="p">();</span>
				<span class="c1">//加一个，归还一个，相当于没加
</span><span class="c1"></span>				<span class="k">return</span> <span class="n">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="c1">//添加一个流动的buffer
</span><span class="c1"></span>		<span class="kt">void</span> <span class="nf">addFloatingBuffer</span><span class="p">(</span><span class="n">Buffer</span> <span class="nf">buffer</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">floatingBuffers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="c1">//优先取流动的buffer
</span><span class="c1"></span>		<span class="nd">@Nullable</span>
		<span class="n">Buffer</span> <span class="nf">takeBuffer</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">floatingBuffers</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">floatingBuffers</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">return</span> <span class="n">exclusiveBuffers</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="kt">int</span> <span class="nf">getAvailableBufferSize</span><span class="p">()</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">floatingBuffers</span><span class="p">.</span><span class="na">size</span><span class="p">()</span> <span class="o">+</span> <span class="n">exclusiveBuffers</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h5 id="请求远端子分区">请求远端子分区</h5>

<p><code>RemoteInputChannel</code> 请求远端的 <code>ResultSubpartition</code>，会创建一个 <code>PartitionRequestClient</code>，并通过 Netty 发送 <code>PartitionRequest</code> 请求，这时会带上当前 InputChannel 的 id 和初始的 credit 信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">RemoteInputChannel</span> <span class="kd">extends</span> <span class="nf">InputChannel</span> <span class="kd">implements</span> <span class="nf">BufferRecycler</span><span class="p">,</span> <span class="n">BufferListener</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">requestSubpartition</span><span class="p">(</span><span class="kt">int</span> <span class="nf">subpartitionIndex</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="c1">//REMOTE，需要网络通信，使用 Netty 建立网络
</span><span class="c1"></span>		<span class="c1">//通过 ConnectionManager 来建立连接：创建 PartitionRequestClient，通过 PartitionRequestClient 发起请求
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">partitionRequestClient</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Create a client and request the partition
</span><span class="c1"></span>			<span class="n">partitionRequestClient</span> <span class="o">=</span> <span class="n">connectionManager</span>
				<span class="p">.</span><span class="na">createPartitionRequestClient</span><span class="p">(</span><span class="n">connectionId</span><span class="p">);</span>

			<span class="c1">//请求分区，通过 netty 发起请求
</span><span class="c1"></span>			<span class="n">partitionRequestClient</span><span class="p">.</span><span class="na">requestSubpartition</span><span class="p">(</span><span class="n">partitionId</span><span class="p">,</span> <span class="n">subpartitionIndex</span><span class="p">,</span> <span class="k">this</span><span class="p">,</span> <span class="n">0</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="nf">class</span> <span class="n">PartitionRequestClient</span> <span class="p">{</span>
	<span class="kd">public</span> <span class="nf">ChannelFuture</span> <span class="n">requestSubpartition</span><span class="p">(</span>
			<span class="kd">final</span> <span class="nf">ResultPartitionID</span> <span class="n">partitionId</span><span class="p">,</span>
			<span class="kd">final</span> <span class="nf">int</span> <span class="n">subpartitionIndex</span><span class="p">,</span>
			<span class="kd">final</span> <span class="nf">RemoteInputChannel</span> <span class="n">inputChannel</span><span class="p">,</span>
			<span class="kt">int</span> <span class="nf">delayMs</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="c1">//向 NetworkClientHandler 注册当前 RemoteInputChannel
</span><span class="c1"></span>		<span class="c1">//单个 Task 所有的 RemoteInputChannel 的数据传输都通过这个 PartitionRequestClient 处理
</span><span class="c1"></span>		<span class="n">clientHandler</span><span class="p">.</span><span class="na">addInputChannel</span><span class="p">(</span><span class="n">inputChannel</span><span class="p">);</span>

		<span class="c1">//PartitionRequest封装了请求的 sub-partition 的信息，当前 input channel 的 ID，以及初始 credit
</span><span class="c1"></span>		<span class="kd">final</span> <span class="nf">PartitionRequest</span> <span class="n">request</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PartitionRequest</span><span class="p">(</span>
				<span class="n">partitionId</span><span class="p">,</span> <span class="n">subpartitionIndex</span><span class="p">,</span> <span class="n">inputChannel</span><span class="p">.</span><span class="na">getInputChannelId</span><span class="p">(),</span> <span class="n">inputChannel</span><span class="p">.</span><span class="na">getInitialCredit</span><span class="p">());</span>

		<span class="kd">final</span> <span class="nf">ChannelFutureListener</span> <span class="n">listener</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChannelFutureListener</span><span class="p">()</span> <span class="p">{</span>
			<span class="nd">@Override</span>
			<span class="kd">public</span> <span class="nf">void</span> <span class="n">operationComplete</span><span class="p">(</span><span class="n">ChannelFuture</span> <span class="nf">future</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">future</span><span class="p">.</span><span class="na">isSuccess</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//如果请求发送失败，要移除当前的 inputChannel
</span><span class="c1"></span>					<span class="n">clientHandler</span><span class="p">.</span><span class="na">removeInputChannel</span><span class="p">(</span><span class="n">inputChannel</span><span class="p">);</span>
					<span class="n">SocketAddress</span> <span class="nf">remoteAddr</span> <span class="o">=</span> <span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">().</span><span class="na">remoteAddress</span><span class="p">();</span>
					<span class="n">inputChannel</span><span class="p">.</span><span class="na">onError</span><span class="p">(</span>
							<span class="k">new</span> <span class="n">LocalTransportException</span><span class="p">(</span>
								<span class="n">String</span><span class="p">.</span><span class="na">format</span><span class="p">(</span><span class="s">&#34;Sending the partition request to &#39;%s&#39; failed.&#34;</span><span class="p">,</span> <span class="n">remoteAddr</span><span class="p">),</span>
								<span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">().</span><span class="na">localAddress</span><span class="p">(),</span> <span class="n">future</span><span class="p">.</span><span class="na">cause</span><span class="p">()</span>
							<span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">};</span>

		<span class="c1">//通过 netty 发送请求
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">delayMs</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ChannelFuture</span> <span class="nf">f</span> <span class="o">=</span> <span class="n">tcpChannel</span><span class="p">.</span><span class="na">writeAndFlush</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
			<span class="n">f</span><span class="p">.</span><span class="na">addListener</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="kd">final</span> <span class="nf">ChannelFuture</span><span class="p">[]</span> <span class="n">f</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ChannelFuture</span><span class="p">[</span><span class="n">1</span><span class="p">];</span>
			<span class="n">tcpChannel</span><span class="p">.</span><span class="na">eventLoop</span><span class="p">().</span><span class="na">schedule</span><span class="p">(</span><span class="k">new</span> <span class="n">Runnable</span><span class="p">()</span> <span class="p">{</span>
				<span class="nd">@Override</span>
				<span class="kd">public</span> <span class="nf">void</span> <span class="n">run</span><span class="p">()</span> <span class="p">{</span>
					<span class="n">f</span><span class="p">[</span><span class="n">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">tcpChannel</span><span class="p">.</span><span class="na">writeAndFlush</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>
					<span class="n">f</span><span class="p">[</span><span class="n">0</span><span class="p">].</span><span class="na">addListener</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">},</span> <span class="n">delayMs</span><span class="p">,</span> <span class="n">TimeUnit</span><span class="p">.</span><span class="na">MILLISECONDS</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">f</span><span class="p">[</span><span class="n">0</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h5 id="生产端的处理流程">生产端的处理流程</h5>

<p>生产者端即 <code>ResultSubpartition</code> 一侧，在网络通信中对应 <code>NettyServer</code>。<code>NettyServer</code> 有两个重要的 <code>ChannelHandler</code>，即 <code>PartitionRequestServerHandler</code> 和 <code>PartitionRequestQueue</code>。其中，<code>PartitionRequestServerHandler</code> 负责处理消费端通过 <code>PartitionRequestClient</code> 发送的 <code>PartitionRequest</code> 和 <code>AddCredit</code> 等请求；<code>PartitionRequestQueue</code> 则包含了一个可以从中读取数据的 <code>NetworkSequenceViewReader</code> 队列，它会监听 Netty Channel 的可写入状态，一旦可以写入数据，就会从 <code>NetworkSequenceViewReader</code> 消费数据写入 Netty Channel。</p>

<p>首先，当 <code>NettyServer</code> 接收到 <code>PartitionRequest</code> 消息后，<code>PartitionRequestServerHandler</code> 会创建一个 <code>NetworkSequenceViewReader</code> 对象，请求创建 <code>ResultSubpartitionView</code>, 并将 <code>NetworkSequenceViewReader</code> 保存在 <code>PartitionRequestQueue</code> 中。<code>PartitionRequestQueue</code> 会持有所有请求消费数据的 <code>RemoteInputChannel</code> 的 ID 和 <code>NetworkSequenceViewReader</code> 之间的映射关系。</p>

<p>我们已经知道，<code>ResultSubpartitionView</code> 用来消费 <code>ResultSubpartition</code> 中的数据，并在 <code>ResultSubpartition</code> 中有数据可用时获得提醒；<code>NetworkSequenceViewReader</code> 则相当于对 <code>ResultSubpartition</code> 的一层包装，她会按顺序为读取的每一个 buffer 分配一个序列号，并且记录了接收数据的 <code>RemoteInputChannel</code> 的 ID。在使用 Credit-based Flow Control 的情况下，<code>NetworkSequenceViewReader</code> 的具体实现对应为 <code>CreditBasedSequenceNumberingViewReader</code>。 <code>CreditBasedSequenceNumberingViewReader</code> 同时还实现了 <code>BufferAvailabilityListener</code> 接口，因而可以作为 <code>PipelinedSubpartitionView</code> 的回调对象。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">PartitionRequestServerHandler</span> <span class="kd">extends</span> <span class="nf">SimpleChannelInboundHandler</span><span class="o">&lt;</span><span class="n">NettyMessage</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">channelRead0</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">,</span> <span class="n">NettyMessage</span> <span class="nf">msg</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="n">Class</span><span class="o">&lt;?&gt;</span> <span class="n">msgClazz</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="na">getClass</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">msgClazz</span> <span class="o">==</span> <span class="n">PartitionRequest</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//Server 端接收到 client 发送的 PartitionRequest
</span><span class="c1"></span>				<span class="n">PartitionRequest</span> <span class="nf">request</span> <span class="o">=</span> <span class="p">(</span><span class="n">PartitionRequest</span><span class="p">)</span> <span class="n">msg</span><span class="p">;</span>
				<span class="k">try</span> <span class="p">{</span>
					<span class="n">NetworkSequenceViewReader</span> <span class="nf">reader</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">creditBasedEnabled</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">CreditBasedSequenceNumberingViewReader</span><span class="p">(</span>
							<span class="n">request</span><span class="p">.</span><span class="na">receiverId</span><span class="p">,</span>
							<span class="n">request</span><span class="p">.</span><span class="na">credit</span><span class="p">,</span>
							<span class="n">outboundQueue</span><span class="p">);</span>
					<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
						<span class="n">reader</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SequenceNumberingViewReader</span><span class="p">(</span>
							<span class="n">request</span><span class="p">.</span><span class="na">receiverId</span><span class="p">,</span>
							<span class="n">outboundQueue</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="c1">//通过 ResultPartitionProvider（实际上就是 ResultPartitionManager）创建 ResultSubpartitionView
</span><span class="c1"></span>					<span class="c1">//在有可被消费的数据产生后，PartitionRequestQueue.notifyReaderNonEmpty 会被回调，进而在 netty channelPipeline 上触发一次 fireUserEventTriggered
</span><span class="c1"></span>					<span class="n">reader</span><span class="p">.</span><span class="na">requestSubpartitionView</span><span class="p">(</span>
						<span class="n">partitionProvider</span><span class="p">,</span>
						<span class="n">request</span><span class="p">.</span><span class="na">partitionId</span><span class="p">,</span>
						<span class="n">request</span><span class="p">.</span><span class="na">queueIndex</span><span class="p">);</span>

					<span class="c1">//通知 PartitionRequestQueue 创建了一个 NetworkSequenceViewReader
</span><span class="c1"></span>					<span class="n">outboundQueue</span><span class="p">.</span><span class="na">notifyReaderCreated</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">PartitionNotFoundException</span> <span class="nf">notFound</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">respondWithError</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">notFound</span><span class="p">,</span> <span class="n">request</span><span class="p">.</span><span class="na">receiverId</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="p">......</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">respondWithError</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>


<span class="kd">class</span> <span class="nf">CreditBasedSequenceNumberingViewReader</span> <span class="kd">implements</span> <span class="nf">BufferAvailabilityListener</span><span class="p">,</span> <span class="n">NetworkSequenceViewReader</span> <span class="p">{</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">InputChannelID</span> <span class="nf">receiverId</span><span class="p">;</span> <span class="c1">//对应的 RemoteInputChannel 的 ID
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">final</span> <span class="n">PartitionRequestQueue</span> <span class="nf">requestQueue</span><span class="p">;</span>
	<span class="c1">//消费 ResultSubpartition 的数据，并在 ResultSubpartition 有数据可用时获得通知
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">volatile</span> <span class="n">ResultSubpartitionView</span> <span class="nf">subpartitionView</span><span class="p">;</span>
	<span class="c1">//numCreditsAvailable的值是消费端还能够容纳的buffer的数量，也就是允许生产端发送的buffer的数量
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">int</span> <span class="n">numCreditsAvailable</span><span class="p">;</span>
	<span class="kd">private</span> <span class="nf">int</span> <span class="n">sequenceNumber</span> <span class="o">=</span> <span class="o">-</span><span class="n">1</span><span class="p">;</span> <span class="c1">//序列号，自增
</span><span class="c1"></span>
	<span class="c1">//创建一个 ResultSubpartitionView，用于读取数据，并在有数据可用时获得通知
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">requestSubpartitionView</span><span class="p">(</span>
		<span class="n">ResultPartitionProvider</span> <span class="nf">partitionProvider</span><span class="p">,</span>
		<span class="n">ResultPartitionID</span> <span class="nf">resultPartitionId</span><span class="p">,</span>
		<span class="kt">int</span> <span class="nf">subPartitionIndex</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">requestLock</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">subpartitionView</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">this</span><span class="p">.</span><span class="na">subpartitionView</span> <span class="o">=</span> <span class="n">partitionProvider</span><span class="p">.</span><span class="na">createSubpartitionView</span><span class="p">(</span>
					<span class="n">resultPartitionId</span><span class="p">,</span>
					<span class="n">subPartitionIndex</span><span class="p">,</span>
					<span class="k">this</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Subpartition already requested&#34;</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//读取数据
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">BufferAndAvailability</span> <span class="n">getNextBuffer</span><span class="p">()</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">,</span> <span class="n">InterruptedException</span> <span class="p">{</span>
		<span class="n">BufferAndBacklog</span> <span class="nf">next</span> <span class="o">=</span> <span class="n">subpartitionView</span><span class="p">.</span><span class="na">getNextBuffer</span><span class="p">();</span> <span class="c1">//读取数据
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sequenceNumber</span><span class="o">++</span><span class="p">;</span> <span class="c1">//序列号
</span><span class="c1"></span>			<span class="c1">//要发送一个buffer，对应的 numCreditsAvailable 要减 1
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="na">buffer</span><span class="p">().</span><span class="na">isBuffer</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">--</span><span class="n">numCreditsAvailable</span> <span class="o">&lt;</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;no credit available&#34;</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="k">new</span> <span class="n">BufferAndAvailability</span><span class="p">(</span>
				<span class="n">next</span><span class="p">.</span><span class="na">buffer</span><span class="p">(),</span> <span class="n">isAvailable</span><span class="p">(</span><span class="n">next</span><span class="p">),</span> <span class="n">next</span><span class="p">.</span><span class="na">buffersInBacklog</span><span class="p">());</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//是否还可以消费数据：
</span><span class="c1"></span>	<span class="c1">// 1. ResultSubpartition 中有更多的数据
</span><span class="c1"></span>	<span class="c1">// 2. credit &gt; 0 或者下一条数据是事件(事件不需要消耗credit)
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">boolean</span> <span class="n">isAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">// BEWARE: this must be in sync with #isAvailable(BufferAndBacklog)!
</span><span class="c1"></span>		<span class="k">return</span> <span class="n">hasBuffersAvailable</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
			<span class="c1">//要求 numCreditsAvailable &gt; 0 或者是 Event
</span><span class="c1"></span>			<span class="p">(</span><span class="n">numCreditsAvailable</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">subpartitionView</span><span class="p">.</span><span class="na">nextBufferIsEvent</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="kt">boolean</span> <span class="nf">hasBuffersAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">subpartitionView</span><span class="p">.</span><span class="na">isAvailable</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="c1">//和上面 isAvailable() 是等价的
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">boolean</span> <span class="n">isAvailable</span><span class="p">(</span><span class="n">BufferAndBacklog</span> <span class="nf">bufferAndBacklog</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">// BEWARE: this must be in sync with #isAvailable()!
</span><span class="c1"></span>		<span class="k">return</span> <span class="n">bufferAndBacklog</span><span class="p">.</span><span class="na">isMoreAvailable</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
			<span class="p">(</span><span class="n">numCreditsAvailable</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">||</span> <span class="n">bufferAndBacklog</span><span class="p">.</span><span class="na">nextBufferIsEvent</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="c1">//在 ResultSubparition 中有数据时会回调该方法
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyDataAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="c1">//告知 PartitionRequestQueue 当前 ViewReader 有数据可读
</span><span class="c1"></span>		<span class="n">requestQueue</span><span class="p">.</span><span class="na">notifyReaderNonEmpty</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>PartitionRequestQueue</code> 负责将 <code>ResultSubparition</code> 中的数据通过网络发送给 <code>RemoteInputChannel</code>。在 <code>PartitionRequestQueue</code> 中保存了所有的 <code>NetworkSequenceViewReader</code> 和 <code>InputChannelID</code> 之间的映射关系，以及一个 <code>ArrayDeque&lt;NetworkSequenceViewReader&gt; availableReaders</code> 队列。当一个 <code>NetworkSequenceViewReader</code> 中有数据可以被消费时，就会被加入到 <code>availableReaders</code> 队列中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">PartitionRequestQueue</span> <span class="kd">extends</span> <span class="nf">ChannelInboundHandlerAdapter</span> <span class="p">{</span>
	<span class="cm">/** The readers which are already enqueued available for transferring data. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ArrayDeque</span><span class="o">&lt;</span><span class="n">NetworkSequenceViewReader</span><span class="o">&gt;</span> <span class="nf">availableReaders</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayDeque</span><span class="o">&lt;&gt;</span><span class="p">();</span>
	<span class="cm">/** All the readers created for the consumers&#39; partition requests. */</span>
	<span class="kd">private</span> <span class="nf">final</span> <span class="n">ConcurrentMap</span><span class="o">&lt;</span><span class="n">InputChannelID</span><span class="p">,</span> <span class="n">NetworkSequenceViewReader</span><span class="o">&gt;</span> <span class="nf">allReaders</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ConcurrentHashMap</span><span class="o">&lt;&gt;</span><span class="p">();</span>

	<span class="c1">//添加新的 NetworkSequenceViewReader
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyReaderCreated</span><span class="p">(</span><span class="kd">final</span> <span class="nf">NetworkSequenceViewReader</span> <span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">allReaders</span><span class="p">.</span><span class="na">put</span><span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="na">getReceiverId</span><span class="p">(),</span> <span class="n">reader</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//通知 NetworkSequenceViewReader 有数据可读取
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">notifyReaderNonEmpty</span><span class="p">(</span><span class="kd">final</span> <span class="nf">NetworkSequenceViewReader</span> <span class="n">reader</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//触发一次用户自定义事件
</span><span class="c1"></span>		<span class="n">ctx</span><span class="p">.</span><span class="na">executor</span><span class="p">().</span><span class="na">execute</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="na">pipeline</span><span class="p">().</span><span class="na">fireUserEventTriggered</span><span class="p">(</span><span class="n">reader</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="c1">//自定义用户事件的处理
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">userEventTriggered</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">msg</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="c1">// The user event triggered event loop callback is used for thread-safe
</span><span class="c1"></span>		<span class="c1">// hand over of reader queues and cancelled producers.
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="nf">instanceof</span> <span class="n">NetworkSequenceViewReader</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//NetworkSequenceViewReader有数据可读取，加入队列中
</span><span class="c1"></span>			<span class="n">enqueueAvailableReader</span><span class="p">((</span><span class="n">NetworkSequenceViewReader</span><span class="p">)</span> <span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msg</span><span class="p">.</span><span class="na">getClass</span><span class="p">()</span> <span class="o">==</span> <span class="n">InputChannelID</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// 对应的 RemoteInputChannel 请求取消消费
</span><span class="c1"></span>			<span class="c1">// Release partition view that get a cancel request.
</span><span class="c1"></span>			<span class="n">InputChannelID</span> <span class="nf">toCancel</span> <span class="o">=</span> <span class="p">(</span><span class="n">InputChannelID</span><span class="p">)</span> <span class="n">msg</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">released</span><span class="p">.</span><span class="na">contains</span><span class="p">(</span><span class="n">toCancel</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">// Cancel the request for the input channel
</span><span class="c1"></span>			<span class="kt">int</span> <span class="nf">size</span> <span class="o">=</span> <span class="n">availableReaders</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
			<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="nf">i</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">NetworkSequenceViewReader</span> <span class="nf">reader</span> <span class="o">=</span> <span class="n">pollAvailableReader</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="na">getReceiverId</span><span class="p">().</span><span class="na">equals</span><span class="p">(</span><span class="n">toCancel</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">reader</span><span class="p">.</span><span class="na">releaseAllResources</span><span class="p">();</span>
					<span class="n">markAsReleased</span><span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="na">getReceiverId</span><span class="p">());</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">registerAvailableReader</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">allReaders</span><span class="p">.</span><span class="na">remove</span><span class="p">(</span><span class="n">toCancel</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="p">.</span><span class="na">fireUserEventTriggered</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//加入队列
</span><span class="c1"></span>	<span class="kd">private</span> <span class="nf">void</span> <span class="n">enqueueAvailableReader</span><span class="p">(</span><span class="kd">final</span> <span class="nf">NetworkSequenceViewReader</span> <span class="n">reader</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="na">isRegisteredAsAvailable</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">reader</span><span class="p">.</span><span class="na">isAvailable</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//已经被注册到队列中，或者暂时没有 buffer 或没有 credit 可用
</span><span class="c1"></span>			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="kt">boolean</span> <span class="nf">triggerWrite</span> <span class="o">=</span> <span class="n">availableReaders</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">();</span>
		<span class="n">registerAvailableReader</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">triggerWrite</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//如果这是队列中第一个元素，调用 writeAndFlushNextMessageIfPossible 发送数据
</span><span class="c1"></span>			<span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="na">channel</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>PartitionRequestQueue</code> 会监听 Netty Channel 的可写入状态，当 Channel 可写入时，就会从 <code>availableReaders</code> 队列中取出 <code>NetworkSequenceViewReader</code>，读取数据并写入网络。可写入状态是 Netty 通过水位线进行控制的，<code>NettyServer</code> 在启动的时候会配置水位线，如果 Netty 输出缓冲中的字节数超过了高水位值，我们会等到其降到低水位值以下才继续写入数据。通过水位线机制确保不往网络中写入太多数据。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">PartitionRequestQueue</span> <span class="kd">extends</span> <span class="nf">ChannelInboundHandlerAdapter</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">channelWritabilityChanged</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="c1">//当前channel的读写状态发生变化
</span><span class="c1"></span>		<span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="na">channel</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="kd">final</span> <span class="nf">Channel</span> <span class="n">channel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatalError</span> <span class="o">||</span> <span class="o">!</span><span class="n">channel</span><span class="p">.</span><span class="na">isWritable</span><span class="p">())</span> <span class="p">{</span>
			<span class="c1">//如果当前不可写入，则直接返回
</span><span class="c1"></span>			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BufferAndAvailability</span> <span class="nf">next</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//取出一个 reader
</span><span class="c1"></span>				<span class="n">NetworkSequenceViewReader</span> <span class="nf">reader</span> <span class="o">=</span> <span class="n">pollAvailableReader</span><span class="p">();</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">reader</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">next</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="na">getNextBuffer</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">//没有读到数据
</span><span class="c1"></span>					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reader</span><span class="p">.</span><span class="na">isReleased</span><span class="p">())</span> <span class="p">{</span>
						<span class="c1">//还没有释放当前 subpartition，继续处理下一个 reader
</span><span class="c1"></span>						<span class="k">continue</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="n">markAsReleased</span><span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="na">getReceiverId</span><span class="p">());</span>

					<span class="c1">//出错了
</span><span class="c1"></span>					<span class="n">Throwable</span> <span class="nf">cause</span> <span class="o">=</span> <span class="n">reader</span><span class="p">.</span><span class="na">getFailureCause</span><span class="p">();</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cause</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">ErrorResponse</span> <span class="nf">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ErrorResponse</span><span class="p">(</span>
							<span class="k">new</span> <span class="n">ProducerFailedException</span><span class="p">(</span><span class="n">cause</span><span class="p">),</span>
							<span class="n">reader</span><span class="p">.</span><span class="na">getReceiverId</span><span class="p">());</span>

						<span class="n">ctx</span><span class="p">.</span><span class="na">writeAndFlush</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
					<span class="p">}</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">// 读到了数据
</span><span class="c1"></span>					<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">.</span><span class="na">moreAvailable</span><span class="p">())</span> <span class="p">{</span>
						<span class="c1">//这个 reader 还可以读到更多的数据，继续加入队列
</span><span class="c1"></span>						<span class="n">registerAvailableReader</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="n">BufferResponse</span> <span class="nf">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BufferResponse</span><span class="p">(</span>
						<span class="n">next</span><span class="p">.</span><span class="na">buffer</span><span class="p">(),</span>
						<span class="n">reader</span><span class="p">.</span><span class="na">getSequenceNumber</span><span class="p">(),</span>
						<span class="n">reader</span><span class="p">.</span><span class="na">getReceiverId</span><span class="p">(),</span>
						<span class="n">next</span><span class="p">.</span><span class="na">buffersInBacklog</span><span class="p">());</span>

					<span class="c1">// 向 client 发送数据，发送成功之后通过 writeListener 的回调触发下一次发送
</span><span class="c1"></span>					<span class="n">channel</span><span class="p">.</span><span class="na">writeAndFlush</span><span class="p">(</span><span class="n">msg</span><span class="p">).</span><span class="na">addListener</span><span class="p">(</span><span class="n">writeListener</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next</span><span class="p">.</span><span class="na">buffer</span><span class="p">().</span><span class="na">recycleBuffer</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IOException</span><span class="p">(</span><span class="n">t</span><span class="p">.</span><span class="na">getMessage</span><span class="p">(),</span> <span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">class</span> <span class="n">WriteAndFlushNextMessageIfPossibleListener</span> <span class="nf">implements</span> <span class="n">ChannelFutureListener</span> <span class="p">{</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="nf">void</span> <span class="n">operationComplete</span><span class="p">(</span><span class="n">ChannelFuture</span> <span class="nf">future</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">isSuccess</span><span class="p">())</span> <span class="p">{</span>
					<span class="c1">//发送成功，再次尝试写入
</span><span class="c1"></span>					<span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">());</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">cause</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">handleException</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">(),</span> <span class="n">future</span><span class="p">.</span><span class="na">cause</span><span class="p">());</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">handleException</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">(),</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Sending cancelled by user.&#34;</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">handleException</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">(),</span> <span class="n">t</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>在 Credit-based Flow Control 算法中，每发送一个 buffer 就会消耗一点 credit，在消费端有空闲 buffer 可用时会发送 <code>AddCrdit</code> 消息。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">PartitionRequestServerHandler</span> <span class="kd">extends</span> <span class="nf">SimpleChannelInboundHandler</span><span class="o">&lt;</span><span class="n">NettyMessage</span><span class="o">&gt;</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">protected</span> <span class="nf">void</span> <span class="n">channelRead0</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">,</span> <span class="n">NettyMessage</span> <span class="nf">msg</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="p">......</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msgClazz</span> <span class="o">==</span> <span class="n">AddCredit</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//增加 credit
</span><span class="c1"></span>				<span class="n">AddCredit</span> <span class="nf">request</span> <span class="o">=</span> <span class="p">(</span><span class="n">AddCredit</span><span class="p">)</span> <span class="n">msg</span><span class="p">;</span>
				<span class="n">outboundQueue</span><span class="p">.</span><span class="na">addCredit</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="na">receiverId</span><span class="p">,</span> <span class="n">request</span><span class="p">.</span><span class="na">credit</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="p">......</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nf">RequestReaderQueue</span> <span class="kd">extends</span> <span class="nf">ChannelInboundHandlerAdapter</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="nf">addCredit</span><span class="p">(</span><span class="n">InputChannelID</span> <span class="nf">receiverId</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">credit</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fatalError</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">NetworkSequenceViewReader</span> <span class="nf">reader</span> <span class="o">=</span> <span class="n">allReaders</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">receiverId</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reader</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//增加 credit
</span><span class="c1"></span>			<span class="n">reader</span><span class="p">.</span><span class="na">addCredit</span><span class="p">(</span><span class="n">credit</span><span class="p">);</span>
			<span class="c1">//因为增加了credit，可能可以继续处理数据，因此把 reader 加入队列
</span><span class="c1"></span>			<span class="n">enqueueAvailableReader</span><span class="p">(</span><span class="n">reader</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;No reader for receiverId = &#34;</span> <span class="o">+</span> <span class="n">receiverId</span> <span class="o">+</span> <span class="s">&#34; exists.&#34;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h5 id="消费端处理流程">消费端处理流程</h5>

<p>消费端即 <code>RemoteInputChannel</code> 一侧，在网络通信中对应 <code>NettyClient</code>。同样地，我们从 <code>ChannelHandler</code> 作为入口进行分析。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">interface</span> <span class="n">NetworkClientHandler</span> <span class="nf">extends</span> <span class="n">ChannelHandler</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="nf">addInputChannel</span><span class="p">(</span><span class="n">RemoteInputChannel</span> <span class="nf">inputChannel</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span><span class="p">;</span>
	<span class="kt">void</span> <span class="nf">removeInputChannel</span><span class="p">(</span><span class="n">RemoteInputChannel</span> <span class="nf">inputChannel</span><span class="p">);</span>
	<span class="kt">void</span> <span class="nf">cancelRequestFor</span><span class="p">(</span><span class="n">InputChannelID</span> <span class="nf">inputChannelId</span><span class="p">);</span>
	<span class="c1">//通知有新的的 credit 可用
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">notifyCreditAvailable</span><span class="p">(</span><span class="kd">final</span> <span class="nf">RemoteInputChannel</span> <span class="n">inputChannel</span><span class="p">);</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>NetworkClientHanlder</code> 对应的实现类为 <code>CreditBasedPartitionRequestClientHandler</code>，<code>CreditBasedPartitionRequestClientHandler</code> 负责接收服务端通过 Netty channel 发送的数据，解析数据后交给对应的 <code>RemoteInputChannle</code> 进行处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">CreditBasedPartitionRequestClientHandler</span> <span class="kd">extends</span> <span class="nf">ChannelInboundHandlerAdapter</span> <span class="kd">implements</span> <span class="nf">NetworkClientHandler</span> <span class="p">{</span>
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">channelRead</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">msg</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="c1">//从netty channel中接收到数据
</span><span class="c1"></span>		<span class="k">try</span> <span class="p">{</span>
			<span class="c1">//解析消息
</span><span class="c1"></span>			<span class="n">decodeMsg</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">notifyAllChannelsOfErrorAndClose</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">decodeMsg</span><span class="p">(</span><span class="n">Object</span> <span class="nf">msg</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Throwable</span> <span class="p">{</span>
		<span class="kd">final</span> <span class="nf">Class</span><span class="o">&lt;?&gt;</span> <span class="n">msgClazz</span> <span class="o">=</span> <span class="n">msg</span><span class="p">.</span><span class="na">getClass</span><span class="p">();</span>

		<span class="c1">// ---- Buffer --------------------------------------------------------
</span><span class="c1"></span>		<span class="k">if</span> <span class="p">(</span><span class="n">msgClazz</span> <span class="o">==</span> <span class="n">NettyMessage</span><span class="p">.</span><span class="na">BufferResponse</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//正常的数据
</span><span class="c1"></span>			<span class="n">NettyMessage</span><span class="p">.</span><span class="na">BufferResponse</span> <span class="nf">bufferOrEvent</span> <span class="o">=</span> <span class="p">(</span><span class="n">NettyMessage</span><span class="p">.</span><span class="na">BufferResponse</span><span class="p">)</span> <span class="n">msg</span><span class="p">;</span>

			<span class="c1">//根据 ID 定位到对应的 RemoteInputChannel
</span><span class="c1"></span>			<span class="n">RemoteInputChannel</span> <span class="nf">inputChannel</span> <span class="o">=</span> <span class="n">inputChannels</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">receiverId</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inputChannel</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//如果没有对应的 RemoteInputChannel
</span><span class="c1"></span>				<span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">releaseBuffer</span><span class="p">();</span>
				<span class="c1">//取消对给定 receiverId 的订阅
</span><span class="c1"></span>				<span class="n">cancelRequestFor</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">receiverId</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="c1">//解析消息，是buffer还是event
</span><span class="c1"></span>			<span class="n">decodeBufferOrEvent</span><span class="p">(</span><span class="n">inputChannel</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">);</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">msgClazz</span> <span class="o">==</span> <span class="n">NettyMessage</span><span class="p">.</span><span class="na">ErrorResponse</span><span class="p">.</span><span class="na">class</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// ---- Error ---------------------------------------------------------
</span><span class="c1"></span>			<span class="p">......</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Received unknown message from producer: &#34;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">.</span><span class="na">getClass</span><span class="p">());</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">decodeBufferOrEvent</span><span class="p">(</span><span class="n">RemoteInputChannel</span> <span class="nf">inputChannel</span><span class="p">,</span> <span class="n">NettyMessage</span><span class="p">.</span><span class="na">BufferResponse</span> <span class="nf">bufferOrEvent</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Throwable</span> <span class="p">{</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="n">ByteBuf</span> <span class="nf">nettyBuffer</span> <span class="o">=</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">getNettyBuffer</span><span class="p">();</span>
			<span class="kd">final</span> <span class="nf">int</span> <span class="n">receivedSize</span> <span class="o">=</span> <span class="n">nettyBuffer</span><span class="p">.</span><span class="na">readableBytes</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">isBuffer</span><span class="p">())</span> <span class="p">{</span>
				<span class="c1">// ---- Buffer ------------------------------------------------
</span><span class="c1"></span>				<span class="c1">// Early return for empty buffers. Otherwise Netty&#39;s readBytes() throws an
</span><span class="c1"></span>				<span class="c1">// IndexOutOfBoundsException.
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">receivedSize</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">inputChannel</span><span class="p">.</span><span class="na">onEmptyBuffer</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">sequenceNumber</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">backlog</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="c1">//从对应的 RemoteInputChannel 中请求一个 Buffer
</span><span class="c1"></span>				<span class="n">Buffer</span> <span class="nf">buffer</span> <span class="o">=</span> <span class="n">inputChannel</span><span class="p">.</span><span class="na">requestBuffer</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">//将接收的数据写入buffer
</span><span class="c1"></span>					<span class="n">nettyBuffer</span><span class="p">.</span><span class="na">readBytes</span><span class="p">(</span><span class="n">buffer</span><span class="p">.</span><span class="na">asByteBuf</span><span class="p">(),</span> <span class="n">receivedSize</span><span class="p">);</span>

					<span class="c1">//通知对应的channel，backlog是生产者那边堆积的buffer数量
</span><span class="c1"></span>					<span class="n">inputChannel</span><span class="p">.</span><span class="na">onBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">sequenceNumber</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">backlog</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inputChannel</span><span class="p">.</span><span class="na">isReleased</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">cancelRequestFor</span><span class="p">(</span><span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">receiverId</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">throw</span> <span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;No buffer available in credit-based input channel.&#34;</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="c1">// ---- Event -------------------------------------------------
</span><span class="c1"></span>				<span class="c1">// TODO We can just keep the serialized data in the Netty buffer and release it later at the reader
</span><span class="c1"></span>				<span class="kt">byte</span><span class="p">[]</span> <span class="nf">byteArray</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="p">[</span><span class="n">receivedSize</span><span class="p">];</span>
				<span class="n">nettyBuffer</span><span class="p">.</span><span class="na">readBytes</span><span class="p">(</span><span class="n">byteArray</span><span class="p">);</span>

				<span class="n">MemorySegment</span> <span class="nf">memSeg</span> <span class="o">=</span> <span class="n">MemorySegmentFactory</span><span class="p">.</span><span class="na">wrap</span><span class="p">(</span><span class="n">byteArray</span><span class="p">);</span>
				<span class="c1">//是一个事件，不需要从 RemoteInputChannel 中申请 buffer
</span><span class="c1"></span>				<span class="n">Buffer</span> <span class="nf">buffer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NetworkBuffer</span><span class="p">(</span><span class="n">memSeg</span><span class="p">,</span> <span class="n">FreeingBufferRecycler</span><span class="p">.</span><span class="na">INSTANCE</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="n">receivedSize</span><span class="p">);</span>
				<span class="c1">//通知对应的channel，backlog是生产者那边堆积的buffer数量
</span><span class="c1"></span>				<span class="n">inputChannel</span><span class="p">.</span><span class="na">onBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">sequenceNumber</span><span class="p">,</span> <span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">backlog</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
			<span class="n">bufferOrEvent</span><span class="p">.</span><span class="na">releaseBuffer</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p><code>CreditBasedPartitionRequestClientHandler</code> 从网络中读取数据后交给 <code>RemoteInputChannel</code>， <code>RemoteInputChannel</code> 会将接收到的加入队列中，并根据生产端的堆积申请 floating buffer：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="nf">class</span> <span class="n">RemoteInputChannel</span> <span class="nf">extends</span> <span class="n">InputChannel</span> <span class="nf">implements</span> <span class="n">BufferRecycler</span><span class="p">,</span> <span class="n">BufferListener</span> <span class="p">{</span>
	<span class="c1">//接收到远程 ResultSubpartition 发送的 Buffer
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">void</span> <span class="n">onBuffer</span><span class="p">(</span><span class="n">Buffer</span> <span class="nf">buffer</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">sequenceNumber</span><span class="p">,</span> <span class="kt">int</span> <span class="nf">backlog</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="kt">boolean</span> <span class="nf">recycleBuffer</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="kd">final</span> <span class="nf">boolean</span> <span class="n">wasEmpty</span><span class="p">;</span>
			<span class="kd">synchronized</span> <span class="p">(</span><span class="n">receivedBuffers</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">.</span><span class="na">get</span><span class="p">())</span> <span class="p">{</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="c1">//序号需要匹配
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">expectedSequenceNumber</span> <span class="o">!=</span> <span class="n">sequenceNumber</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">onError</span><span class="p">(</span><span class="k">new</span> <span class="n">BufferReorderingException</span><span class="p">(</span><span class="n">expectedSequenceNumber</span><span class="p">,</span> <span class="n">sequenceNumber</span><span class="p">));</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="c1">//加入 receivedBuffers 队列中
</span><span class="c1"></span>				<span class="n">wasEmpty</span> <span class="o">=</span> <span class="n">receivedBuffers</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">();</span>
				<span class="n">receivedBuffers</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
				<span class="n">recycleBuffer</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="o">++</span><span class="n">expectedSequenceNumber</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wasEmpty</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//通知 InputGate，当前 channel 有新数据
</span><span class="c1"></span>				<span class="n">notifyChannelNonEmpty</span><span class="p">();</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">backlog</span> <span class="o">&gt;=</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//根据客户端的积压申请float buffer
</span><span class="c1"></span>				<span class="n">onSenderBacklog</span><span class="p">(</span><span class="n">backlog</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">recycleBuffer</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">buffer</span><span class="p">.</span><span class="na">recycleBuffer</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">//backlog 是发送端的堆积 的 buffer 数量，
</span><span class="c1"></span>	<span class="c1">//如果 bufferQueue 中 buffer 的数量不足，就去须从 LocalBufferPool 中请求 floating buffer
</span><span class="c1"></span>	<span class="c1">//在请求了新的 buffer 后，通知生产者有 credit 可用
</span><span class="c1"></span>	<span class="kt">void</span> <span class="nf">onSenderBacklog</span><span class="p">(</span><span class="kt">int</span> <span class="nf">backlog</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">IOException</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="nf">numRequestedBuffers</span> <span class="o">=</span> <span class="n">0</span><span class="p">;</span>

		<span class="kd">synchronized</span> <span class="p">(</span><span class="n">bufferQueue</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">// Similar to notifyBufferAvailable(), make sure that we never add a buffer
</span><span class="c1"></span>			<span class="c1">// after releaseAllResources() released all buffers (see above for details).
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">.</span><span class="na">get</span><span class="p">())</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">//需要的 buffer 数量是 backlog + initialCredit, backlog 是生产者当前的积压
</span><span class="c1"></span>			<span class="n">numRequiredBuffers</span> <span class="o">=</span> <span class="n">backlog</span> <span class="o">+</span> <span class="n">initialCredit</span><span class="p">;</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">bufferQueue</span><span class="p">.</span><span class="na">getAvailableBufferSize</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">numRequiredBuffers</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isWaitingForFloatingBuffers</span><span class="p">)</span> <span class="p">{</span>
				<span class="c1">//不停地请求新的 floating buffer
</span><span class="c1"></span>				<span class="n">Buffer</span> <span class="nf">buffer</span> <span class="o">=</span> <span class="n">inputGate</span><span class="p">.</span><span class="na">getBufferPool</span><span class="p">().</span><span class="na">requestBuffer</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">//从 buffer poll 中请求到 buffer
</span><span class="c1"></span>					<span class="n">bufferQueue</span><span class="p">.</span><span class="na">addFloatingBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
					<span class="n">numRequestedBuffers</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inputGate</span><span class="p">.</span><span class="na">getBufferProvider</span><span class="p">().</span><span class="na">addBufferListener</span><span class="p">(</span><span class="k">this</span><span class="p">))</span> <span class="p">{</span>
					<span class="c1">// buffer pool 没有 buffer 了，加一个监听，当 LocalBufferPool 中有新的 buffer 时会回调 notifyBufferAvailable
</span><span class="c1"></span>					<span class="c1">// If the channel has not got enough buffers, register it as listener to wait for more floating buffers.
</span><span class="c1"></span>					<span class="n">isWaitingForFloatingBuffers</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">numRequestedBuffers</span> <span class="o">&gt;</span> <span class="n">0</span> <span class="o">&amp;&amp;</span> <span class="n">unannouncedCredit</span><span class="p">.</span><span class="na">getAndAdd</span><span class="p">(</span><span class="n">numRequestedBuffers</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//请求了新的floating buffer，要更新 credit
</span><span class="c1"></span>			<span class="n">notifyCreditAvailable</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">notifyCreditAvailable</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">checkState</span><span class="p">(</span><span class="n">partitionRequestClient</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">,</span> <span class="s">&#34;Tried to send task event to producer before requesting a queue.&#34;</span><span class="p">);</span>
		<span class="c1">//通知当前 channel 有新的 credit
</span><span class="c1"></span>		<span class="n">partitionRequestClient</span><span class="p">.</span><span class="na">notifyCreditAvailable</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//LocalBufferPool 通知有 buffer 可用
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">NotificationResult</span> <span class="n">notifyBufferAvailable</span><span class="p">(</span><span class="n">Buffer</span> <span class="nf">buffer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NotificationResult</span> <span class="nf">notificationResult</span> <span class="o">=</span> <span class="n">NotificationResult</span><span class="p">.</span><span class="na">BUFFER_NOT_USED</span><span class="p">;</span>
		<span class="k">try</span> <span class="p">{</span>
			<span class="kd">synchronized</span> <span class="p">(</span><span class="n">bufferQueue</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">checkState</span><span class="p">(</span><span class="n">isWaitingForFloatingBuffers</span><span class="p">,</span>
					<span class="s">&#34;This channel should be waiting for floating buffers.&#34;</span><span class="p">);</span>

				<span class="c1">// Important: make sure that we never add a buffer after releaseAllResources()
</span><span class="c1"></span>				<span class="c1">// released all buffers. Following scenarios exist:
</span><span class="c1"></span>				<span class="c1">// 1) releaseAllResources() already released buffers inside bufferQueue
</span><span class="c1"></span>				<span class="c1">// -&gt; then isReleased is set correctly
</span><span class="c1"></span>				<span class="c1">// 2) releaseAllResources() did not yet release buffers from bufferQueue
</span><span class="c1"></span>				<span class="c1">// -&gt; we may or may not have set isReleased yet but will always wait for the
</span><span class="c1"></span>				<span class="c1">// lock on bufferQueue to release buffers
</span><span class="c1"></span>				<span class="k">if</span> <span class="p">(</span><span class="n">isReleased</span><span class="p">.</span><span class="na">get</span><span class="p">()</span> <span class="o">||</span> <span class="n">bufferQueue</span><span class="p">.</span><span class="na">getAvailableBufferSize</span><span class="p">()</span> <span class="o">&gt;=</span> <span class="n">numRequiredBuffers</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">isWaitingForFloatingBuffers</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">notificationResult</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="c1">//增加floating buffer
</span><span class="c1"></span>				<span class="n">bufferQueue</span><span class="p">.</span><span class="na">addFloatingBuffer</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">bufferQueue</span><span class="p">.</span><span class="na">getAvailableBufferSize</span><span class="p">()</span> <span class="o">==</span> <span class="n">numRequiredBuffers</span><span class="p">)</span> <span class="p">{</span>
					<span class="c1">//bufferQueue中有足够多的 buffer 了
</span><span class="c1"></span>					<span class="n">isWaitingForFloatingBuffers</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
					<span class="n">notificationResult</span> <span class="o">=</span> <span class="n">NotificationResult</span><span class="p">.</span><span class="na">BUFFER_USED_NO_NEED_MORE</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="c1">//bufferQueue 中 buffer 仍然不足
</span><span class="c1"></span>					<span class="n">notificationResult</span> <span class="o">=</span> <span class="n">NotificationResult</span><span class="p">.</span><span class="na">BUFFER_USED_NEED_MORE</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unannouncedCredit</span><span class="p">.</span><span class="na">getAndAdd</span><span class="p">(</span><span class="n">1</span><span class="p">)</span> <span class="o">==</span> <span class="n">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">notifyCreditAvailable</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">setError</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">notificationResult</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<p>一旦 <code>RemoteInputChannel</code> 申请到新的 buffer，就需要通知生产者更新 credit，这需要发送一条 <code>AddCredit</code> 消息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-java" data-lang="java"><span class="kd">class</span> <span class="nf">PartitionRequestClient</span> <span class="p">{</span>
	<span class="c1">//交给 NetworkClientHandler 处理
</span><span class="c1"></span>	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyCreditAvailable</span><span class="p">(</span><span class="n">RemoteInputChannel</span> <span class="nf">inputChannel</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clientHandler</span><span class="p">.</span><span class="na">notifyCreditAvailable</span><span class="p">(</span><span class="n">inputChannel</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="nf">CreditBasedPartitionRequestClientHandler</span> <span class="kd">extends</span> <span class="nf">ChannelInboundHandlerAdapter</span> <span class="kd">implements</span> <span class="nf">NetworkClientHandler</span> <span class="p">{</span>
	<span class="c1">//有新的credit
</span><span class="c1"></span>	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">notifyCreditAvailable</span><span class="p">(</span><span class="kd">final</span> <span class="nf">RemoteInputChannel</span> <span class="n">inputChannel</span><span class="p">)</span> <span class="p">{</span>
		<span class="c1">//触发一次自定义事件
</span><span class="c1"></span>		<span class="n">ctx</span><span class="p">.</span><span class="na">executor</span><span class="p">().</span><span class="na">execute</span><span class="p">(()</span> <span class="o">-&gt;</span> <span class="n">ctx</span><span class="p">.</span><span class="na">pipeline</span><span class="p">().</span><span class="na">fireUserEventTriggered</span><span class="p">(</span><span class="n">inputChannel</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">channelWritabilityChanged</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="na">channel</span><span class="p">());</span>
	<span class="p">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nf">void</span> <span class="n">userEventTriggered</span><span class="p">(</span><span class="n">ChannelHandlerContext</span> <span class="nf">ctx</span><span class="p">,</span> <span class="n">Object</span> <span class="nf">msg</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">msg</span> <span class="nf">instanceof</span> <span class="n">RemoteInputChannel</span><span class="p">)</span> <span class="p">{</span>
			<span class="c1">//有新的credit会触发
</span><span class="c1"></span>			<span class="kt">boolean</span> <span class="nf">triggerWrite</span> <span class="o">=</span> <span class="n">inputChannelsWithCredit</span><span class="p">.</span><span class="na">isEmpty</span><span class="p">();</span>

			<span class="c1">//加入到队列中
</span><span class="c1"></span>			<span class="n">inputChannelsWithCredit</span><span class="p">.</span><span class="na">add</span><span class="p">((</span><span class="n">RemoteInputChannel</span><span class="p">)</span> <span class="n">msg</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">triggerWrite</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="na">channel</span><span class="p">());</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ctx</span><span class="p">.</span><span class="na">fireUserEventTriggered</span><span class="p">(</span><span class="n">msg</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">void</span> <span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">Channel</span> <span class="nf">channel</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">channelError</span><span class="p">.</span><span class="na">get</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">||</span> <span class="o">!</span><span class="n">channel</span><span class="p">.</span><span class="na">isWritable</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="c1">//从队列中取出 RemoteInputChannel， 发送消息
</span><span class="c1"></span>		<span class="k">while</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">RemoteInputChannel</span> <span class="nf">inputChannel</span> <span class="o">=</span> <span class="n">inputChannelsWithCredit</span><span class="p">.</span><span class="na">poll</span><span class="p">();</span>

			<span class="c1">// The input channel may be null because of the write callbacks
</span><span class="c1"></span>			<span class="c1">// that are executed after each write.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="n">inputChannel</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="c1">//It is no need to notify credit for the released channel.
</span><span class="c1"></span>			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inputChannel</span><span class="p">.</span><span class="na">isReleased</span><span class="p">())</span> <span class="p">{</span>
				<span class="c1">//发送 AddCredit 的消息
</span><span class="c1"></span>				<span class="n">AddCredit</span> <span class="nf">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">AddCredit</span><span class="p">(</span>
					<span class="n">inputChannel</span><span class="p">.</span><span class="na">getPartitionId</span><span class="p">(),</span>
					<span class="n">inputChannel</span><span class="p">.</span><span class="na">getAndResetUnannouncedCredit</span><span class="p">(),</span> <span class="c1">//获取并重置新增的credit
</span><span class="c1"></span>					<span class="n">inputChannel</span><span class="p">.</span><span class="na">getInputChannelId</span><span class="p">());</span>

				<span class="c1">// Write and flush and wait until this is done before
</span><span class="c1"></span>				<span class="c1">// trying to continue with the next input channel.
</span><span class="c1"></span>				<span class="n">channel</span><span class="p">.</span><span class="na">writeAndFlush</span><span class="p">(</span><span class="n">msg</span><span class="p">).</span><span class="na">addListener</span><span class="p">(</span><span class="n">writeListener</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="kd">private</span> <span class="nf">class</span> <span class="n">WriteAndFlushNextMessageIfPossibleListener</span> <span class="nf">implements</span> <span class="n">ChannelFutureListener</span> <span class="p">{</span>
		<span class="nd">@Override</span>
		<span class="kd">public</span> <span class="nf">void</span> <span class="n">operationComplete</span><span class="p">(</span><span class="n">ChannelFuture</span> <span class="nf">future</span><span class="p">)</span> <span class="kd">throws</span> <span class="nf">Exception</span> <span class="p">{</span>
			<span class="k">try</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">isSuccess</span><span class="p">())</span> <span class="p">{</span>
					<span class="n">writeAndFlushNextMessageIfPossible</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">channel</span><span class="p">());</span>
				<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">cause</span><span class="p">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">notifyAllChannelsOfErrorAndClose</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="na">cause</span><span class="p">());</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">notifyAllChannelsOfErrorAndClose</span><span class="p">(</span><span class="k">new</span> <span class="n">IllegalStateException</span><span class="p">(</span><span class="s">&#34;Sending cancelled by user.&#34;</span><span class="p">));</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">Throwable</span> <span class="nf">t</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">notifyAllChannelsOfErrorAndClose</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></td></tr></table>
</div>
</div>
<h2 id="反压">反压</h2>

<p>在上面几节，我们已经详细地分析了 Task 之间的数据交换机制和它们的实现原理，理解这这些实际上就已经理解了 Flink 的“反压”机制。</p>

<p>所谓“反压”，就是指在流处理系统中，下游任务的处理速度跟不上上游任务的数据生产速度。许多日常问题都会导致反压，例如，垃圾回收停顿可能会导致流入的数据快速堆积，或者遇到大促或秒杀活动导致流量陡增。反压如果不能得到正确的处理，可能会导致资源耗尽甚至系统崩溃。反压机制就是指系统能够自己检测到被阻塞的算子，然后系统自适应地降低源头或者上游的发送速率。在 Flink 中，应对“反压”是一种极其自然的方式，因为 Flink 中的数据传输机制已经提供了应对反压的措施。</p>

<p>在本地数据交换的情况下，两个 Task 实际上是同一个 JVM 中的两个线程，Task1 产生的 Buffer 直接被 Task2 使用，当 Task2 处理完之后这个 Buffer 就会被回收到本地缓冲池中。一旦 Task2 的处理速度比 Task2 产生 Buffer 的速度慢，那么缓冲池中 Buffer 渐渐地就会被耗尽，Task1 无法申请到新的 Buffer 自然就会阻塞，因而会导致 Task1 的降速。</p>

<p>在网络数据交换的情况下，如果下游 Task 的处理速度较慢，下游 Task 的接收缓冲池逐渐耗尽后就无法从网络中读取新的数据，这回导致上游 Task 无法将缓冲池中的 Buffer 发送到网络中，因此上游 Task 的缓冲池也会被耗尽，进而导致上游任务的降速。为了解决网络连接阻塞导致所有 Task 都无法处理数据的情况，Flink 还引入了 Credit-based Flow Control 算法，在上游生产者下游消费只之间通过“信用点”来协调发送速度，确保网络连接永远不会被阻塞。同时，Flink 的网络栈基于 Netty 构建，通过 Netty 的水位线机制也可以控制发送端的发送速率。</p>

<h2 id="小结">小结</h2>

<p>本文详细地分析在 Flink 作业中，不同的 Task 之间是如何进行数据交换的。我们先介绍了 Flink 数据交换机制的整体流程，然后分别对本地数据交换和网络数据交换的情况进行了细致的分析。在最后，我们也概括了 Flink 是如何应对“背压”的。总的来说，通过合理地利用缓冲池和流量控制算法，Flink 可以高效地在不同 Task 之间进行数据传输，并优雅地达到了自适应调整速度效果。</p>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://cwiki.apache.org/confluence/display/FLINK/Data+exchange+between+tasks?src=contextnavpagetreemode">Data exchange between tasks</a></li>
<li><a href="https://docs.google.com/document/d/1chTOuOqe0sBsjldA_r-wXYeSIhU2zRGpUaTaik7QZ84/edit#heading=h.pjh6mv7m2hjn">FLIP- Network Stack Improvements</a></li>
<li><a href="http://wuchong.me/blog/2016/04/26/flink-internals-how-to-handle-backpressure/">Flink 原理与实现：如何处理反压问题</a></li>
<li><a href="https://www.ververica.com/blog/how-flink-handles-backpressure">How Apache Flink™ handles backpressure</a></li>
</ul>

<p>-EOF-</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">原始链接</span>
    <span class="item-content"><a href="https://blog.jrwang.me/2019/flink-source-code-data-exchange/">https://blog.jrwang.me/2019/flink-source-code-data-exchange/</a></span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
        2019-09-12
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/flink/">Flink</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/2019/flink-source-code-task-lifecycle/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Flink 源码阅读笔记（9）- Task 的生命周期</span>
            <span class="prev-text nav-mobile">上一篇</span>
          </a>
        <a class="next" href="/2019/flink-source-code-memory-management/">
            <span class="next-text nav-default">Flink 源码阅读笔记（7）- 内存管理</span>
            <span class="next-text nav-mobile">下一篇</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="jrthe42/blog-comment"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="mailto:jrthe42@gmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/jrthe42" class="iconfont icon-github" title="github"></a>
      <a href="https://weibo.com/jrthe42" class="iconfont icon-weibo" title="weibo"></a>
  <a href="https://blog.jrwang.me/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    由 <a class="hexo-link" href="https://gohugo.io">Hugo</a> 强力驱动
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    主题 - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2015 - 
    2020
    <span class="heart">
      <i class="iconfont icon-heart"></i>
    </span>
    <span class="author"><a rel="license noopener" href="https://blog.jrwang.me" target="_blank">jrthe42</a></span>
  </span>
</div>
    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>
<script type="text/javascript" src="/dist/even.f79f403f.min.js"></script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-66913886-2', 'auto');
	ga('set', 'anonymizeIp', true);
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
