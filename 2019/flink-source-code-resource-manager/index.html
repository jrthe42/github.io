<!doctype html>
<html class="theme-next use-motion theme-next-mist">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>


    <meta name="description" content="想入非非就是寻找神奇" />



  <meta name="keywords" content="Flink," />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description" content="在 Flink 中，计算资源的是以 Slot 作为基本单位进行分配的。本文将对 Flink 中计算资源的管理机制加以分析。 Task Slot 的基本概念我们在前面的文章中了解了 Flink 集群的启动流程。在 Flink 集群中，每个 TaskManager 都是一个单独的 JVM 进程（非 MiniCluster 模式），并且在一个 TaskManager 中可能运行多个子任务，这些子任务都在">
<meta name="keywords" content="Flink">
<meta property="og:type" content="article">
<meta property="og:title" content="Flink 源码阅读笔记（6）- 计算资源管理">
<meta property="og:url" content="http://blog.jrwang.me/2019/flink-source-code-resource-manager/index.html">
<meta property="og:site_name" content="JR&#39;s Blog">
<meta property="og:description" content="在 Flink 中，计算资源的是以 Slot 作为基本单位进行分配的。本文将对 Flink 中计算资源的管理机制加以分析。 Task Slot 的基本概念我们在前面的文章中了解了 Flink 集群的启动流程。在 Flink 集群中，每个 TaskManager 都是一个单独的 JVM 进程（非 MiniCluster 模式），并且在一个 TaskManager 中可能运行多个子任务，这些子任务都在">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://blog.jrwang.me/img/flink/task-slots.svg">
<meta property="og:image" content="http://blog.jrwang.me/img/flink/slot-request.svg">
<meta property="og:updated_time" content="2019-08-14T12:47:32.729Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Flink 源码阅读笔记（6）- 计算资源管理">
<meta name="twitter:description" content="在 Flink 中，计算资源的是以 Slot 作为基本单位进行分配的。本文将对 Flink 中计算资源的管理机制加以分析。 Task Slot 的基本概念我们在前面的文章中了解了 Flink 集群的启动流程。在 Flink 集群中，每个 TaskManager 都是一个单独的 JVM 进程（非 MiniCluster 模式），并且在一个 TaskManager 中可能运行多个子任务，这些子任务都在">
<meta name="twitter:image" content="http://blog.jrwang.me/img/flink/task-slots.svg">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: 'Mist',
    sidebar: 'hide'
  };
</script>

  <title> Flink 源码阅读笔记（6）- 计算资源管理 | JR's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-66913886-2', 'auto');
  ga('send', 'pageview');
</script>




  <div class="container one-column page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">JR's Blog</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu ">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
    </ul>
  

  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 

  <div id="posts" class="posts-expand">
    

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              Flink 源码阅读笔记（6）- 计算资源管理
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2019-05-11T19:01:10+08:00" content="2019-05-11">
            2019-05-11
          </time>
        </span>

        

        
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        <span itemprop="articleBody"><p>在 Flink 中，计算资源的是以 Slot 作为基本单位进行分配的。本文将对 Flink 中计算资源的管理机制加以分析。</p>
<h2 id="Task-Slot-的基本概念"><a href="#Task-Slot-的基本概念" class="headerlink" title="Task Slot 的基本概念"></a>Task Slot 的基本概念</h2><p>我们在前面的文章中了解了 Flink 集群的启动流程。在 Flink 集群中，每个 TaskManager 都是一个单独的 JVM 进程（非 MiniCluster 模式），并且在一个 TaskManager 中可能运行多个子任务，这些子任务都在各自独立的线程中运行。为了控制一个 TaskManager 中可以运行的任务的数量，引入了 <strong>Task Slot</strong> 的概念。</p>
<p>每一个 Task Slot 代表了 TaskManager 所拥有的计算资源的一个固定的子集。例如，一个拥有 3 个 slot 的 TaskManager，每个 slot 可以使用 1/3 的内存。这样，运行在不同 slot 中的子任务不会竞争内存资源。目前 Flink 还不支持 CPU 的隔离，只支持内存的隔离。</p>
<p>通过调整 slot 的数量，可以控制子任务的隔离程度。例如，如果每个 TaskManager 只有 1 个 slot，么么就以为者每一组子任务都运行在单独的 JVM 进程中；每个 TaskManager 有多个 slot 的话，就意味着可以有更多的子任务运行在同一个 JVM 中。而在同一个 JVM 进程中的子任务，可以共享TCP连接和心跳消息，减少数据的网络传输，也能共享一些数据结构。一定程度上减少了每个子任务的消耗。</p>
<p>默认情况下， Flink 允许子任务共享 slot ，前提是，它们属于同一个 Job 并且不是同一个 operator 的子任务。这样的结果是，在同一个 slit 中可能会运行 Job 的一个完整的 pipeline。允许 Slot 共享有两个主要的好处：</p>
<ol>
<li>Flink 计算一个 Job 所需的 slot 数量时，只需要确定其最大并行度即可，而不用考虑每一个任务的并行度；</li>
<li>能更好的利用资源。如果没有 slot 共享，那些资源需求不大的子任务和资源需求大的子任务会占用相同的资源，但一旦允许 slot 共享，它们就可能被分配到同一个 slot 中。</li>
</ol>
<p>Flink 通过 <code>SlotSharingGroup</code> 和 <code>CoLocationGroup</code> 来确定在调度任务的时候如何进行资源共享，它们俩分别对应两种约束条件：</p>
<ul>
<li><code>SlotSharingGroup</code>： 相同 <code>SlotSharingGroup</code> 的不同 <code>JobVertex</code> 的子任务可以被分配在同一个 slot 中，但不保证能做到；</li>
<li><code>CoLocationGroup</code>：相同 <code>SlotSharingGroup</code> 的不同 <code>JobVertex</code> ，它们的第 n 个子任务必须保证都在同一个 slot 中，这是一种强制性的约束。</li>
</ul>
<h2 id="TaskExecutor-中-Slot-的管理"><a href="#TaskExecutor-中-Slot-的管理" class="headerlink" title="TaskExecutor 中 Slot 的管理"></a>TaskExecutor 中 Slot 的管理</h2><h3 id="TaskSlot"><a href="#TaskSlot" class="headerlink" title="TaskSlot"></a>TaskSlot</h3><p>首先，我们来看下在 TaskManager，也就是 <code>TaskExecutor</code> 中是如何管理 Slot 的。</p>
<p><code>SlotID</code> 是一个 slot 的唯一标识，它包含两个属性，其中 <code>ResourceID</code> 表明该 slot 所在的<code>TaskExecutor</code>， <code>slotNumber</code> 是该 slot 在 <code>TaskExecutor</code> 中的索引位置。</p>
<p><code>TaskSlot</code> 是在 <code>TaskExecutor</code> 中对 slot 的抽象，可能处于 <code>Free</code>, <code>Releasing</code>, <code>Allocated</code>, <code>Active</code> 这四种状态之中。它的主要属性如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSlot</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Index of the task slot. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> index;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/** State of this slot. */</span></span><br><span class="line">  <span class="keyword">private</span> TaskSlotState state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Resource characteristics for this slot. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceProfile resourceProfile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Tasks running in this slot. */</span></span><br><span class="line">  <span class="comment">//在一个 Slot 中可能执行多个 Task</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ExecutionAttemptID, Task&gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Job id to which the slot has been allocated; null if not allocated. */</span></span><br><span class="line">  <span class="keyword">private</span> JobID jobId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Allocation id of this slot; null if not allocated. */</span></span><br><span class="line">  <span class="keyword">private</span> AllocationID allocationId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>TaskSlot</code> 提供了修改状态的方法，如 <code>allocate(JobID newJobId, AllocationID newAllocationId)</code> 方法会将 slot 标记为 <code>Allocated</code> 状态；<code>markFree()</code> 会将 slot 标记为 <code>Free</code> 状态，但只有在所有 Task 都被移除之后才能释放成功。 slot 在切换状态的时候会先判断它当前所处的状态。另外，可以通过 <code>add(Task task)</code> 向 slot 中添加 Task，需要保证这些 Task 都来自同一个 Job。</p>
<h3 id="TaskSlotTable"><a href="#TaskSlotTable" class="headerlink" title="TaskSlotTable"></a>TaskSlotTable</h3><p><code>TaskExecutor</code> 主要通过 <code>TaskSlotTable</code> 来管理它所拥有的所有 slot :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSlotTable</span> <span class="keyword">implements</span> <span class="title">TimeoutListener</span>&lt;<span class="title">AllocationID</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">/** Timer service used to time out allocated slots. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TimerService&lt;AllocationID&gt; timerService;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The list of all task slots. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;TaskSlot&gt; taskSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Mapping from allocation id to task slot. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AllocationID, TaskSlot&gt; allocationIDTaskSlotMap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Mapping from execution attempt id to task and task slot. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ExecutionAttemptID, TaskSlotMapping&gt; taskSlotMappings;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Mapping from job id to allocated slots for a job. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;JobID, Set&lt;AllocationID&gt;&gt; slotsPerJob;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Interface for slot actions, such as freeing them or timing them out. */</span></span><br><span class="line">  <span class="keyword">private</span> SlotActions slotActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>allocateSlot(int index, JobID jobId, AllocationID allocationId, Time slotTimeout)</code> 方法可以将指定 index 的 slot 分配给 <code>AllocationID</code> 对应的请求，这个方法会调用 <code>TaskSlot.allocate(JobID newJobId, AllocationID newAllocationId)</code> 方法。这里需要注意的是，<code>allocateSlot</code> 方法的最后一个参数是一个超时时间。我们注意到，<code>TaskSlotTable</code> 有一个成员变量是 <code>TimerService&lt;AllocationID&gt; timerService</code>，通过 <code>timeService</code> 可以注册定时器，如果定时器在超时时间到达之前没有被取消，那么 <code>SlotAction.timeout</code> 方法就会被调用。如果被分配的 slot 关联的 slot 在超时之前没有被取消，那么该 slot 就会被重新释放，标记为 <code>Free</code> 状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSlotTable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allocateSlot</span><span class="params">(<span class="keyword">int</span> index, JobID jobId, AllocationID allocationId, Time slotTimeout)</span> </span>&#123;</span><br><span class="line">    checkInit();</span><br><span class="line">    TaskSlot taskSlot = taskSlots.get(index);</span><br><span class="line">    <span class="keyword">boolean</span> result = taskSlot.allocate(jobId, allocationId);</span><br><span class="line">    <span class="keyword">if</span> (result) &#123;</span><br><span class="line">      <span class="comment">// update the allocation id to task slot map</span></span><br><span class="line">      allocationIDTaskSlotMap.put(allocationId, taskSlot);</span><br><span class="line">      <span class="comment">// register a timeout for this slot since it's in state allocated</span></span><br><span class="line">      timerService.registerTimeout(allocationId, slotTimeout.getSize(), slotTimeout.getUnit());</span><br><span class="line">      <span class="comment">// add this slot to the set of job slots</span></span><br><span class="line">      Set&lt;AllocationID&gt; slots = slotsPerJob.get(jobId);</span><br><span class="line">      <span class="keyword">if</span> (slots == <span class="keyword">null</span>) &#123;</span><br><span class="line">        slots = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</span><br><span class="line">        slotsPerJob.put(jobId, slots);</span><br><span class="line">      &#125;</span><br><span class="line">      slots.add(allocationId);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 slot 被标记为 Active，则会取消在分配 slot 的时候关联的定时器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSlotTable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSlotActive</span><span class="params">(AllocationID allocationId)</span> <span class="keyword">throws</span> SlotNotFoundException </span>&#123;</span><br><span class="line">    checkInit();</span><br><span class="line">    TaskSlot taskSlot = getTaskSlot(allocationId);</span><br><span class="line">    <span class="keyword">if</span> (taskSlot != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (taskSlot.markActive()) &#123;</span><br><span class="line">        <span class="comment">// unregister a potential timeout</span></span><br><span class="line">        LOG.info(<span class="string">"Activate slot &#123;&#125;."</span>, allocationId);</span><br><span class="line">        timerService.unregisterTimeout(allocationId);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SlotNotFoundException(allocationId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过 <code>createSlotReport</code> 可以获得一个 <code>SlotReport</code> 对象， <code>SlotReport</code> 中包含当前 <code>TaskExecutor</code> 中所有 slot 的状态以及它们的分配情况。</p>
<h3 id="TaskExecutor"><a href="#TaskExecutor" class="headerlink" title="TaskExecutor"></a>TaskExecutor</h3><p><code>TaskExecutor</code> 需要向 <code>ResourceManager</code> 报告所有 slot 的状态，这样 <code>ResourceManager</code> 就知道了所有 slot 的分配情况。这主要发生在两种情况之下：</p>
<ul>
<li><code>TaskExecutor</code> 首次和 <code>ResourceManager</code> 建立连接的时候，需要发送 <code>SlotReport</code></li>
<li><code>TaskExecutor</code> 和 <code>ResourceManager</code> 定期发送心跳信息，心跳包中包含 <code>SlotReport</code></li>
</ul>
<p>我们看下相关的代码逻辑：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">establishResourceManagerConnection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			ResourceManagerGateway resourceManagerGateway,</span></span></span><br><span class="line"><span class="function"><span class="params">			ResourceID resourceManagerResourceId,</span></span></span><br><span class="line"><span class="function"><span class="params">			InstanceID taskExecutorRegistrationId,</span></span></span><br><span class="line"><span class="function"><span class="params">			ClusterInformation clusterInformation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首次建立连接，向 RM 报告 slot 信息</span></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; slotReportResponseFuture = resourceManagerGateway.sendSlotReport(</span><br><span class="line">      getResourceID(),</span><br><span class="line">      taskExecutorRegistrationId,</span><br><span class="line">      taskSlotTable.createSlotReport(getResourceID()),</span><br><span class="line">      taskManagerConfiguration.getTimeout());</span><br><span class="line">      </span><br><span class="line">    <span class="comment">//.........</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceManagerHeartbeatListener</span> <span class="keyword">implements</span> <span class="title">HeartbeatListener</span>&lt;<span class="title">Void</span>, <span class="title">SlotReport</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//心跳信息</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompletableFuture&lt;SlotReport&gt; <span class="title">retrievePayload</span><span class="params">(ResourceID resourceID)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> callAsync(</span><br><span class="line">          () -&gt; taskSlotTable.createSlotReport(getResourceID()),</span><br><span class="line">          taskManagerConfiguration.getTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>ResourceManager</code> 通过 <code>TaskExecutor.requestSlot</code> 方法要求 <code>TaskExecutor</code> 分配 slot，由于 <code>ResourceManager</code> 知道所有 slot 的当前状况，因此分配请求会精确到具体的 SlotID ：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Acknowledge&gt; <span class="title">requestSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> SlotID slotId,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> JobID jobId,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> AllocationID allocationId,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> String targetAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> ResourceManagerId resourceManagerId,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">final</span> Time timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//判断发送请求的 RM 是否是当前 TaskExecutor 注册的</span></span><br><span class="line">      <span class="keyword">if</span> (!isConnectedToResourceManager(resourceManagerId)) &#123;</span><br><span class="line">        <span class="keyword">final</span> String message = String.format(<span class="string">"TaskManager is not connected to the resource manager %s."</span>, resourceManagerId);</span><br><span class="line">        log.debug(message);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TaskManagerException(message);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</span><br><span class="line">        <span class="comment">//如果 slot 是 Free 状态，则分配 slot</span></span><br><span class="line">        <span class="keyword">if</span> (taskSlotTable.allocateSlot(slotId.getSlotNumber(), jobId, allocationId, taskManagerConfiguration.getTimeout())) &#123;</span><br><span class="line">          log.info(<span class="string">"Allocated slot for &#123;&#125;."</span>, allocationId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.info(<span class="string">"Could not allocate slot for &#123;&#125;."</span>, allocationId);</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SlotAllocationException(<span class="string">"Could not allocate slot."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!taskSlotTable.isAllocated(slotId.getSlotNumber(), jobId, allocationId)) &#123;</span><br><span class="line">        <span class="comment">//如果 slot 已经被分配了，则抛出异常</span></span><br><span class="line">        <span class="keyword">final</span> String message = <span class="string">"The slot "</span> + slotId + <span class="string">" has already been allocated for a different job."</span>;</span><br><span class="line">        log.info(message);</span><br><span class="line">        <span class="keyword">final</span> AllocationID allocationID = taskSlotTable.getCurrentAllocation(slotId.getSlotNumber());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SlotOccupiedException(message, allocationID, taskSlotTable.getOwningJob(allocationID));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将分配的 slot 提供给发送请求的 JobManager</span></span><br><span class="line">      <span class="keyword">if</span> (jobManagerTable.contains(jobId)) &#123;</span><br><span class="line">        <span class="comment">//如果和对应的 JobManager 已经建立了连接，则向 JobManager 提供 slot</span></span><br><span class="line">        offerSlotsToJobManager(jobId);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//否则，先和JobManager 建立连接，连接建立后会调用 offerSlotsToJobManager(jobId) 方法</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          jobLeaderService.addJob(jobId, targetAddress);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// free the allocated slot</span></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            taskSlotTable.freeSlot(allocationId);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (SlotNotFoundException slotNotFoundException) &#123;</span><br><span class="line">            <span class="comment">// slot no longer existent, this should actually never happen, because we've</span></span><br><span class="line">            <span class="comment">// just allocated the slot. So let's fail hard in this case!</span></span><br><span class="line">            onFatalError(slotNotFoundException);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// release local state under the allocation id.</span></span><br><span class="line">          localStateStoresManager.releaseLocalStateForAllocationId(allocationId);</span><br><span class="line">          <span class="comment">// sanity check</span></span><br><span class="line">          <span class="keyword">if</span> (!taskSlotTable.isSlotFree(slotId.getSlotNumber())) &#123;</span><br><span class="line">            onFatalError(<span class="keyword">new</span> Exception(<span class="string">"Could not free slot "</span> + slotId));</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> SlotAllocationException(<span class="string">"Could not add job to job leader service."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TaskManagerException taskManagerException) &#123;</span><br><span class="line">      <span class="keyword">return</span> FutureUtils.completedExceptionally(taskManagerException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 Slot 被分配给之后，TaskExecutor 需要将对应的 slot 提供给 JobManager，而这正是通过 <code>offerSlotsToJobManager(jobId)</code> 方法来实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">offerSlotsToJobManager</span><span class="params">(<span class="keyword">final</span> JobID jobId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> JobManagerConnection jobManagerConnection = jobManagerTable.get(jobId);</span><br><span class="line">    <span class="keyword">if</span> (jobManagerConnection == <span class="keyword">null</span>) &#123;</span><br><span class="line">      log.debug(<span class="string">"There is no job manager connection to the leader of job &#123;&#125;."</span>, jobId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (taskSlotTable.hasAllocatedSlots(jobId)) &#123;</span><br><span class="line">        log.info(<span class="string">"Offer reserved slots to the leader of job &#123;&#125;."</span>, jobId);</span><br><span class="line">        <span class="keyword">final</span> JobMasterGateway jobMasterGateway = jobManagerConnection.getJobManagerGateway();</span><br><span class="line">        <span class="comment">//获取分配给当前 Job 的 slot，这里只会取得状态为 allocated 的 slot</span></span><br><span class="line">        <span class="keyword">final</span> Iterator&lt;TaskSlot&gt; reservedSlotsIterator = taskSlotTable.getAllocatedSlots(jobId);</span><br><span class="line">        <span class="keyword">final</span> JobMasterId jobMasterId = jobManagerConnection.getJobMasterId();</span><br><span class="line">        <span class="keyword">final</span> Collection&lt;SlotOffer&gt; reservedSlots = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">while</span> (reservedSlotsIterator.hasNext()) &#123;</span><br><span class="line">          SlotOffer offer = reservedSlotsIterator.next().generateSlotOffer();</span><br><span class="line">          reservedSlots.add(offer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//通过 RPC 调用，将slot提供给 JobMaster</span></span><br><span class="line">        CompletableFuture&lt;Collection&lt;SlotOffer&gt;&gt; acceptedSlotsFuture = jobMasterGateway.offerSlots(</span><br><span class="line">          getResourceID(),</span><br><span class="line">          reservedSlots,</span><br><span class="line">          taskManagerConfiguration.getTimeout());</span><br><span class="line"></span><br><span class="line">        acceptedSlotsFuture.whenCompleteAsync(</span><br><span class="line">          (Iterable&lt;SlotOffer&gt; acceptedSlots, Throwable throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">//超时，则重试</span></span><br><span class="line">              <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">                log.info(<span class="string">"Slot offering to JobManager did not finish in time. Retrying the slot offering."</span>);</span><br><span class="line">                <span class="comment">// We ran into a timeout. Try again.</span></span><br><span class="line">                offerSlotsToJobManager(jobId);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.warn(<span class="string">"Slot offering to JobManager failed. Freeing the slots "</span> +</span><br><span class="line">                  <span class="string">"and returning them to the ResourceManager."</span>, throwable);</span><br><span class="line">                <span class="comment">// 发生异常，则释放所有的 slot</span></span><br><span class="line">                <span class="keyword">for</span> (SlotOffer reservedSlot: reservedSlots) &#123;</span><br><span class="line">                  freeSlotInternal(reservedSlot.getAllocationId(), throwable);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//调用成功</span></span><br><span class="line">              <span class="comment">// check if the response is still valid</span></span><br><span class="line">              <span class="keyword">if</span> (isJobManagerConnectionValid(jobId, jobMasterId)) &#123;</span><br><span class="line">                <span class="comment">// mark accepted slots active</span></span><br><span class="line">                <span class="comment">//对于被 JobMaster 确认接受的 slot， 标记为 Active 状态</span></span><br><span class="line">                <span class="keyword">for</span> (SlotOffer acceptedSlot : acceptedSlots) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!taskSlotTable.markSlotActive(acceptedSlot.getAllocationId())) &#123;</span><br><span class="line">                      <span class="comment">// the slot is either free or releasing at the moment</span></span><br><span class="line">                      <span class="keyword">final</span> String message = <span class="string">"Could not mark slot "</span> + jobId + <span class="string">" active."</span>;</span><br><span class="line">                      log.debug(message);</span><br><span class="line">                      jobMasterGateway.failSlot(</span><br><span class="line">                        getResourceID(),</span><br><span class="line">                        acceptedSlot.getAllocationId(),</span><br><span class="line">                        <span class="keyword">new</span> FlinkException(message));</span><br><span class="line">                    &#125;</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (SlotNotFoundException e) &#123;</span><br><span class="line">                    <span class="keyword">final</span> String message = <span class="string">"Could not mark slot "</span> + jobId + <span class="string">" active."</span>;</span><br><span class="line">                    jobMasterGateway.failSlot(</span><br><span class="line">                      getResourceID(),</span><br><span class="line">                      acceptedSlot.getAllocationId(),</span><br><span class="line">                      <span class="keyword">new</span> FlinkException(message));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  reservedSlots.remove(acceptedSlot);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Exception e = <span class="keyword">new</span> Exception(<span class="string">"The slot was rejected by the JobManager."</span>);</span><br><span class="line">                <span class="comment">//释放剩余没有被接受的 slot</span></span><br><span class="line">                <span class="keyword">for</span> (SlotOffer rejectedSlot : reservedSlots) &#123;</span><br><span class="line">                  freeSlotInternal(rejectedSlot.getAllocationId(), e);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// discard the response since there is a new leader for the job</span></span><br><span class="line">                log.debug(<span class="string">"Discard offer slot response since there is a new leader "</span> +</span><br><span class="line">                  <span class="string">"for the job &#123;&#125;."</span>, jobId);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          getMainThreadExecutor());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"There are no unassigned slots for the job &#123;&#125;."</span>, jobId);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 <code>freeSlot(AllocationID, Throwable)</code> 方法，可以请求 <code>TaskExecutor</code> 释放和 <code>AllocationID</code> 关联的 slot：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskExecutor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletableFuture&lt;Acknowledge&gt; <span class="title">freeSlot</span><span class="params">(AllocationID allocationId, Throwable cause, Time timeout)</span> </span>&#123;</span><br><span class="line">    freeSlotInternal(allocationId, cause);</span><br><span class="line">    <span class="keyword">return</span> CompletableFuture.completedFuture(Acknowledge.get());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">freeSlotInternal</span><span class="params">(AllocationID allocationId, Throwable cause)</span> </span>&#123;</span><br><span class="line">    checkNotNull(allocationId);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> JobID jobId = taskSlotTable.getOwningJob(allocationId);</span><br><span class="line">      <span class="comment">//尝试释放 allocationId 绑定的 slot</span></span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> slotIndex = taskSlotTable.freeSlot(allocationId, cause);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (slotIndex != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//成功释放 slot</span></span><br><span class="line">        <span class="keyword">if</span> (isConnectedToResourceManager()) &#123;</span><br><span class="line">          <span class="comment">//告知 ResourceManager 当前 slot 可用</span></span><br><span class="line">          <span class="comment">// the slot was freed. Tell the RM about it</span></span><br><span class="line">          ResourceManagerGateway resourceManagerGateway = establishedResourceManagerConnection.getResourceManagerGateway();</span><br><span class="line">          resourceManagerGateway.notifySlotAvailable(</span><br><span class="line">            establishedResourceManagerConnection.getTaskExecutorRegistrationId(),</span><br><span class="line">            <span class="keyword">new</span> SlotID(getResourceID(), slotIndex),</span><br><span class="line">            allocationId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (jobId != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果和 allocationID 绑定的 Job 已经没有分配的 slot 了，那么可以断开和 JobMaster 的连接了</span></span><br><span class="line">          <span class="comment">// check whether we still have allocated slots for the same job</span></span><br><span class="line">          <span class="keyword">if</span> (taskSlotTable.getAllocationIdsPerJob(jobId).isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// we can remove the job from the job leader service</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              jobLeaderService.removeJob(jobId);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">              log.info(<span class="string">"Could not remove job &#123;&#125; from JobLeaderService."</span>, jobId, e);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            closeJobManagerConnection(</span><br><span class="line">              jobId,</span><br><span class="line">              <span class="keyword">new</span> FlinkException(<span class="string">"TaskExecutor "</span> + getAddress() +</span><br><span class="line">                <span class="string">" has no more allocated slots for job "</span> + jobId + <span class="string">'.'</span>));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SlotNotFoundException e) &#123;</span><br><span class="line">      log.debug(<span class="string">"Could not free slot for allocation id &#123;&#125;."</span>, allocationId, e);</span><br><span class="line">    &#125;</span><br><span class="line">    localStateStoresManager.releaseLocalStateForAllocationId(allocationId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ResourceManage-中-Slot-的管理"><a href="#ResourceManage-中-Slot-的管理" class="headerlink" title="ResourceManage 中 Slot 的管理"></a>ResourceManage 中 Slot 的管理</h2><p>上一节分析 <code>TaskExecutor</code> 中 slot 的管理，仅仅局限于单个 <code>TaskExecutor</code>，而 <code>ResoureManager</code> 则需要对所有 <code>TaskExecutor</code> 的 slot 进行管理。所有的 JobManager 都是通过 <code>ResourceManager</code> 进行资源的申请，<code>ResourceManager</code> 则根据当前的集群的计算资源使用情况将请求“转发”给 <code>TaskExecutor</code>。</p>
<h3 id="SlotManager"><a href="#SlotManager" class="headerlink" title="SlotManager"></a>SlotManager</h3><p><code>ResourceManager</code> 借助 <code>SlotManager</code> 来管理 slot。 <code>SlotManager</code> 维护了所有已经注册的 <code>TaskExecutor</code> 的所有 slot 的状态，它们的分配情况。<code>SlotManager</code> 还维护了所有处于等待状态的 slot 请求。每当有一个新的 slot 注册或者一个已经分配的 slot 被释放的时候，<code>SlotManager</code> 会试图去满足处于等待状态 slot request。如果可用的 slot 不足以满足要求，<code>SlotManager</code> 会通过 <code>ResourceActions#allocateResource(ResourceProfile)</code> 来告知 <code>ResourceManager</code>, <code>ResourceManager</code> 可能会尝试启动新的 <code>TaskExecutor</code> (如 Yarn 模式下)。</p>
<p>此外，长时间处于空闲状态的 <code>TaskExecutor</code> 或者长时间没有被满足的 pending slot request，会触发超时机制进行处理。</p>
<h4 id="Slot-注册"><a href="#Slot-注册" class="headerlink" title="Slot 注册"></a>Slot 注册</h4><p>首先，来看下 <code>SlotManager</code> 中一些比较重要的成员变量，主要是 slot 的状态和 slot request 的状态：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** Map for all registered slots. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;SlotID, TaskManagerSlot&gt; slots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Index of all currently free slots. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;SlotID, TaskManagerSlot&gt; freeSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** All currently registered task managers. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;InstanceID, TaskManagerRegistration&gt; taskManagerRegistrations;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Map of fulfilled and active allocations for request deduplication purposes. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;AllocationID, SlotID&gt; fulfilledSlotRequests;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Map of pending/unfulfilled slot allocation requests. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;AllocationID, PendingSlotRequest&gt; pendingSlotRequests;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 资源不足的时候会通过 ResourceActions#allocateResource(ResourceProfile) 申请新的资源（可能启动新的 TaskManager，也可能什么也不做），</span></span><br><span class="line">  <span class="comment">// 这些新申请的资源会被封装为 PendingTaskManagerSlot</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;TaskManagerSlotId, PendingTaskManagerSlot&gt; pendingSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** ResourceManager's id. */</span></span><br><span class="line">  <span class="keyword">private</span> ResourceManagerId resourceManagerId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Callbacks for resource (de-)allocations. */</span></span><br><span class="line">  <span class="keyword">private</span> ResourceActions resourceActions;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当一个新的 <code>TaskManager</code>  注册的时候，<code>registerTaskManager</code> 被调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerTaskManager</span><span class="params">(<span class="keyword">final</span> TaskExecutorConnection taskExecutorConnection, SlotReport initialSlotReport)</span> </span>&#123;</span><br><span class="line">    checkInit();</span><br><span class="line">    LOG.debug(<span class="string">"Registering TaskManager &#123;&#125; under &#123;&#125; at the SlotManager."</span>, taskExecutorConnection.getResourceID(), taskExecutorConnection.getInstanceID());</span><br><span class="line">    <span class="comment">// we identify task managers by their instance id</span></span><br><span class="line">    <span class="keyword">if</span> (taskManagerRegistrations.containsKey(taskExecutorConnection.getInstanceID())) &#123;</span><br><span class="line">      reportSlotStatus(taskExecutorConnection.getInstanceID(), initialSlotReport);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// first register the TaskManager</span></span><br><span class="line">      ArrayList&lt;SlotID&gt; reportedSlots = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">for</span> (SlotStatus slotStatus : initialSlotReport) &#123;</span><br><span class="line">        reportedSlots.add(slotStatus.getSlotID());</span><br><span class="line">      &#125;</span><br><span class="line">      TaskManagerRegistration taskManagerRegistration = <span class="keyword">new</span> TaskManagerRegistration(</span><br><span class="line">        taskExecutorConnection,</span><br><span class="line">        reportedSlots);</span><br><span class="line">      taskManagerRegistrations.put(taskExecutorConnection.getInstanceID(), taskManagerRegistration);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 依次注册所有的 slot</span></span><br><span class="line">      <span class="comment">// next register the new slots</span></span><br><span class="line">      <span class="keyword">for</span> (SlotStatus slotStatus : initialSlotReport) &#123;</span><br><span class="line">        registerSlot(</span><br><span class="line">          slotStatus.getSlotID(),</span><br><span class="line">          slotStatus.getAllocationID(),</span><br><span class="line">          slotStatus.getJobID(),</span><br><span class="line">          slotStatus.getResourceProfile(),</span><br><span class="line">          taskExecutorConnection);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注册一个slot</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			SlotID slotId,</span></span></span><br><span class="line"><span class="function"><span class="params">			AllocationID allocationId,</span></span></span><br><span class="line"><span class="function"><span class="params">			JobID jobId,</span></span></span><br><span class="line"><span class="function"><span class="params">			ResourceProfile resourceProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">			TaskExecutorConnection taskManagerConnection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (slots.containsKey(slotId)) &#123;</span><br><span class="line">      <span class="comment">// remove the old slot first</span></span><br><span class="line">      removeSlot(slotId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建一个 TaskManagerSlot 对象，并加入 slots 中</span></span><br><span class="line">    <span class="keyword">final</span> TaskManagerSlot slot = createAndRegisterTaskManagerSlot(slotId, resourceProfile, taskManagerConnection);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> PendingTaskManagerSlot pendingTaskManagerSlot;</span><br><span class="line">    <span class="keyword">if</span> (allocationId == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//这个 slot 还没有被分配，则找到和当前 slot 的计算资源相匹配的 PendingTaskManagerSlot</span></span><br><span class="line">      pendingTaskManagerSlot = findExactlyMatchingPendingTaskManagerSlot(resourceProfile);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//这个 slot 已经被分配了</span></span><br><span class="line">      pendingTaskManagerSlot = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pendingTaskManagerSlot == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//两种可能： 1）slot已经被分配了 2）没有匹配的 PendingTaskManagerSlot</span></span><br><span class="line">      updateSlot(slotId, allocationId, jobId);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 新注册的 slot 能够满足 PendingTaskManagerSlot 的要求</span></span><br><span class="line">      pendingSlots.remove(pendingTaskManagerSlot.getTaskManagerSlotId());</span><br><span class="line">      <span class="keyword">final</span> PendingSlotRequest assignedPendingSlotRequest = pendingTaskManagerSlot.getAssignedPendingSlotRequest();</span><br><span class="line">      <span class="comment">// PendingTaskManagerSlot 可能有关联的 PedningSlotRequest</span></span><br><span class="line">      <span class="keyword">if</span> (assignedPendingSlotRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//没有关联的 PedningSlotRequest，则将 slot 是 Free 状态</span></span><br><span class="line">        handleFreeSlot(slot);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//有关联的 PedningSlotRequest，则这个 request 可以被满足，分配 slot</span></span><br><span class="line">        assignedPendingSlotRequest.unassignPendingTaskManagerSlot();</span><br><span class="line">        allocateSlot(slot, assignedPendingSlotRequest);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleFreeSlot</span><span class="params">(TaskManagerSlot freeSlot)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkState(freeSlot.getState() == TaskManagerSlot.State.FREE);</span><br><span class="line">    <span class="comment">//先查找是否有能够满足的 PendingSlotRequest</span></span><br><span class="line">    PendingSlotRequest pendingSlotRequest = findMatchingRequest(freeSlot.getResourceProfile());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pendingSlotRequest) &#123;</span><br><span class="line">      <span class="comment">//如果有匹配的 PendingSlotRequest，则分配slot</span></span><br><span class="line">      allocateSlot(freeSlot, pendingSlotRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      freeSlots.put(freeSlot.getSlotId(), freeSlot);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，<code>TaskExecutor</code> 也会定期通过心跳向 <code>ResourceManager</code> 报告 slot 的状态。 在 <code>reportSlotStatus</code> 方法中会更新 slot 的状态。</p>
<h4 id="请求-Slot"><a href="#请求-Slot" class="headerlink" title="请求 Slot"></a>请求 Slot</h4><p><code>ResourceManager</code> 通过 <code>SlotManager</code> 的 <code>registerSlotRequest(SlotRequest slotRequest)</code> 方法请求 slot，<code>SlotRequest</code> 中封装了请求的 <code>JobId</code>, <code>AllocationID</code> 以及请求的资源描述 <code>ResourceProfile</code>，<code>SlotManager</code> 会将 slot request 进一步封装为 <code>PendingSlotRequest</code>, 意为一个尚未被满足要求的 slot request。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">registerSlotRequest</span><span class="params">(SlotRequest slotRequest)</span> <span class="keyword">throws</span> SlotManagerException </span>&#123;</span><br><span class="line">    checkInit();</span><br><span class="line">    <span class="keyword">if</span> (checkDuplicateRequest(slotRequest.getAllocationId())) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Ignoring a duplicate slot request with allocation id &#123;&#125;."</span>, slotRequest.getAllocationId());</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//将请求封装为 PendingSlotRequest</span></span><br><span class="line">      PendingSlotRequest pendingSlotRequest = <span class="keyword">new</span> PendingSlotRequest(slotRequest);</span><br><span class="line">      pendingSlotRequests.put(slotRequest.getAllocationId(), pendingSlotRequest);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//执行请求分配slot的逻辑</span></span><br><span class="line">        internalRequestSlot(pendingSlotRequest);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ResourceManagerException e) &#123;</span><br><span class="line">        <span class="comment">// requesting the slot failed --&gt; remove pending slot request</span></span><br><span class="line">        pendingSlotRequests.remove(slotRequest.getAllocationId());</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SlotManagerException(<span class="string">"Could not fulfill slot request "</span> + slotRequest.getAllocationId() + <span class="string">'.'</span>, e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">internalRequestSlot</span><span class="params">(PendingSlotRequest pendingSlotRequest)</span> <span class="keyword">throws</span> ResourceManagerException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResourceProfile resourceProfile = pendingSlotRequest.getResourceProfile();</span><br><span class="line">    <span class="comment">//首先从 FREE 状态的已注册的 slot 中选择符合要求的 slot</span></span><br><span class="line">    TaskManagerSlot taskManagerSlot = findMatchingSlot(resourceProfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (taskManagerSlot != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//找到了符合条件的slot，分配</span></span><br><span class="line">      allocateSlot(taskManagerSlot, pendingSlotRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//从 PendingTaskManagerSlot 中选择</span></span><br><span class="line">      Optional&lt;PendingTaskManagerSlot&gt; pendingTaskManagerSlotOptional = findFreeMatchingPendingTaskManagerSlot(resourceProfile);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//如果连 PendingTaskManagerSlot 中都没有</span></span><br><span class="line">      <span class="keyword">if</span> (!pendingTaskManagerSlotOptional.isPresent()) &#123;</span><br><span class="line">        <span class="comment">//请求 ResourceManager 分配资源，通过 ResourceActions#allocateResource(ResourceProfile) 回调进行</span></span><br><span class="line">        pendingTaskManagerSlotOptional = allocateResource(resourceProfile);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//将 PendingTaskManagerSlot 指派给 PendingSlotRequest</span></span><br><span class="line">      pendingTaskManagerSlotOptional.ifPresent(pendingTaskManagerSlot -&gt; assignPendingTaskManagerSlot(pendingSlotRequest, pendingTaskManagerSlot));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么具体的 <code>allocatSlot</code> 的逻辑是怎么样的？在上一节我们提到过，通过 RPC 调用可以请求 <code>TaskExecutor</code> 分配 slot，这个 RPC 调用就是在 <code>SlotManager#allocateSlot</code> 中发生的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateSlot</span><span class="params">(TaskManagerSlot taskManagerSlot, PendingSlotRequest pendingSlotRequest)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkState(taskManagerSlot.getState() == TaskManagerSlot.State.FREE);</span><br><span class="line">    TaskExecutorConnection taskExecutorConnection = taskManagerSlot.getTaskManagerConnection();</span><br><span class="line">    TaskExecutorGateway gateway = taskExecutorConnection.getTaskExecutorGateway();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">    <span class="keyword">final</span> AllocationID allocationId = pendingSlotRequest.getAllocationId();</span><br><span class="line">    <span class="keyword">final</span> SlotID slotId = taskManagerSlot.getSlotId();</span><br><span class="line">    <span class="keyword">final</span> InstanceID instanceID = taskManagerSlot.getInstanceId();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//taskManagerSlot 状态变为 PENDING</span></span><br><span class="line">    taskManagerSlot.assignPendingSlotRequest(pendingSlotRequest);</span><br><span class="line">    pendingSlotRequest.setRequestFuture(completableFuture);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有 PendingTaskManager 指派给当前 pendingSlotRequest，要先解除关联</span></span><br><span class="line">    returnPendingTaskManagerSlotIfAssigned(pendingSlotRequest);</span><br><span class="line"></span><br><span class="line">    TaskManagerRegistration taskManagerRegistration = taskManagerRegistrations.get(instanceID);</span><br><span class="line">    <span class="keyword">if</span> (taskManagerRegistration == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not find a registered task manager for instance id "</span> +</span><br><span class="line">        instanceID + <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    taskManagerRegistration.markUsed();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RPC call to the task manager</span></span><br><span class="line">    <span class="comment">// 通过 RPC 调用向 TaskExecutor 请求 slot</span></span><br><span class="line">    CompletableFuture&lt;Acknowledge&gt; requestFuture = gateway.requestSlot(</span><br><span class="line">      slotId,</span><br><span class="line">      pendingSlotRequest.getJobId(),</span><br><span class="line">      allocationId,</span><br><span class="line">      pendingSlotRequest.getTargetAddress(),</span><br><span class="line">      resourceManagerId,</span><br><span class="line">      taskManagerRequestTimeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RPC调用的请求完成</span></span><br><span class="line">    requestFuture.whenComplete(</span><br><span class="line">      (Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (acknowledge != <span class="keyword">null</span>) &#123;</span><br><span class="line">          completableFuture.complete(acknowledge);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          completableFuture.completeExceptionally(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//PendingSlotRequest 请求完成的回调函数</span></span><br><span class="line">    <span class="comment">//PendingSlotRequest 请求完成可能是由于上面 RPC 调用完成，也可能是因为 PendingSlotRequest 被取消</span></span><br><span class="line">    completableFuture.whenCompleteAsync(</span><br><span class="line">      (Acknowledge acknowledge, Throwable throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (acknowledge != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果请求成功，则取消 pendingSlotRequest，并更新 slot 状态 PENDING -&gt; ALLOCATED</span></span><br><span class="line">            updateSlot(slotId, allocationId, pendingSlotRequest.getJobId());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> SlotOccupiedException) &#123;</span><br><span class="line">              <span class="comment">//这个 slot 已经被占用了，更新状态</span></span><br><span class="line">              SlotOccupiedException exception = (SlotOccupiedException) throwable;</span><br><span class="line">              updateSlot(slotId, exception.getAllocationId(), exception.getJobId());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//请求失败，将 pendingSlotRequest 从 TaskManagerSlot 中移除</span></span><br><span class="line">              removeSlotRequestFromSlot(slotId, allocationId);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!(throwable <span class="keyword">instanceof</span> CancellationException)) &#123;</span><br><span class="line">              <span class="comment">//slot request 请求失败，会进行重试</span></span><br><span class="line">              handleFailedSlotRequest(slotId, allocationId, throwable);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//主动取消</span></span><br><span class="line">              LOG.debug(<span class="string">"Slot allocation request &#123;&#125; has been cancelled."</span>, allocationId, throwable);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          LOG.error(<span class="string">"Error while completing the slot allocation."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      mainThreadExecutor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="取消-slot-请求"><a href="#取消-slot-请求" class="headerlink" title="取消 slot 请求"></a>取消 slot 请求</h4><p>通过 <code>unregisterSlotRequest</code> 可以取消一个 slot request：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">unregisterSlotRequest</span><span class="params">(AllocationID allocationId)</span> </span>&#123;</span><br><span class="line">    checkInit();</span><br><span class="line">    <span class="comment">//从 pendingSlotRequests 中移除</span></span><br><span class="line">    PendingSlotRequest pendingSlotRequest = pendingSlotRequests.remove(allocationId);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != pendingSlotRequest) &#123;</span><br><span class="line">      LOG.debug(<span class="string">"Cancel slot request &#123;&#125;."</span>, allocationId);</span><br><span class="line">      <span class="comment">//取消请求</span></span><br><span class="line">      cancelPendingSlotRequest(pendingSlotRequest);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      LOG.debug(<span class="string">"No pending slot request with allocation id &#123;&#125; found. Ignoring unregistration request."</span>, allocationId);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelPendingSlotRequest</span><span class="params">(PendingSlotRequest pendingSlotRequest)</span> </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Acknowledge&gt; request = pendingSlotRequest.getRequestFuture();</span><br><span class="line">    returnPendingTaskManagerSlotIfAssigned(pendingSlotRequest);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != request) &#123;</span><br><span class="line">      request.cancel(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="超时设置"><a href="#超时设置" class="headerlink" title="超时设置"></a>超时设置</h4><p><code>SlotManager</code> 在启动的时候会启动两个超时检测任务，一个是对 slot request 超时的检测，一个是对 TaskManager 长时间处于空闲状态的检测：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(ResourceManagerId newResourceManagerId, Executor newMainThreadExecutor, ResourceActions newResourceActions)</span> </span>&#123;</span><br><span class="line">    LOG.info(<span class="string">"Starting the SlotManager."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.resourceManagerId = Preconditions.checkNotNull(newResourceManagerId);</span><br><span class="line">    mainThreadExecutor = Preconditions.checkNotNull(newMainThreadExecutor);</span><br><span class="line">    resourceActions = Preconditions.checkNotNull(newResourceActions);</span><br><span class="line"></span><br><span class="line">    started = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查 TaskExecutor 是否长时间处于 idle 状态</span></span><br><span class="line">    taskManagerTimeoutCheck = scheduledExecutor.scheduleWithFixedDelay(</span><br><span class="line">      () -&gt; mainThreadExecutor.execute(</span><br><span class="line">        () -&gt; checkTaskManagerTimeouts()),</span><br><span class="line">      <span class="number">0L</span>,</span><br><span class="line">      taskManagerTimeout.toMilliseconds(),</span><br><span class="line">      TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查 slot request 是否超时</span></span><br><span class="line">    slotRequestTimeoutCheck = scheduledExecutor.scheduleWithFixedDelay(</span><br><span class="line">      () -&gt; mainThreadExecutor.execute(</span><br><span class="line">        () -&gt; checkSlotRequestTimeouts()),</span><br><span class="line">      <span class="number">0L</span>,</span><br><span class="line">      slotRequestTimeout.toMilliseconds(),</span><br><span class="line">      TimeUnit.MILLISECONDS);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦 <code>TaskExecutor</code> 长时间处于空闲状态，则会通过 <code>ResourceActions#releaseResource()</code> 回调函数释放资源：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">releaseTaskExecutor</span><span class="params">(InstanceID timedOutTaskManagerId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> FlinkException cause = <span class="keyword">new</span> FlinkException(<span class="string">"TaskExecutor exceeded the idle timeout."</span>);</span><br><span class="line">    LOG.debug(<span class="string">"Release TaskExecutor &#123;&#125; because it exceeded the idle timeout."</span>, timedOutTaskManagerId);</span><br><span class="line">    resourceActions.releaseResource(timedOutTaskManagerId, cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一个 slot request 超时，则会取消 PendingSlotRequest，并通过  <code>ResourceActions#notifyAllocationFailure()</code> 告知 <code>ResourceManager</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManager</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkSlotRequestTimeouts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pendingSlotRequests.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">      Iterator&lt;Map.Entry&lt;AllocationID, PendingSlotRequest&gt;&gt; slotRequestIterator = pendingSlotRequests.entrySet().iterator();</span><br><span class="line">      <span class="keyword">while</span> (slotRequestIterator.hasNext()) &#123;</span><br><span class="line">        PendingSlotRequest slotRequest = slotRequestIterator.next().getValue();</span><br><span class="line">        <span class="keyword">if</span> (currentTime - slotRequest.getCreationTimestamp() &gt;= slotRequestTimeout.toMilliseconds()) &#123;</span><br><span class="line">          slotRequestIterator.remove();</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (slotRequest.isAssigned()) &#123;</span><br><span class="line">            cancelPendingSlotRequest(slotRequest);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          resourceActions.notifyAllocationFailure(</span><br><span class="line">            slotRequest.getJobId(),</span><br><span class="line">            slotRequest.getAllocationId(),</span><br><span class="line">            <span class="keyword">new</span> TimeoutException(<span class="string">"The allocation could not be fulfilled in time."</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ResourceManager"><a href="#ResourceManager" class="headerlink" title="ResourceManager"></a>ResourceManager</h3><p>我们已经知道了， <code>ResoureManager</code> 实际上是通过 <code>SlotManager</code> 来管理 <code>TaskExecutor</code> 所注册的所有 slot，但 <code>ResourceManagee</code> 自身需要对外提供 RPC 调用方法，从而将 slot 管理相关的方法暴露给 <code>JobMaster</code> 和 <code>TaskExecutor</code>。</p>
<h4 id="RPC-接口"><a href="#RPC-接口" class="headerlink" title="RPC 接口"></a>RPC 接口</h4><p>首先，我们来看下 <code>ResourceManager</code> 提供了哪些 slot 管理相关的 RPC 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ResouceManagerGateway</span> </span>&#123;</span><br><span class="line">  <span class="function">CompletableFuture&lt;Acknowledge&gt; <span class="title">requestSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		JobMasterId jobMasterId,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequest slotRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">		@RpcTimeout Time timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancelSlotRequest</span><span class="params">(AllocationID allocationID)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">CompletableFuture&lt;Acknowledge&gt; <span class="title">sendSlotReport</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		ResourceID taskManagerResourceId,</span></span></span><br><span class="line"><span class="function"><span class="params">		InstanceID taskManagerRegistrationId,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotReport slotReport,</span></span></span><br><span class="line"><span class="function"><span class="params">		@RpcTimeout Time timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">notifySlotAvailable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		InstanceID instanceId,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotID slotID,</span></span></span><br><span class="line"><span class="function"><span class="params">		AllocationID oldAllocationId)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述的四个方法，<code>requestSlot</code> 和 <code>cancelSlotRequest</code> 主要供 <code>JobMaster</code> 进行调用，而 <code>sendSlotReport</code> 和 <code>notifySlotAvailable</code> 则主要供 <code>TaskExecutor</code> 调用。<code>ResourceManager</code> 在接收到上述 RPC 调用后，会通过 <code>SlotManager</code> 完成具体的工作。</p>
<h4 id="动态资源管理"><a href="#动态资源管理" class="headerlink" title="动态资源管理"></a>动态资源管理</h4><p><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=65147077" target="_blank" rel="noopener">FLIP-6</a> 引入的一个重要特性是，<code>ResourceManager</code> 支持动态管理 <code>TaskExecutor</code> 计算资源，从而可以更好地和 Yarn、 Mesos、Kubernetes 等框架进行集成，动态管理计算资源。下面我们来介绍下这个特性是怎么实现的。</p>
<p>前面在介绍 <a href="#SlotManager">SlotManager</a> 的时候提到：如果当前注册的 slot 不能满足 slot request 的要求，那么 <code>SlotManager</code> 会通过 <code>ResourceActions#allocateResource</code> 回调告知 <code>ResourceManager</code>；当一个 <code>SlotManager</code> 检查到一个 <code>TaskExecutor</code> 长时间处于 Idle 状态是，也会通过 <code>ResourceActions#releaseResource</code> 回调告知 <code>ResourceManager</code>。通过这两个回调， <code>ResourceManager</code> 就可以动态申请资源及释放资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ResourceManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceActionsImpl</span> <span class="keyword">implements</span> <span class="title">ResourceActions</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseResource</span><span class="params">(InstanceID instanceId, Exception cause)</span> </span>&#123;</span><br><span class="line">      validateRunsInMainThread();</span><br><span class="line">      <span class="comment">//释放资源</span></span><br><span class="line">      ResourceManager.<span class="keyword">this</span>.releaseResource(instanceId, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;ResourceProfile&gt; <span class="title">allocateResource</span><span class="params">(ResourceProfile resourceProfile)</span> </span>&#123;</span><br><span class="line">      validateRunsInMainThread();</span><br><span class="line">      <span class="comment">//申请新的资源，具体行为和不同的 ResourceManager 的实现有关。其返回的列表相当于是承诺即将分配的资源</span></span><br><span class="line">      <span class="keyword">return</span> startNewWorker(resourceProfile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyAllocationFailure</span><span class="params">(JobID jobId, AllocationID allocationId, Exception cause)</span> </span>&#123;</span><br><span class="line">      validateRunsInMainThread();</span><br><span class="line">      JobManagerRegistration jobManagerRegistration = jobManagerRegistrations.get(jobId);</span><br><span class="line">      <span class="keyword">if</span> (jobManagerRegistration != <span class="keyword">null</span>) &#123;</span><br><span class="line">        jobManagerRegistration.getJobManagerGateway().notifyAllocationFailure(allocationId, cause);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">releaseResource</span><span class="params">(InstanceID instanceId, Exception cause)</span> </span>&#123;</span><br><span class="line">    WorkerType worker = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Improve performance by having an index on the instanceId</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;ResourceID, WorkerRegistration&lt;WorkerType&gt;&gt; entry : taskExecutors.entrySet()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.getValue().getInstanceID().equals(instanceId)) &#123;</span><br><span class="line">        worker = entry.getValue().getWorker();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (worker != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//停止对应的worker，具体行为和不同的 ResourceManager 的实现有关</span></span><br><span class="line">      <span class="keyword">if</span> (stopWorker(worker)) &#123;</span><br><span class="line">        closeTaskManagerConnection(worker.getResourceID(), cause);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"Worker &#123;&#125; could not be stopped."</span>, worker.getResourceID());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unregister in order to clean up potential left over state</span></span><br><span class="line">      slotManager.unregisterTaskManager(instanceId);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Collection&lt;ResourceProfile&gt; <span class="title">startNewWorker</span><span class="params">(ResourceProfile resourceProfile)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">stopWorker</span><span class="params">(WorkerType worker)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startNewWorker</code> 和 <code>stopWorker</code> 这两个抽象方法是实现动态申请和释放资源的关键。对于 Standalone 模式而言，<code>TaskExecutor</code> 是固定的，不支持动态启动和释放；而对于在 Yarn 上运行的 Flink， <code>YarnResourceManager</code> 中这两个方法的具体实现就涉及到启动新的 container 和释放已经申请的 container。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">YarnResourceManager</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Collection&lt;ResourceProfile&gt; <span class="title">startNewWorker</span><span class="params">(ResourceProfile resourceProfile)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkArgument(</span><br><span class="line">      ResourceProfile.UNKNOWN.equals(resourceProfile),</span><br><span class="line">      <span class="string">"The YarnResourceManager does not support custom ResourceProfiles yet. It assumes that all containers have the same resources."</span>);</span><br><span class="line">    <span class="comment">//申请 container</span></span><br><span class="line">    requestYarnContainer();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> slotsPerWorker;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">stopWorker</span><span class="params">(<span class="keyword">final</span> YarnWorkerNode workerNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Container container = workerNode.getContainer();</span><br><span class="line">    log.info(<span class="string">"Stopping container &#123;&#125;."</span>, container.getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      nodeManagerClient.stopContainer(container.getId(), container.getNodeId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Exception e) &#123;</span><br><span class="line">      log.warn(<span class="string">"Error while calling YARN Node Manager to stop container"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放container</span></span><br><span class="line">    resourceManagerClient.releaseAssignedContainer(container.getId());</span><br><span class="line">    workerNodeMap.remove(workerNode.getResourceID());</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="JobManager-中-Slot-的管理"><a href="#JobManager-中-Slot-的管理" class="headerlink" title="JobManager 中 Slot 的管理"></a>JobManager 中 Slot 的管理</h2><p>相比于 <code>TaskExecutor</code> 和 <code>ResourceManager</code>, <code>JobManager</code> 中资源管理的部分可能要相对更为复杂一下，这主要是由于 Flink 允许通过 <code>SlotSharingGroup</code> 和 <code>CoLocationGroup</code> 约束使得多个子任务在相同的的 slot 中运行。在 <code>JobMaster</code> 中，主要通过 <code>SlotPool</code> 和 <code>ResourceManager</code> 及 <code>TaskExecutor</code> 进行通信，并管理分配给当前 <code>JobMaster</code> 的 slot；而具体到当前 Job 的所有子任务的调度和资源分配，则主要依赖 <code>Scheduler</code> 和 <code>SlotSharingManager</code> 。</p>
<h3 id="PhysicalSlot-vs-LogicalSlot-vs-MultiTaskSlot"><a href="#PhysicalSlot-vs-LogicalSlot-vs-MultiTaskSlot" class="headerlink" title="PhysicalSlot vs. LogicalSlot vs. MultiTaskSlot"></a>PhysicalSlot vs. LogicalSlot vs. MultiTaskSlot</h3><p>首先要区分一下 <code>PhysicalSlot</code> 和 <code>LogicalSlot</code> 这两个概念：<code>PhysicalSlot</code> 表征的是物理意义上 <code>TaskExecutor</code> 上的一个 slot，而 <code>LogicalSlot</code> 表征逻辑上的一个 slot，一个 task 可以部署到一个 <code>LogicalSlot</code> 上，但它和物理上一个具体的 slot 并不是意义对应的。由于资源共享等机制的存在，多个 <code>LogicalSlot</code> 可能被映射到同一个 <code>PhysicalSlot</code> 上。</p>
<p><code>PhysicalSlot</code> 接口唯一的实现类是 <code>AllocatedSlot</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PhysicalSlot</span> <span class="keyword">extends</span> <span class="title">SlotContext</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryAssignPayload</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Payload which can be assigned to an &#123;<span class="doctag">@link</span> AllocatedSlot&#125;.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Payload</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * Releases the payload</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * <span class="doctag">@param</span> cause of the payload release</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">release</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AllocatedSlot</span> <span class="keyword">implements</span> <span class="title">PhysicalSlot</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The ID under which the slot is allocated. Uniquely identifies the slot. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AllocationID allocationId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The location information of the TaskManager to which this slot belongs */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TaskManagerLocation taskManagerLocation;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The resource profile of the slot provides */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceProfile resourceProfile;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** RPC gateway to call the TaskManager that holds this slot */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> TaskManagerGateway taskManagerGateway;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The number of the slot on the TaskManager to which slot belongs. Purely informational. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> physicalSlotNumber;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AtomicReference&lt;Payload&gt; payloadReference;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>LogicSlot</code> 接口和它的实现类 <code>SingleLogicalSlot</code>:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LogicalSlot</span> </span>&#123;</span><br><span class="line">  <span class="function">TaskManagerLocation <span class="title">getTaskManagerLocation</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">TaskManagerGateway <span class="title">getTaskManagerGateway</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getPhysicalSlotNumber</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">AllocationID <span class="title">getAllocationId</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">SlotRequestId <span class="title">getSlotRequestId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">Locality <span class="title">getLocality</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  CompletableFuture&lt;?&gt; releaseSlot(<span class="meta">@Nullable</span> Throwable cause);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">SlotSharingGroupId <span class="title">getSlotSharingGroupId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">tryAssignPayload</span><span class="params">(Payload payload)</span></span>;</span><br><span class="line">  <span class="function">Payload <span class="title">getPayload</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Payload for a logical slot.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="class"><span class="keyword">interface</span> <span class="title">Payload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fail</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">    CompletableFuture&lt;?&gt; getTerminalStateFuture();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleLogicalSlot</span> <span class="keyword">implements</span> <span class="title">LogicalSlot</span>, <span class="title">PhysicalSlot</span>.<span class="title">Payload</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotRequestId slotRequestId;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotContext slotContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// null if the logical slot does not belong to a slot sharing group, otherwise non-null</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotSharingGroupId slotSharingGroupId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// locality of this slot wrt the requested preferred locations</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Locality locality;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// owner of this slot to which it is returned upon release</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotOwner slotOwner;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CompletableFuture&lt;Void&gt; releaseFuture;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> State state;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// LogicalSlot.Payload of this slot</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Payload payload;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，<code>SingleLogicalSlot</code> 实现了 <code>PhysicalSlot.Payload</code> 接口，就是说说 <code>SingleLogicalSlot</code> 可以作为 payload 被分配给 <code>PhysicalSlot</code>。类似地， <code>LogicalSlot</code> 同样规定了其所能承载的 payload , <code>LogicalSlot.Payload</code> 接口的实现类是 <code>Execution</code>，也就是需要被调度执行的一个 task。</p>
<p>同样需要关注一下 <code>AllocationID</code> 和 <code>SlotRequestID</code> 的区别：<code>AllocationID</code> 是用来区分物理内存的分配，它总是和 <code>AllocatedSlot</code> 向关联的；而 <code>SlotRequestID</code> 是任务调度执行的时候请求 <code>LogicalSlot</code>，是和 <code>LogicalSlot</code> 关联的。</p>
<p>我们已经知道，为了实现 slot 资源的共享，我们需要把多个 <code>LogicalSlot</code> 映射到同一个 <code>PhysicalSlot</code> 上，那么这个映射是如何实现的呢？这里就需要引入 <code>PhysicalSlot.Payload</code> 接口的另一个实现：<code>SlotSharingManager</code> 的内部类 <code>SlotSharingManager.MultiTaskSlot</code>。</p>
<p><code>MultiTaskSlot</code> 和 <code>SingleTaskSlot</code> 的公共父类是 <code>TaskSlot</code>，通过构造一个由 <code>TaskSlot</code> 构成的树形结构来实现 slot 共享和 <code>CoLocationGroup</code> 的强制约束。<code>MultiTaskSlot</code> 对应树形结构的内部节点，它可以包含多个子节点（可以是<code>MultiTaskSlot</code>，也可以是 <code>SingleTaskSlot</code>）；而 <code>SingleTaskSlot</code> 对应树形结构的叶子结点。</p>
<p>树的根节点是 <code>MultiTaskSlot</code>，根节点会被分配一个 <code>SlotContext</code>，<code>SlotContext</code> 代表了其所分配的 <code>TaskExecutor</code> 中的一个物理 slot，这棵树中所有的任务都会在同一个 slot 中运行。一个 <code>MultiTaskSlot</code> 可以包含多个叶子节点，只要用来区分这些叶子节点 <code>TaskSlot</code> 的 <code>AbstractID</code> 不同即可（可能是 <code>JobVertexID</code>，也可能是 CoLocationGroup 的 ID）。</p>
<p>先来看一下 <code>TaskSlot</code> 封装的两个 ID，其一是 <code>SlotRequestId</code>，其二是 <code>AbstractID</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskSlot</span> </span>&#123;</span><br><span class="line">    <span class="comment">// every TaskSlot has an associated slot request id</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SlotRequestId slotRequestId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// all task slots except for the root slots have a group id assigned</span></span><br><span class="line">    <span class="comment">// 除了 root 节点，每个节点都有一个 groupId 用来区分一个 TaskSlot。可能是 JobVertexID，也可能是 CoLocationGroup 的 ID</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AbstractID groupId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(AbstractID groupId)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Objects.equals(<span class="keyword">this</span>.groupId, groupId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Throwable cause)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>MultiTaskSlot</code> 继承了 <code>TaskSlot</code>，<code>MultiTaskSlot</code> 可以有多个子节点。<code>MultiTaskSlot</code> 可以作为根节点，也可以作为内部节点。<code>MultiTaskSlot</code> 也实现了 <code>PhysicalSlot.Payload</code> 接口，可以分配给 <code>PhysicalSlot</code>（在作为根节点的情况下）:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiTaskSlot</span> <span class="keyword">extends</span> <span class="title">TaskSlot</span> <span class="keyword">implements</span> <span class="title">PhysicalSlot</span>.<span class="title">Payload</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;AbstractID, TaskSlot&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// the root node has its parent set to null</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultiTaskSlot parent;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// underlying allocated slot</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompletableFuture&lt;? extends SlotContext&gt; slotContextFuture;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// slot request id of the allocated slot</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SlotRequestId allocatedSlotRequestId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>SingleTaskSlot</code> 只能作为叶子节点，它拥有一个 <code>LogicalSlot</code>，后续可以用来分配具体的 task：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTaskSlot</span> <span class="keyword">extends</span> <span class="title">TaskSlot</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MultiTaskSlot parent;</span><br><span class="line"><span class="comment">// future containing a LogicalSlot which is completed once the underlying SlotContext future is completed</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompletableFuture&lt;SingleLogicalSlot&gt; singleLogicalSlotFuture;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTaskSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">				SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">				AbstractID groupId,</span></span></span><br><span class="line"><span class="function"><span class="params">				MultiTaskSlot parent,</span></span></span><br><span class="line"><span class="function"><span class="params">				Locality locality)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(slotRequestId, groupId);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.parent = Preconditions.checkNotNull(parent);</span><br><span class="line"></span><br><span class="line">      Preconditions.checkNotNull(locality);</span><br><span class="line">      singleLogicalSlotFuture = parent.getSlotContextFuture()</span><br><span class="line">        .thenApply(</span><br><span class="line">          (SlotContext slotContext) -&gt; &#123;</span><br><span class="line">            <span class="comment">//在父节点被分配了 PhysicalSlot 后，创建 SingleLogicalSlot</span></span><br><span class="line">            LOG.trace(<span class="string">"Fulfill single task slot [&#123;&#125;] with slot [&#123;&#125;]."</span>, slotRequestId, slotContext.getAllocationId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleLogicalSlot(</span><br><span class="line">              slotRequestId,</span><br><span class="line">              slotContext,</span><br><span class="line">              slotSharingGroupId,</span><br><span class="line">              locality,</span><br><span class="line">              slotOwner);</span><br><span class="line">          &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>更具体一点地说，对于普通的 <code>SlotShargingGroup</code> 的约束，形成的树形结构是: <code>MultiTaskSlot</code> 作为根节点，多个 <code>SingleTaskSlot</code> 作为叶子节点，这些叶子节点分别代表不同的任务，用来区分它们的 <code>JobVertextID</code> 不同。对于 <code>CoLocationGroup</code> 强制约束，会在 <code>MultiTaskSlot</code> 根节点的下一级创建一个 <code>MultiTaskSlot</code> 节点（用 CoLocationGroup ID） 来区分，同一个 <code>CoLocationGroup</code> 约束下的子任务进一步作为第二层 <code>MultiTaskSlot</code> 的叶子节点。</p>
<h3 id="SlotPool"><a href="#SlotPool" class="headerlink" title="SlotPool"></a>SlotPool</h3><p>JobManager 使用 <code>SlotPool</code> 来向 <code>ResourceManager</code> 申请 slot， 并管理所有分配给该 JobManager 的 slots。这一节所说的 slot 指的都是 physical slot。</p>
<p><code>SlotPool</code> 接口的唯一实现类是 <code>SlotPoolImpl</code>，先来看一下几个关键的成员变量：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotPoolImpl</span> <span class="keyword">implements</span> <span class="title">SlotPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">/** The book-keeping of all allocated slots. */</span></span><br><span class="line">  <span class="comment">//所有分配给当前 JobManager 的 slots</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AllocatedSlots allocatedSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The book-keeping of all available slots. */</span></span><br><span class="line">  <span class="comment">//所有可用的 slots（已经分配给该 JobManager，但还没有装载 payload）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AvailableSlots availableSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** All pending requests waiting for slots. */</span></span><br><span class="line">  <span class="comment">//所有处于等待状态的slot request（已经发送请求给 ResourceManager）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> DualKeyMap&lt;SlotRequestId, AllocationID, PendingRequest&gt; pendingRequests;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The requests that are waiting for the resource manager to be connected. */</span></span><br><span class="line">  <span class="comment">//处于等待状态的 slot request （还没有发送请求给 ResourceManager，此时没有和 ResourceManager 建立连接）</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> HashMap&lt;SlotRequestId, PendingRequest&gt; waitingForResourceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>每一个分配给 <code>SlotPool</code> 的 slot 都通过 <code>AllocationID</code> 进行唯一区分。 <code>getAvailableSlotsInformation</code> 方法可以获取当前可用的 slots（还没有 payload），而后可以通过 <code>allocateAvailableSlot</code> 将特定 <code>AllocationID</code> 关联的 <code>AlocatedSlot</code> 分配给指定的 <code>SlotRequestID</code> 对应的请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotPoolImpl</span> <span class="keyword">implements</span> <span class="title">SlotPool</span> </span>&#123;</span><br><span class="line">  <span class="comment">//列出当前可用的 slot</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Collection&lt;SlotInfo&gt; <span class="title">getAvailableSlotsInformation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> availableSlots.listSlotInfo();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将 allocationID 关联的 slot 分配给 slotRequestId 对应的请求</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Optional&lt;PhysicalSlot&gt; <span class="title">allocateAvailableSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull AllocationID allocationID)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从 availableSlots 中移除</span></span><br><span class="line">    AllocatedSlot allocatedSlot = availableSlots.tryRemove(allocationID);</span><br><span class="line">    <span class="keyword">if</span> (allocatedSlot != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//加入已分配的映射关系中</span></span><br><span class="line">      allocatedSlots.add(slotRequestId, allocatedSlot);</span><br><span class="line">      <span class="keyword">return</span> Optional.of(allocatedSlot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前没有可用的 slot，则可以要求 <code>SlotPool</code> 向 <code>ResourceManager</code> 进行申请:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotPoolImpl</span> <span class="keyword">implements</span> <span class="title">SlotPool</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//向RM申请新的 slot</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletableFuture&lt;PhysicalSlot&gt; <span class="title">requestNewAllocatedSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull ResourceProfile resourceProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time timeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> requestNewAllocatedSlotInternal(slotRequestId, resourceProfile, timeout)</span><br><span class="line">      .thenApply((Function.identity()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> CompletableFuture&lt;AllocatedSlot&gt; <span class="title">requestNewAllocatedSlotInternal</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull ResourceProfile resourceProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull Time timeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造哟个 PendingRequest</span></span><br><span class="line">    <span class="keyword">final</span> PendingRequest pendingRequest = <span class="keyword">new</span> PendingRequest(</span><br><span class="line">      slotRequestId,</span><br><span class="line">      resourceProfile);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// register request timeout</span></span><br><span class="line">    FutureUtils</span><br><span class="line">      .orTimeout(</span><br><span class="line">        pendingRequest.getAllocatedSlotFuture(),</span><br><span class="line">        timeout.toMilliseconds(),</span><br><span class="line">        TimeUnit.MILLISECONDS,</span><br><span class="line">        componentMainThreadExecutor)</span><br><span class="line">      .whenComplete(</span><br><span class="line">        (AllocatedSlot ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">          <span class="keyword">if</span> (throwable <span class="keyword">instanceof</span> TimeoutException) &#123;</span><br><span class="line">            <span class="comment">//超时处理</span></span><br><span class="line">            timeoutPendingSlotRequest(slotRequestId);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (resourceManagerGateway == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果当前没有和 RM 建立连接，则需要等待 RM 建立连接</span></span><br><span class="line">      stashRequestWaitingForResourceManager(pendingRequest);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//当前已经和 RM 建立了连接，向 RM 申请slot</span></span><br><span class="line">      requestSlotFromResourceManager(resourceManagerGateway, pendingRequest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pendingRequest.getAllocatedSlotFuture();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果当前没有和 RM 建立连接，则需要等待 RM 建立连接，加入 waitingForResourceManager</span></span><br><span class="line">  <span class="comment">//一旦和 RM 建立连接，就会向 RM 发送请求</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">stashRequestWaitingForResourceManager</span><span class="params">(<span class="keyword">final</span> PendingRequest pendingRequest)</span> </span>&#123;</span><br><span class="line">    log.info(<span class="string">"Cannot serve slot request, no ResourceManager connected. "</span> +</span><br><span class="line">        <span class="string">"Adding as pending request [&#123;&#125;]"</span>,  pendingRequest.getSlotRequestId());</span><br><span class="line">    waitingForResourceManager.put(pendingRequest.getSlotRequestId(), pendingRequest);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//当前已经和 RM 建立了连接，向 RM 申请slot</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestSlotFromResourceManager</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> ResourceManagerGateway resourceManagerGateway,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> PendingRequest pendingRequest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//生成一个 AllocationID，后面分配的 slot 通过 AllocationID 区分</span></span><br><span class="line">    <span class="keyword">final</span> AllocationID allocationId = <span class="keyword">new</span> AllocationID();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加到等待处理的请求中</span></span><br><span class="line">    pendingRequests.put(pendingRequest.getSlotRequestId(), allocationId, pendingRequest);</span><br><span class="line"></span><br><span class="line">    pendingRequest.getAllocatedSlotFuture().whenComplete(</span><br><span class="line">      (AllocatedSlot allocatedSlot, Throwable throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (throwable != <span class="keyword">null</span> || !allocationId.equals(allocatedSlot.getAllocationId())) &#123;</span><br><span class="line">          <span class="comment">// cancel the slot request if there is a failure or if the pending request has</span></span><br><span class="line">          <span class="comment">// been completed with another allocated slot</span></span><br><span class="line">          resourceManagerGateway.cancelSlotRequest(allocationId);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 RPC 调用向 RM 请求 slot，RM 的处理流程在前面已经介绍过</span></span><br><span class="line">    CompletableFuture&lt;Acknowledge&gt; rmResponse = resourceManagerGateway.requestSlot(</span><br><span class="line">      jobMasterId,</span><br><span class="line">      <span class="keyword">new</span> SlotRequest(jobId, allocationId, pendingRequest.getResourceProfile(), jobManagerAddress),</span><br><span class="line">      rpcTimeout);</span><br><span class="line"></span><br><span class="line">    FutureUtils.whenCompleteAsyncIfNotDone(</span><br><span class="line">      rmResponse,</span><br><span class="line">      componentMainThreadExecutor,</span><br><span class="line">      (Acknowledge ignored, Throwable failure) -&gt; &#123;</span><br><span class="line">        <span class="comment">// on failure, fail the request future</span></span><br><span class="line">        <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">          slotRequestToResourceManagerFailed(pendingRequest.getSlotRequestId(), failure);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦 <code>ResourceManager</code> 完成了 slot 分配的处理流程，会将分配的 slot 提供给 JobManager，最终 <code>SlotPool.offerSlots()</code> 方法会被调用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotPoolImpl</span> </span>&#123;</span><br><span class="line">  <span class="comment">//向 SlotPool 分配 slot，返回已经被接受的 slot 集合。没有被接受的 slot，RM 可以分配给其他 Job。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Collection&lt;SlotOffer&gt; <span class="title">offerSlots</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			TaskManagerLocation taskManagerLocation,</span></span></span><br><span class="line"><span class="function"><span class="params">			TaskManagerGateway taskManagerGateway,</span></span></span><br><span class="line"><span class="function"><span class="params">			Collection&lt;SlotOffer&gt; offers)</span> </span>&#123;</span><br><span class="line">    ArrayList&lt;SlotOffer&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;(offers.size());</span><br><span class="line">    <span class="comment">//SlotPool 可以确定是否接受每一个 slot</span></span><br><span class="line">    <span class="keyword">for</span> (SlotOffer offer : offers) &#123;</span><br><span class="line">      <span class="keyword">if</span> (offerSlot(</span><br><span class="line">        taskManagerLocation,</span><br><span class="line">        taskManagerGateway,</span><br><span class="line">        offer)) &#123;</span><br><span class="line"></span><br><span class="line">        result.add(offer);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">offerSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> TaskManagerLocation taskManagerLocation,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> TaskManagerGateway taskManagerGateway,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="keyword">final</span> SlotOffer slotOffer)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if this TaskManager is valid</span></span><br><span class="line">    <span class="keyword">final</span> ResourceID resourceID = taskManagerLocation.getResourceID();</span><br><span class="line">    <span class="keyword">final</span> AllocationID allocationID = slotOffer.getAllocationId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!registeredTaskManagers.contains(resourceID)) &#123;</span><br><span class="line">      log.debug(<span class="string">"Received outdated slot offering [&#123;&#125;] from unregistered TaskManager: &#123;&#125;"</span>,</span><br><span class="line">          slotOffer.getAllocationId(), taskManagerLocation);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether we have already using this slot</span></span><br><span class="line">    <span class="comment">// 如果当前 slot 关联的 AllocationID 已经在 SlotPool 中出现</span></span><br><span class="line">    AllocatedSlot existingSlot;</span><br><span class="line">    <span class="keyword">if</span> ((existingSlot = allocatedSlots.get(allocationID)) != <span class="keyword">null</span> ||</span><br><span class="line">      (existingSlot = availableSlots.get(allocationID)) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// we need to figure out if this is a repeated offer for the exact same slot,</span></span><br><span class="line">      <span class="comment">// or another offer that comes from a different TaskManager after the ResourceManager</span></span><br><span class="line">      <span class="comment">// re-tried the request</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">// we write this in terms of comparing slot IDs, because the Slot IDs are the identifiers of</span></span><br><span class="line">      <span class="comment">// the actual slots on the TaskManagers</span></span><br><span class="line">      <span class="comment">// Note: The slotOffer should have the SlotID</span></span><br><span class="line">      <span class="keyword">final</span> SlotID existingSlotId = existingSlot.getSlotId();</span><br><span class="line">      <span class="keyword">final</span> SlotID newSlotId = <span class="keyword">new</span> SlotID(taskManagerLocation.getResourceID(), slotOffer.getSlotIndex());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (existingSlotId.equals(newSlotId)) &#123;</span><br><span class="line">        <span class="comment">//这个 slot 在之前已经被 SlotPool 接受了，相当于 TaskExecutor 发送了一个重复的 offer</span></span><br><span class="line">        log.info(<span class="string">"Received repeated offer for slot [&#123;&#125;]. Ignoring."</span>, allocationID);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return true here so that the sender will get a positive acknowledgement to the retry</span></span><br><span class="line">        <span class="comment">// and mark the offering as a success</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//已经有一个其他的 AllocatedSlot 和 这个 AllocationID 关联了，因此不能接受当前的这个 slot</span></span><br><span class="line">        <span class="comment">// the allocation has been fulfilled by another slot, reject the offer so the task executor</span></span><br><span class="line">        <span class="comment">// will offer the slot to the resource manager</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个 slot 关联的 AllocationID 此前没有出现过</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新建一个 AllocatedSlot 对象，表示新分配的 slot</span></span><br><span class="line">    <span class="keyword">final</span> AllocatedSlot allocatedSlot = <span class="keyword">new</span> AllocatedSlot(</span><br><span class="line">      allocationID,</span><br><span class="line">      taskManagerLocation,</span><br><span class="line">      slotOffer.getSlotIndex(),</span><br><span class="line">      slotOffer.getResourceProfile(),</span><br><span class="line">      taskManagerGateway);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether we have request waiting for this slot</span></span><br><span class="line">    <span class="comment">// 检查是否有一个 request 和 这个 AllocationID 关联</span></span><br><span class="line">    PendingRequest pendingRequest = pendingRequests.removeKeyB(allocationID);</span><br><span class="line">    <span class="keyword">if</span> (pendingRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// we were waiting for this!</span></span><br><span class="line">      <span class="comment">//有一个pending request 正在等待这个 slot</span></span><br><span class="line">      allocatedSlots.add(pendingRequest.getSlotRequestId(), allocatedSlot);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//尝试去完成那个等待的请求</span></span><br><span class="line">      <span class="keyword">if</span> (!pendingRequest.getAllocatedSlotFuture().complete(allocatedSlot)) &#123;</span><br><span class="line">        <span class="comment">// we could not complete the pending slot future --&gt; try to fulfill another pending request</span></span><br><span class="line">        <span class="comment">//失败了</span></span><br><span class="line">        allocatedSlots.remove(pendingRequest.getSlotRequestId());</span><br><span class="line">        <span class="comment">//尝试去满足其他在等待的请求</span></span><br><span class="line">        tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.debug(<span class="string">"Fulfilled slot request [&#123;&#125;] with allocated slot [&#123;&#125;]."</span>, pendingRequest.getSlotRequestId(), allocationID);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//没有请求在等待这个slot，可能请求已经被满足了</span></span><br><span class="line">      <span class="comment">// we were actually not waiting for this:</span></span><br><span class="line">      <span class="comment">//   - could be that this request had been fulfilled</span></span><br><span class="line">      <span class="comment">//   - we are receiving the slots from TaskManagers after becoming leaders</span></span><br><span class="line">      <span class="comment">//尝试去满足其他在等待的请求</span></span><br><span class="line">      tryFulfillSlotRequestOrMakeAvailable(allocatedSlot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we accepted the request in any case. slot will be released after it idled for</span></span><br><span class="line">    <span class="comment">// too long and timed out</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一旦有新的可用的 <code>AllocatedSlot</code> 的时候，<code>SlotPoolImpl</code> 会尝试用这个 <code>AllocatedSlot</code> 去提前满足其他还在等待响应的请求：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotManagerImpl</span> <span class="keyword">implements</span> <span class="title">SlotPool</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">tryFulfillSlotRequestOrMakeAvailable</span><span class="params">(AllocatedSlot allocatedSlot)</span> </span>&#123;</span><br><span class="line">    Preconditions.checkState(!allocatedSlot.isUsed(), <span class="string">"Provided slot is still in use."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查找和当前 AllocatedSlot 的计算资源相匹配的还在等待的请求</span></span><br><span class="line">    <span class="keyword">final</span> PendingRequest pendingRequest = pollMatchingPendingRequest(allocatedSlot);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingRequest != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果有匹配的请求，那么将 AllocatedSlot 分配给等待的请求</span></span><br><span class="line">      log.debug(<span class="string">"Fulfilling pending slot request [&#123;&#125;] early with returned slot [&#123;&#125;]"</span>,</span><br><span class="line">        pendingRequest.getSlotRequestId(), allocatedSlot.getAllocationId());</span><br><span class="line"></span><br><span class="line">      allocatedSlots.add(pendingRequest.getSlotRequestId(), allocatedSlot);</span><br><span class="line">      pendingRequest.getAllocatedSlotFuture().complete(allocatedSlot);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果没有，那么这个 AllocatedSlot 变成 available 的</span></span><br><span class="line">      log.debug(<span class="string">"Adding returned slot [&#123;&#125;] to available slots"</span>, allocatedSlot.getAllocationId());</span><br><span class="line">      availableSlots.add(allocatedSlot, clock.relativeTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PendingRequest <span class="title">pollMatchingPendingRequest</span><span class="params">(<span class="keyword">final</span> AllocatedSlot slot)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ResourceProfile slotResources = slot.getResourceProfile();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try the requests sent to the resource manager first</span></span><br><span class="line">    <span class="keyword">for</span> (PendingRequest request : pendingRequests.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (slotResources.isMatching(request.getResourceProfile())) &#123;</span><br><span class="line">        pendingRequests.removeKeyA(request.getSlotRequestId());</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// try the requests waiting for a resource manager connection next</span></span><br><span class="line">    <span class="keyword">for</span> (PendingRequest request : waitingForResourceManager.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (slotResources.isMatching(request.getResourceProfile())) &#123;</span><br><span class="line">        waitingForResourceManager.remove(request.getSlotRequestId());</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no request pending, or no request matches</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>slotPool</code> 启动的时候会开启一个定时调度的任务，周期性地检查空闲的 slot，如果 slot 空闲时间过长，会将该 slot 归还给 TaskManager:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotPoolImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkIdleSlot</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The timestamp in SlotAndTimestamp is relative</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> currentRelativeTimeMillis = clock.relativeTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> List&lt;AllocatedSlot&gt; expiredSlots = <span class="keyword">new</span> ArrayList&lt;&gt;(availableSlots.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (SlotAndTimestamp slotAndTimestamp : availableSlots.availableSlots.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (currentRelativeTimeMillis - slotAndTimestamp.timestamp &gt; idleSlotTimeout.toMilliseconds()) &#123;</span><br><span class="line">        expiredSlots.add(slotAndTimestamp.slot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> FlinkException cause = <span class="keyword">new</span> FlinkException(<span class="string">"Releasing idle slot."</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (AllocatedSlot expiredSlot : expiredSlots) &#123;</span><br><span class="line">      <span class="keyword">final</span> AllocationID allocationID = expiredSlot.getAllocationId();</span><br><span class="line">      <span class="keyword">if</span> (availableSlots.tryRemove(allocationID) != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将空闲的 slot 归还给 TaskManager</span></span><br><span class="line">        log.info(<span class="string">"Releasing idle slot [&#123;&#125;]."</span>, allocationID);</span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;Acknowledge&gt; freeSlotFuture = expiredSlot.getTaskManagerGateway().freeSlot(</span><br><span class="line">          allocationID,</span><br><span class="line">          cause,</span><br><span class="line">          rpcTimeout);</span><br><span class="line"></span><br><span class="line">        FutureUtils.whenCompleteAsyncIfNotDone(</span><br><span class="line">          freeSlotFuture,</span><br><span class="line">          componentMainThreadExecutor,</span><br><span class="line">          (Acknowledge ignored, Throwable throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (registeredTaskManagers.contains(expiredSlot.getTaskManagerId())) &#123;</span><br><span class="line">                log.debug(<span class="string">"Releasing slot [&#123;&#125;] of registered TaskExecutor &#123;&#125; failed. "</span> +</span><br><span class="line">                    <span class="string">"Trying to fulfill a different slot request."</span>, allocationID, expiredSlot.getTaskManagerId(),</span><br><span class="line">                  throwable);</span><br><span class="line">                tryFulfillSlotRequestOrMakeAvailable(expiredSlot);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                log.debug(<span class="string">"Releasing slot [&#123;&#125;] failed and owning TaskExecutor &#123;&#125; is no "</span> +</span><br><span class="line">                  <span class="string">"longer registered. Discarding slot."</span>, allocationID, expiredSlot.getTaskManagerId());</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    scheduleRunAsync(<span class="keyword">this</span>::checkIdleSlot, idleSlotTimeout);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Scheduler-和-SlotSharingManager"><a href="#Scheduler-和-SlotSharingManager" class="headerlink" title="Scheduler 和 SlotSharingManager"></a>Scheduler 和 SlotSharingManager</h3><p>我们已经了解，<code>SlotPool</code> 主要负责的是分配给当前 <code>JobMaster</code> 的 PhysicalSlot 的管理。但是，具体到每一个 Task 所需要的计算资源的调度和管理，是按照 <code>LogicalSlot</code> 进行组织的，不同的 Task 所分配的 LogicalSlot 各不相同，但它们底层的 PhysicalSlot 可能是同一个。主要的逻辑都封装在 <code>SlotSharingManager</code> 和 <code>Scheduler</code> 中。</p>
<p>前面已经提到过，通过构造一个由 <code>TaskSlot</code> 构成的树形结构可以实现 <code>SlotSharingGroup</code> 内的资源共享以及 <code>CoLocationGroup</code> 的强制约束，这主要就是通过 <code>SlotSharingManager</code> 来完成的。每一个 <code>SlotSharingGroup</code> 都会有一个与其对应的 <code>SlotSharingManager</code>。</p>
<p><code>SlotSharingManager</code> 主要的成员变量如下，除了关联的 <code>SlotSharingGroupId</code> 以外，最重要的就是用于管理 <code>TaskSlot</code> 的三个 Map ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotSharingManager</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotSharingGroupId slotSharingGroupId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Actions to release allocated slots after a complete multi task slot hierarchy has been released. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> AllocatedSlotActions allocatedSlotActions;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Owner of the slots to which to return them when they are released from the outside. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotOwner slotOwner;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//所有的 TaskSlot，包括 root 和 inner 和 leaf</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;SlotRequestId, TaskSlot&gt; allTaskSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//root MultiTaskSlot，但底层的 Physical Slot 还没有分配好</span></span><br><span class="line">  <span class="comment">/** Root nodes which have not been completed because the allocated slot is still pending. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;SlotRequestId, MultiTaskSlot&gt; unresolvedRootSlots;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//root MultiTaskSlot，底层的 physical slot 也已经分配好了，按照两层 map 的方式组织，</span></span><br><span class="line">  <span class="comment">//可以通过已分配的 Physical slot 所在的TaskManager 的位置进行查找</span></span><br><span class="line">  <span class="comment">/** Root nodes which have been completed (the underlying allocated slot has been assigned). */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;TaskManagerLocation, Map&lt;AllocationID, MultiTaskSlot&gt;&gt; resolvedRootSlots;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当需要构造一个新的 <code>TaskSlot</code> 树的时候，需要调用 <code>createRootSlot</code> 来创建根节点：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotSharingManager</span> </span>&#123;</span><br><span class="line">  <span class="function">MultiTaskSlot <span class="title">createRootSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">			CompletableFuture&lt;? extends SlotContext&gt; slotContextFuture,</span></span></span><br><span class="line"><span class="function"><span class="params">			SlotRequestId allocatedSlotRequestId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MultiTaskSlot rootMultiTaskSlot = <span class="keyword">new</span> MultiTaskSlot(</span><br><span class="line">      slotRequestId,</span><br><span class="line">      slotContextFuture,</span><br><span class="line">      allocatedSlotRequestId);</span><br><span class="line"></span><br><span class="line">    LOG.debug(<span class="string">"Create multi task slot [&#123;&#125;] in slot [&#123;&#125;]."</span>, slotRequestId, allocatedSlotRequestId);</span><br><span class="line"></span><br><span class="line">    allTaskSlots.put(slotRequestId, rootMultiTaskSlot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先加入到 unresolvedRootSlots 中</span></span><br><span class="line">    unresolvedRootSlots.put(slotRequestId, rootMultiTaskSlot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// add the root node to the set of resolved root nodes once the SlotContext future has</span></span><br><span class="line">    <span class="comment">// been completed and we know the slot's TaskManagerLocation</span></span><br><span class="line">    slotContextFuture.whenComplete(</span><br><span class="line">      (SlotContext slotContext, Throwable throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (slotContext != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//一旦physical slot完成分配，就从 unresolvedRootSlots 中移除，加入到 resolvedRootSlots 中</span></span><br><span class="line">          <span class="keyword">final</span> MultiTaskSlot resolvedRootNode = unresolvedRootSlots.remove(slotRequestId);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (resolvedRootNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> AllocationID allocationId = slotContext.getAllocationId();</span><br><span class="line">            LOG.trace(<span class="string">"Fulfill multi task slot [&#123;&#125;] with slot [&#123;&#125;]."</span>, slotRequestId, allocationId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Map&lt;AllocationID, MultiTaskSlot&gt; innerMap = resolvedRootSlots.computeIfAbsent(</span><br><span class="line">              slotContext.getTaskManagerLocation(),</span><br><span class="line">              taskManagerLocation -&gt; <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>));</span><br><span class="line"></span><br><span class="line">            MultiTaskSlot previousValue = innerMap.put(allocationId, resolvedRootNode);</span><br><span class="line">            Preconditions.checkState(previousValue == <span class="keyword">null</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          rootMultiTaskSlot.release(throwable);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    <span class="keyword">return</span> rootMultiTaskSlot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另外，Flink 中不同 Task 只要在同一个 <code>SlotSharingGroup</code> 中就可以进行资源共享，但有一个隐含的条件是，这两个 Task 需要是不同的 Operator 的子任务。<br>例如，如果 map 算子的并行度为三，map[1] 子任务和 map[2] 子任务是不能落在同一个 PhysicalSlot 中的。在 <code>listResolvedRootSlotInfo</code> 和 <code>getUnresolvedRootSlot</code> 中，都有 <code>!multiTaskSlot.contains(groupId)</code> 的逻辑，也就是说要确保一棵 <code>TaskSlot</code> 构成的树中不会出现同一个算子的不同子任务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SlotSharingManager</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Nonnull</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Collection&lt;SlotInfo&gt; <span class="title">listResolvedRootSlotInfo</span><span class="params">(@Nullable AbstractID groupId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//列出已经分配了physical slot 的root MultiTaskSlot，但要求 MultiTaskSlot 不包含指定的 groupId</span></span><br><span class="line">    <span class="keyword">return</span> resolvedRootSlots</span><br><span class="line">      .values()</span><br><span class="line">      .stream()</span><br><span class="line">      .flatMap((Map&lt;AllocationID, MultiTaskSlot&gt; map) -&gt; map.values().stream())</span><br><span class="line">      .filter((MultiTaskSlot multiTaskSlot) -&gt; !multiTaskSlot.contains(groupId))</span><br><span class="line">      .map((MultiTaskSlot multiTaskSlot) -&gt; (SlotInfo) multiTaskSlot.getSlotContextFuture().join())</span><br><span class="line">      .collect(Collectors.toList());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MultiTaskSlot <span class="title">getResolvedRootSlot</span><span class="params">(@Nonnull SlotInfo slotInfo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//根据 SlotInfo（TasManagerLocation 和 AllocationId）找到 MultiTaskSlot</span></span><br><span class="line">    Map&lt;AllocationID, MultiTaskSlot&gt; forLocationEntry = resolvedRootSlots.get(slotInfo.getTaskManagerLocation());</span><br><span class="line">    <span class="keyword">return</span> forLocationEntry != <span class="keyword">null</span> ? forLocationEntry.get(slotInfo.getAllocationId()) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * Gets an unresolved slot which does not yet contain the given groupId. An unresolved</span></span><br><span class="line"><span class="comment">	 * slot is a slot whose underlying allocated slot has not been allocated yet.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> groupId which the returned slot must not contain</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> the unresolved slot or null if there was no root slot with free capacities</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">  <span class="meta">@Nullable</span></span><br><span class="line">  <span class="function">MultiTaskSlot <span class="title">getUnresolvedRootSlot</span><span class="params">(AbstractID groupId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//找到一个不包含指定 groupId 的 root MultiTaskSlot</span></span><br><span class="line">    <span class="keyword">for</span> (MultiTaskSlot multiTaskSlot : unresolvedRootSlots.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!multiTaskSlot.contains(groupId)) &#123;</span><br><span class="line">        <span class="keyword">return</span> multiTaskSlot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>任务调度时 <code>LogicalSlot</code> 资源的申请通过 <code>Scheduler</code> 接口进行管理，<code>Scheduler</code> 接口继承了 <code>SlotProvider</code> 接口， 它的唯一实现类是 <code>SchuedulerImpl</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SlotProvider</span> </span>&#123;</span><br><span class="line">  <span class="comment">//申请 slot，返回值一个 LogicalSlot 的 future</span></span><br><span class="line">  <span class="function">CompletableFuture&lt;LogicalSlot&gt; <span class="title">allocateSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		ScheduledUnit scheduledUnit,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotProfile slotProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> allowQueuedScheduling,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time allocationTimeout)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cancelSlotRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable SlotSharingGroupId slotSharingGroupId,</span></span></span><br><span class="line"><span class="function"><span class="params">		Throwable cause)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Scheduler</span> <span class="keyword">extends</span> <span class="title">SlotProvider</span>, <span class="title">SlotOwner</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">(@Nonnull ComponentMainThreadExecutor mainThreadExecutor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">requiresPreviousExecutionGraphAllocations</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>SchedulerImpl</code> 的主要成员变量有：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchedulerImpl</span> <span class="keyword">implements</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotSelectionStrategy slotSelectionStrategy;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SlotPool slotPool;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;SlotSharingGroupId, SlotSharingManager&gt; slotSharingManagers;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很明显，<code>SchedulerImpl</code> 借助 <code>SlotPool</code> 来申请 PhysicalSlot，借助 <code>SlotSharingManager</code> 实现 slot 共享。<code>SlotSelectionStrategy</code> 接口主要用于从一组 slot 中选出最符合资源申请偏好的一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchedulerImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletableFuture&lt;LogicalSlot&gt; <span class="title">allocateSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		ScheduledUnit scheduledUnit,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotProfile slotProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> allowQueuedScheduling,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time allocationTimeout)</span> </span>&#123;</span><br><span class="line">    log.debug(<span class="string">"Received slot request [&#123;&#125;] for task: &#123;&#125;"</span>, slotRequestId, scheduledUnit.getTaskToExecute());</span><br><span class="line"></span><br><span class="line">    componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CompletableFuture&lt;LogicalSlot&gt; allocationResultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有指定 SlotSharingGroupId，说明这个任务不运行 slot 共享，要独占一个 slot</span></span><br><span class="line">    CompletableFuture&lt;LogicalSlot&gt; allocationFuture = scheduledUnit.getSlotSharingGroupId() == <span class="keyword">null</span> ?</span><br><span class="line">      allocateSingleSlot(slotRequestId, slotProfile, allowQueuedScheduling, allocationTimeout) :</span><br><span class="line">      allocateSharedSlot(slotRequestId, scheduledUnit, slotProfile, allowQueuedScheduling, allocationTimeout);</span><br><span class="line"></span><br><span class="line">    allocationFuture.whenComplete((LogicalSlot slot, Throwable failure) -&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (failure != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cancelSlotRequest(</span><br><span class="line">          slotRequestId,</span><br><span class="line">          scheduledUnit.getSlotSharingGroupId(),</span><br><span class="line">          failure);</span><br><span class="line">        allocationResultFuture.completeExceptionally(failure);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        allocationResultFuture.complete(slot);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> allocationResultFuture;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelSlotRequest</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nullable SlotSharingGroupId slotSharingGroupId,</span></span></span><br><span class="line"><span class="function"><span class="params">		Throwable cause)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    componentMainThreadExecutor.assertRunningInMainThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotSharingGroupId != <span class="keyword">null</span>) &#123;</span><br><span class="line">      releaseSharedSlot(slotRequestId, slotSharingGroupId, cause);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      slotPool.releaseSlot(slotRequestId, cause);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">returnLogicalSlot</span><span class="params">(LogicalSlot logicalSlot)</span> </span>&#123;</span><br><span class="line">    SlotRequestId slotRequestId = logicalSlot.getSlotRequestId();</span><br><span class="line">    SlotSharingGroupId slotSharingGroupId = logicalSlot.getSlotSharingGroupId();</span><br><span class="line">    FlinkException cause = <span class="keyword">new</span> FlinkException(<span class="string">"Slot is being returned to the SlotPool."</span>);</span><br><span class="line">    cancelSlotRequest(slotRequestId, slotSharingGroupId, cause);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这几个对外暴露的方法的逻辑都比较清晰，接着来看下内部的具体实现。</p>
<p>如果不允许资源共享，那么直接从 <code>SlotPool</code> 中获取 PhysicalSlot，然后创建一个 <code>LogicalSlot</code> 即可：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchedulerImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> CompletableFuture&lt;LogicalSlot&gt; <span class="title">allocateSingleSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotProfile slotProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> allowQueuedScheduling,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time allocationTimeout)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先尝试从 SlotPool 可用的 AllocatedSlot 中获取</span></span><br><span class="line">    Optional&lt;SlotAndLocality&gt; slotAndLocality = tryAllocateFromAvailable(slotRequestId, slotProfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (slotAndLocality.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//如果有已经有可用的了，就创建一个 SingleLogicalSlot，并作为 AllocatedSlot 的payload</span></span><br><span class="line">      <span class="comment">// already successful from available</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> CompletableFuture.completedFuture(</span><br><span class="line">          completeAllocationByAssigningPayload(slotRequestId, slotAndLocality.get()));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (FlinkException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> FutureUtils.completedExceptionally(e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (allowQueuedScheduling) &#123;</span><br><span class="line">      <span class="comment">//暂时没有可用的，如果允许排队的话，可以要求 SlotPool 向 RM 申请一个新的 slot</span></span><br><span class="line">      <span class="comment">// we allocate by requesting a new slot</span></span><br><span class="line">      <span class="keyword">return</span> slotPool</span><br><span class="line">        .requestNewAllocatedSlot(slotRequestId, slotProfile.getResourceProfile(), allocationTimeout)</span><br><span class="line">        .thenApply((PhysicalSlot allocatedSlot) -&gt; &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> completeAllocationByAssigningPayload(slotRequestId, <span class="keyword">new</span> SlotAndLocality(allocatedSlot, Locality.UNKNOWN));</span><br><span class="line">          &#125; <span class="keyword">catch</span> (FlinkException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> CompletionException(e);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// failed to allocate</span></span><br><span class="line">      <span class="keyword">return</span> FutureUtils.completedExceptionally(</span><br><span class="line">        <span class="keyword">new</span> NoResourceAvailableException(<span class="string">"Could not allocate a simple slot for "</span> + slotRequestId + <span class="string">'.'</span>));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Optional&lt;SlotAndLocality&gt; <span class="title">tryAllocateFromAvailable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		@Nonnull SlotProfile slotProfile)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Collection&lt;SlotInfo&gt; slotInfoList = slotPool.getAvailableSlotsInformation();</span><br><span class="line"></span><br><span class="line">    Optional&lt;SlotSelectionStrategy.SlotInfoAndLocality&gt; selectedAvailableSlot =</span><br><span class="line">      slotSelectionStrategy.selectBestSlotForProfile(slotInfoList, slotProfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> selectedAvailableSlot.flatMap(slotInfoAndLocality -&gt; &#123;</span><br><span class="line">      Optional&lt;PhysicalSlot&gt; optionalAllocatedSlot = slotPool.allocateAvailableSlot(</span><br><span class="line">        slotRequestId,</span><br><span class="line">        slotInfoAndLocality.getSlotInfo().getAllocationId());</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> optionalAllocatedSlot.map(</span><br><span class="line">        allocatedSlot -&gt; <span class="keyword">new</span> SlotAndLocality(allocatedSlot, slotInfoAndLocality.getLocality()));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果需要进行资源共享，那么还要进一步考虑 <code>CoLocationGroup</code> 强制约束的情况，它的核心就在于构造 <code>TaskSlot</code> 构成的树，然后在树上创建一个叶子节点，叶子节点里封装了需要的 <code>LogicalSlot</code>。更详细的流程参考下面代码和添加的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SchedulerImpl</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> CompletableFuture&lt;LogicalSlot&gt; <span class="title">allocateSharedSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotRequestId slotRequestId,</span></span></span><br><span class="line"><span class="function"><span class="params">		ScheduledUnit scheduledUnit,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotProfile slotProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> allowQueuedScheduling,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time allocationTimeout)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每一个 SlotSharingGroup 对应一个 SlotSharingManager</span></span><br><span class="line">    <span class="comment">// allocate slot with slot sharing</span></span><br><span class="line">    <span class="keyword">final</span> SlotSharingManager multiTaskSlotManager = slotSharingManagers.computeIfAbsent(</span><br><span class="line">      scheduledUnit.getSlotSharingGroupId(),</span><br><span class="line">      id -&gt; <span class="keyword">new</span> SlotSharingManager(</span><br><span class="line">        id,</span><br><span class="line">        slotPool,</span><br><span class="line">        <span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配 MultiTaskSlot</span></span><br><span class="line">    <span class="keyword">final</span> SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (scheduledUnit.getCoLocationConstraint() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//存在 ColLocation 约束</span></span><br><span class="line">        multiTaskSlotLocality = allocateCoLocatedMultiTaskSlot(</span><br><span class="line">          scheduledUnit.getCoLocationConstraint(),</span><br><span class="line">          multiTaskSlotManager,</span><br><span class="line">          slotProfile,</span><br><span class="line">          allowQueuedScheduling,</span><br><span class="line">          allocationTimeout);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        multiTaskSlotLocality = allocateMultiTaskSlot(</span><br><span class="line">          scheduledUnit.getJobVertexId(),</span><br><span class="line">          multiTaskSlotManager,</span><br><span class="line">          slotProfile,</span><br><span class="line">          allowQueuedScheduling,</span><br><span class="line">          allocationTimeout);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoResourceAvailableException noResourceException) &#123;</span><br><span class="line">      <span class="keyword">return</span> FutureUtils.completedExceptionally(noResourceException);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sanity check</span></span><br><span class="line">    Preconditions.checkState(!multiTaskSlotLocality.getMultiTaskSlot().contains(scheduledUnit.getJobVertexId()));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 MultiTaskSlot 下创建叶子节点 SingleTaskSlot，并获取可以分配给任务的 SingleLogicalSlot</span></span><br><span class="line">    <span class="keyword">final</span> SlotSharingManager.SingleTaskSlot leaf = multiTaskSlotLocality.getMultiTaskSlot().allocateSingleTaskSlot(</span><br><span class="line">      slotRequestId,</span><br><span class="line">      scheduledUnit.getJobVertexId(),</span><br><span class="line">      multiTaskSlotLocality.getLocality());</span><br><span class="line">    <span class="keyword">return</span> leaf.getLogicalSlotFuture();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SlotSharingManager.<span class="function">MultiTaskSlotLocality <span class="title">allocateCoLocatedMultiTaskSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		CoLocationConstraint coLocationConstraint,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotSharingManager multiTaskSlotManager,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotProfile slotProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> allowQueuedScheduling,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time allocationTimeout)</span> <span class="keyword">throws</span> NoResourceAvailableException </span>&#123;</span><br><span class="line">    <span class="comment">//coLocationConstraint 会和分配给它的 MultiTaskSlot(不是root) 的 SlotRequestId 绑定</span></span><br><span class="line">    <span class="comment">//这个绑定关系只有在分配了 MultiTaskSlot 之后才会生成</span></span><br><span class="line">    <span class="comment">//可以根据 SlotRequestId 直接定位到 MultiTaskSlot</span></span><br><span class="line">    <span class="keyword">final</span> SlotRequestId coLocationSlotRequestId = coLocationConstraint.getSlotRequestId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (coLocationSlotRequestId != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// we have a slot assigned --&gt; try to retrieve it</span></span><br><span class="line">      <span class="keyword">final</span> SlotSharingManager.TaskSlot taskSlot = multiTaskSlotManager.getTaskSlot(coLocationSlotRequestId);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (taskSlot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Preconditions.checkState(taskSlot <span class="keyword">instanceof</span> SlotSharingManager.MultiTaskSlot);</span><br><span class="line">        <span class="keyword">return</span> SlotSharingManager.MultiTaskSlotLocality.of(((SlotSharingManager.MultiTaskSlot) taskSlot), Locality.LOCAL);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// the slot may have been cancelled in the mean time</span></span><br><span class="line">        coLocationConstraint.setSlotRequestId(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (coLocationConstraint.isAssigned()) &#123;</span><br><span class="line">      <span class="comment">// refine the preferred locations of the slot profile</span></span><br><span class="line">      slotProfile = <span class="keyword">new</span> SlotProfile(</span><br><span class="line">        slotProfile.getResourceProfile(),</span><br><span class="line">        Collections.singleton(coLocationConstraint.getLocation()),</span><br><span class="line">        slotProfile.getPreferredAllocations());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为这个 coLocationConstraint 分配 MultiTaskSlot，先找到符合要求的root MultiTaskSlot</span></span><br><span class="line">    <span class="comment">// get a new multi task slot</span></span><br><span class="line">    SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = allocateMultiTaskSlot(</span><br><span class="line">      coLocationConstraint.getGroupId(),</span><br><span class="line">      multiTaskSlotManager,</span><br><span class="line">      slotProfile,</span><br><span class="line">      allowQueuedScheduling,</span><br><span class="line">      allocationTimeout);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check whether we fulfill the co-location constraint</span></span><br><span class="line">    <span class="keyword">if</span> (coLocationConstraint.isAssigned() &amp;&amp; multiTaskSlotLocality.getLocality() != Locality.LOCAL) &#123;</span><br><span class="line">      multiTaskSlotLocality.getMultiTaskSlot().release(</span><br><span class="line">        <span class="keyword">new</span> FlinkException(<span class="string">"Multi task slot is not local and, thus, does not fulfill the co-location constraint."</span>));</span><br><span class="line"></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NoResourceAvailableException(<span class="string">"Could not allocate a local multi task slot for the "</span> +</span><br><span class="line">        <span class="string">"co location constraint "</span> + coLocationConstraint + <span class="string">'.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在 root MultiTaskSlot 下面创建一个二级的 MultiTaskSlot，分配给这个 coLocationConstraint</span></span><br><span class="line">    <span class="keyword">final</span> SlotRequestId slotRequestId = <span class="keyword">new</span> SlotRequestId();</span><br><span class="line">    <span class="keyword">final</span> SlotSharingManager.MultiTaskSlot coLocationSlot =</span><br><span class="line">      multiTaskSlotLocality.getMultiTaskSlot().allocateMultiTaskSlot(</span><br><span class="line">        slotRequestId,</span><br><span class="line">        coLocationConstraint.getGroupId());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为 coLocationConstraint 绑定 slotRequestId，后续就可以直接通过这个 slotRequestId 定位到 MultiTaskSlot</span></span><br><span class="line">    <span class="comment">// mark the requested slot as co-located slot for other co-located tasks</span></span><br><span class="line">    coLocationConstraint.setSlotRequestId(slotRequestId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// lock the co-location constraint once we have obtained the allocated slot</span></span><br><span class="line">    coLocationSlot.getSlotContextFuture().whenComplete(</span><br><span class="line">      (SlotContext slotContext, Throwable throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (throwable == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// check whether we are still assigned to the co-location constraint</span></span><br><span class="line">          <span class="keyword">if</span> (Objects.equals(coLocationConstraint.getSlotRequestId(), slotRequestId)) &#123;</span><br><span class="line">            <span class="comment">//为这个 coLocationConstraint 绑定位置</span></span><br><span class="line">            coLocationConstraint.lockLocation(slotContext.getTaskManagerLocation());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.debug(<span class="string">"Failed to lock colocation constraint &#123;&#125; because assigned slot "</span> +</span><br><span class="line">                <span class="string">"request &#123;&#125; differs from fulfilled slot request &#123;&#125;."</span>,</span><br><span class="line">              coLocationConstraint.getGroupId(),</span><br><span class="line">              coLocationConstraint.getSlotRequestId(),</span><br><span class="line">              slotRequestId);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          log.debug(<span class="string">"Failed to lock colocation constraint &#123;&#125; because the slot "</span> +</span><br><span class="line">              <span class="string">"allocation for slot request &#123;&#125; failed."</span>,</span><br><span class="line">            coLocationConstraint.getGroupId(),</span><br><span class="line">            coLocationConstraint.getSlotRequestId(),</span><br><span class="line">            throwable);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> SlotSharingManager.MultiTaskSlotLocality.of(coLocationSlot, multiTaskSlotLocality.getLocality());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> SlotSharingManager.<span class="function">MultiTaskSlotLocality <span class="title">allocateMultiTaskSlot</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		AbstractID groupId,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotSharingManager slotSharingManager,</span></span></span><br><span class="line"><span class="function"><span class="params">		SlotProfile slotProfile,</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">boolean</span> allowQueuedScheduling,</span></span></span><br><span class="line"><span class="function"><span class="params">		Time allocationTimeout)</span> <span class="keyword">throws</span> NoResourceAvailableException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到符合要求的已经分配了 AllocatedSlot 的 root MultiTaskSlot 集合，</span></span><br><span class="line">    <span class="comment">//这里的符合要求是指 root MultiTaskSlot 不含有当前 groupId, 避免把 groupId 相同（同一个 JobVertex）的不同 task 分配到同一个 slot 中</span></span><br><span class="line">    Collection&lt;SlotInfo&gt; resolvedRootSlotsInfo = slotSharingManager.listResolvedRootSlotInfo(groupId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//由 slotSelectionStrategy 选出最符合条件的</span></span><br><span class="line">    SlotSelectionStrategy.SlotInfoAndLocality bestResolvedRootSlotWithLocality =</span><br><span class="line">      slotSelectionStrategy.selectBestSlotForProfile(resolvedRootSlotsInfo, slotProfile).orElse(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对 MultiTaskSlot 和 Locality 做一层封装</span></span><br><span class="line">    <span class="keyword">final</span> SlotSharingManager.MultiTaskSlotLocality multiTaskSlotLocality = bestResolvedRootSlotWithLocality != <span class="keyword">null</span> ?</span><br><span class="line">      <span class="keyword">new</span> SlotSharingManager.MultiTaskSlotLocality(</span><br><span class="line">        slotSharingManager.getResolvedRootSlot(bestResolvedRootSlotWithLocality.getSlotInfo()),</span><br><span class="line">        bestResolvedRootSlotWithLocality.getLocality()) :</span><br><span class="line">      <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果 MultiTaskSlot 对应的 AllocatedSlot 和请求偏好的 slot 落在同一个 TaskManager，那么就选择这个 MultiTaskSlot</span></span><br><span class="line">    <span class="keyword">if</span> (multiTaskSlotLocality != <span class="keyword">null</span> &amp;&amp; multiTaskSlotLocality.getLocality() == Locality.LOCAL) &#123;</span><br><span class="line">      <span class="keyword">return</span> multiTaskSlotLocality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里由两种可能：</span></span><br><span class="line">    <span class="comment">// 1）multiTaskSlotLocality == null，说明没有找到符合条件的 root MultiTaskSlot</span></span><br><span class="line">    <span class="comment">// 2) multiTaskSlotLocality != null &amp;&amp; multiTaskSlotLocality.getLocality() == Locality.LOCAL，不符合 Locality 偏好</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试从 SlotPool 中未使用的 slot 中选择</span></span><br><span class="line">    <span class="keyword">final</span> SlotRequestId allocatedSlotRequestId = <span class="keyword">new</span> SlotRequestId();</span><br><span class="line">    <span class="keyword">final</span> SlotRequestId multiTaskSlotRequestId = <span class="keyword">new</span> SlotRequestId();</span><br><span class="line"></span><br><span class="line">    Optional&lt;SlotAndLocality&gt; optionalPoolSlotAndLocality = tryAllocateFromAvailable(allocatedSlotRequestId, slotProfile);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (optionalPoolSlotAndLocality.isPresent()) &#123;</span><br><span class="line">      <span class="comment">//如果从 SlotPool 中找到了未使用的 slot</span></span><br><span class="line">      SlotAndLocality poolSlotAndLocality = optionalPoolSlotAndLocality.get();</span><br><span class="line">      <span class="comment">//如果未使用的 AllocatedSlot 符合 Locality 偏好，或者前一步没有找到可用的 MultiTaskSlot</span></span><br><span class="line">      <span class="keyword">if</span> (poolSlotAndLocality.getLocality() == Locality.LOCAL || bestResolvedRootSlotWithLocality == <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//基于 新分配的 AllocatedSlot 创建一个 root MultiTaskSlot</span></span><br><span class="line">        <span class="keyword">final</span> PhysicalSlot allocatedSlot = poolSlotAndLocality.getSlot();</span><br><span class="line">        <span class="keyword">final</span> SlotSharingManager.MultiTaskSlot multiTaskSlot = slotSharingManager.createRootSlot(</span><br><span class="line">          multiTaskSlotRequestId,</span><br><span class="line">          CompletableFuture.completedFuture(poolSlotAndLocality.getSlot()),</span><br><span class="line">          allocatedSlotRequestId);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将新创建的 root MultiTaskSlot 作为 AllocatedSlot 的 payload</span></span><br><span class="line">        <span class="keyword">if</span> (allocatedSlot.tryAssignPayload(multiTaskSlot)) &#123;</span><br><span class="line">          <span class="keyword">return</span> SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlot, poolSlotAndLocality.getLocality());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          multiTaskSlot.release(<span class="keyword">new</span> FlinkException(<span class="string">"Could not assign payload to allocated slot "</span> +</span><br><span class="line">            allocatedSlot.getAllocationId() + <span class="string">'.'</span>));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (multiTaskSlotLocality != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//如果都不符合 Locality 偏好，或者 SlotPool 中没有可用的 slot 了</span></span><br><span class="line">      <span class="comment">// prefer slot sharing group slots over unused slots</span></span><br><span class="line">      <span class="keyword">if</span> (optionalPoolSlotAndLocality.isPresent()) &#123;</span><br><span class="line">        slotPool.releaseSlot(</span><br><span class="line">          allocatedSlotRequestId,</span><br><span class="line">          <span class="keyword">new</span> FlinkException(<span class="string">"Locality constraint is not better fulfilled by allocated slot."</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> multiTaskSlotLocality;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里，说明 1）slotSharingManager 中没有符合要求的 root MultiTaskSlot &amp;&amp; 2）slotPool 中没有可用的 slot 了</span></span><br><span class="line">    <span class="keyword">if</span> (allowQueuedScheduling) &#123;</span><br><span class="line">      <span class="comment">//先检查 slotSharingManager 中是不是还有没完成 slot 分配的  root MultiTaskSlot</span></span><br><span class="line">      <span class="comment">// there is no slot immediately available --&gt; check first for uncompleted slots at the slot sharing group</span></span><br><span class="line">      SlotSharingManager.MultiTaskSlot multiTaskSlot = slotSharingManager.getUnresolvedRootSlot(groupId);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (multiTaskSlot == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果没有，就需要 slotPool 向 RM 请求新的 slot 了</span></span><br><span class="line">        <span class="comment">// it seems as if we have to request a new slot from the resource manager, this is always the last resort!!!</span></span><br><span class="line">        <span class="keyword">final</span> CompletableFuture&lt;PhysicalSlot&gt; slotAllocationFuture = slotPool.requestNewAllocatedSlot(</span><br><span class="line">          allocatedSlotRequestId,</span><br><span class="line">          slotProfile.getResourceProfile(),</span><br><span class="line">          allocationTimeout);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//请求分配后，就是同样的流程的，创建一个 root MultiTaskSlot，并作为新分配的 AllocatedSlot 的负载</span></span><br><span class="line">        multiTaskSlot = slotSharingManager.createRootSlot(</span><br><span class="line">          multiTaskSlotRequestId,</span><br><span class="line">          slotAllocationFuture,</span><br><span class="line">          allocatedSlotRequestId);</span><br><span class="line"></span><br><span class="line">        slotAllocationFuture.whenComplete(</span><br><span class="line">          (PhysicalSlot allocatedSlot, Throwable throwable) -&gt; &#123;</span><br><span class="line">            <span class="keyword">final</span> SlotSharingManager.TaskSlot taskSlot = slotSharingManager.getTaskSlot(multiTaskSlotRequestId);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (taskSlot != <span class="keyword">null</span>) &#123;</span><br><span class="line">              <span class="comment">// still valid</span></span><br><span class="line">              <span class="keyword">if</span> (!(taskSlot <span class="keyword">instanceof</span> SlotSharingManager.MultiTaskSlot) || throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                taskSlot.release(throwable);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!allocatedSlot.tryAssignPayload(((SlotSharingManager.MultiTaskSlot) taskSlot))) &#123;</span><br><span class="line">                  taskSlot.release(<span class="keyword">new</span> FlinkException(<span class="string">"Could not assign payload to allocated slot "</span> +</span><br><span class="line">                    allocatedSlot.getAllocationId() + <span class="string">'.'</span>));</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              slotPool.releaseSlot(</span><br><span class="line">                allocatedSlotRequestId,</span><br><span class="line">                <span class="keyword">new</span> FlinkException(<span class="string">"Could not find task slot with "</span> + multiTaskSlotRequestId + <span class="string">'.'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> SlotSharingManager.MultiTaskSlotLocality.of(multiTaskSlot, Locality.UNKNOWN);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NoResourceAvailableException(<span class="string">"Could not allocate a shared slot for "</span> + groupId + <span class="string">'.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在分布式计算引擎，一个非常核心的功能在于对计算资源的管理。在这篇文章里我们了解了 Flink 以 Task slot 为基本单位的资源管理模式，从 <code>TaskExecutor</code>, <code>ResourceManager</code> 到 <code>JobMaster</code>，对于每一个组件内部的 slot 管理方式都进行了较为细致的分解，包括 <code>ResourceManager</code> 的动态资源管理，<code>SlotSharingGroup</code> 和 <code>CoLocationGroup</code> 的共享约束等。动态资源管理机制使得 Flink 可以更为方便地和 Yarn、Kubernetes 等资源管理框架进行继承，而计算资源共享机制则使得作业内部子任务之间的网络开销大大降低。</p>
<p>最后，附上两张图以加深理解:<br><img src="/img/flink/task-slots.svg" alt="task-slots"><br><img src="/img/flink/slot-request.svg" alt="slot-request-inter-action"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://cwiki.apache.org/confluence/pages/viewpage.action?pageId=65147077" target="_blank" rel="noopener">FLIP-6 - Flink Deployment and Process Model - Standalone, Yarn, Mesos, Kubernetes, etc.</a></li>
<li><a href="https://ci.apache.org/projects/flink/flink-docs-master/concepts/runtime.html#task-slots-and-resources" target="_blank" rel="noopener">Task Slots and Resources</a></li>
</ul>
</span>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Flink/" rel="tag">#Flink</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/flink-source-code-memory-management/" rel="prev">Flink 源码阅读笔记（7）- 内存管理</a>
            
          </div>

          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/flink-source-code-bootstarp/" rel="next">Flink 源码阅读笔记（5）- 集群启动流程</a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>

 </div>

        

        
          <div class="comments" id="comments">
            
          </div>
        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="/images/avatar.png" alt="JR" itemprop="image"/>
          <p class="site-author-name" itemprop="name">JR</p>
        </div>
        <p class="site-description motion-element" itemprop="description">想入非非就是寻找神奇</p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">42</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">19</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/jrthe42" target="_blank">GitHub</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/jrthe42" target="_blank">Weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://music.jrwang.me" target="_blank">Music</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://wiki.jrwang.me" target="_blank">Wiki</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://jrwang.me" target="_blank">Site</a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="http://creativecommons.org/licenses/by-nc-sa/4.0" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

      </section>

      
        <section class="post-toc-wrap sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator"></div>
          <div class="post-toc">
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Task-Slot-的基本概念"><span class="nav-number">1.</span> <span class="nav-text">Task Slot 的基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TaskExecutor-中-Slot-的管理"><span class="nav-number">2.</span> <span class="nav-text">TaskExecutor 中 Slot 的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TaskSlot"><span class="nav-number">2.1.</span> <span class="nav-text">TaskSlot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TaskSlotTable"><span class="nav-number">2.2.</span> <span class="nav-text">TaskSlotTable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TaskExecutor"><span class="nav-number">2.3.</span> <span class="nav-text">TaskExecutor</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ResourceManage-中-Slot-的管理"><span class="nav-number">3.</span> <span class="nav-text">ResourceManage 中 Slot 的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SlotManager"><span class="nav-number">3.1.</span> <span class="nav-text">SlotManager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Slot-注册"><span class="nav-number">3.1.1.</span> <span class="nav-text">Slot 注册</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求-Slot"><span class="nav-number">3.1.2.</span> <span class="nav-text">请求 Slot</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#取消-slot-请求"><span class="nav-number">3.1.3.</span> <span class="nav-text">取消 slot 请求</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#超时设置"><span class="nav-number">3.1.4.</span> <span class="nav-text">超时设置</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ResourceManager"><span class="nav-number">3.2.</span> <span class="nav-text">ResourceManager</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#RPC-接口"><span class="nav-number">3.2.1.</span> <span class="nav-text">RPC 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#动态资源管理"><span class="nav-number">3.2.2.</span> <span class="nav-text">动态资源管理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JobManager-中-Slot-的管理"><span class="nav-number">4.</span> <span class="nav-text">JobManager 中 Slot 的管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PhysicalSlot-vs-LogicalSlot-vs-MultiTaskSlot"><span class="nav-number">4.1.</span> <span class="nav-text">PhysicalSlot vs. LogicalSlot vs. MultiTaskSlot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SlotPool"><span class="nav-number">4.2.</span> <span class="nav-text">SlotPool</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Scheduler-和-SlotSharingManager"><span class="nav-number">4.3.</span> <span class="nav-text">Scheduler 和 SlotSharingManager</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#小结"><span class="nav-number">5.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考"><span class="nav-number">6.</span> <span class="nav-text">参考</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator"></div>
        </section>
      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp;  2015 - 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">JR</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="powered-by">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

<div class="theme-info">
  Modified By <a class="theme-link" href="http://jrwang.me">JR</a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    
    

  


  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  
<script type="text/javascript" src="/js/bootstrap.scrollspy.js?v=0.4.5.1" id="bootstrap.scrollspy.custom"></script>


<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 0.4 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    var $tocContent = $('.post-toc-content');
    if (isDesktop() && CONFIG.sidebar === 'post') {
      if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
        displaySidebar();
      }
    }
  });
</script>



  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
