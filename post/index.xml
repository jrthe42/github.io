<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on JR&#39;s Blog</title>
    <link>https://blog.jrwang.me/post/</link>
    <description>Recent content in Posts on JR&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 29 Sep 2019 20:05:03 +0800</lastBuildDate>
    
	<atom:link href="https://blog.jrwang.me/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Aloha：一个分布式任务调度框架</title>
      <link>https://blog.jrwang.me/2019/aloha-introduce/</link>
      <pubDate>Fri, 15 Mar 2019 23:58:18 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/aloha-introduce/</guid>
      <description>概览 Aloha 是一个基于 Scala 实现的分布式的任务调度和管理框架，提供插件式扩展功能，可以用来调度各种类型的任务。Aloha 的典型的应用场景是作为统一的任</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（17）- Flink SQL 中的时间属性</title>
      <link>https://blog.jrwang.me/2019/2019-09-16-flink-sourcecode-sql-time-attribute.md/</link>
      <pubDate>Sun, 29 Sep 2019 20:05:03 +0800</pubDate>
      
      <guid>https://blog.jrwang.me/2019/2019-09-16-flink-sourcecode-sql-time-attribute.md/</guid>
      <description>在流计算中，时间属性承担了一个极其重要的作用，所有基于时间的操作，例如窗口操作，都需要正确获取时间信息。我们曾经在Flink 源码阅读笔记（1</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（16）- Flink SQL 的元数据管理</title>
      <link>https://blog.jrwang.me/2019/2019-09-12-flink-sourcecode-sql-catalog/</link>
      <pubDate>Sun, 15 Sep 2019 20:34:45 +0800</pubDate>
      
      <guid>https://blog.jrwang.me/2019/2019-09-12-flink-sourcecode-sql-catalog/</guid>
      <description>为了使用 SQL，一个首先需要解决的是元数据管理的问题。元数据的管理包括表的元数据和 UDF 的元数据，这使得完全使用 SQL 语句来构建实时任务成为可能。 Catalog</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（15）- Flink SQL 整体执行框架</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-sql-overview/</link>
      <pubDate>Wed, 04 Sep 2019 21:31:00 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-sql-overview/</guid>
      <description>在数据处理领域，无论是实时数据处理还是离线数据处理，使用 SQL 简化开发将会是未来的整体发展趋势。尽管 SQL 简化了使用的门槛，但是如何将 SQL 等价转换到现</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（14）- Async I/O 的实现</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-async-io/</link>
      <pubDate>Sat, 27 Jul 2019 20:31:53 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-async-io/</guid>
      <description>在使用 Flink 处理实时数据流时，经常需要和外部系统进行交互。例如，在构建实时数据仓库的时候，通常需要将消息和外部维表进行关联，以获得额外的维度数据</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（13）- 双流操作的实现</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-two-stream-join/</link>
      <pubDate>Sat, 13 Jul 2019 20:18:13 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-two-stream-join/</guid>
      <description>在使用 Flink 进行实时数据处理时，一个常用的场景是对两个流的数据进行关联。这篇文章中我们将对双流操作的底层实现机制进行分析。 Window Join and CoGroup Window Join 操作，顾名</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（12）- 时间、定时器和窗口</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-time-and-window/</link>
      <pubDate>Sun, 07 Jul 2019 19:18:23 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-time-and-window/</guid>
      <description>流式数据处理中，很多操作要依赖于时间属性进行，因此时间属性也是流式引擎能够保证准确处理数据的基石。在这篇文章中，我们将对 Flink 中时间属性和窗口的</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（11）- Checkpoint 机制和状态恢复</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-checkpoint/</link>
      <pubDate>Sat, 22 Jun 2019 19:58:33 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-checkpoint/</guid>
      <description>在上一篇文章中，我们对 Flink 状态管理相关的代码逻辑进行了分析，但为了实现任务的故障恢复以及数据一致性的效果，还需要借助于检查点（Checkpoi</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（10）- State 管理</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-state/</link>
      <pubDate>Sat, 15 Jun 2019 20:11:24 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-state/</guid>
      <description>状态 State 是 Flink 中用于构建复杂逻辑的重要组件。本文将从源码角度来分析 Flink 的状态管理是如何实现的。状态 （State）需要配合检查点（Checkpoin</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（9）- Task 的生命周期</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-task-lifecycle/</link>
      <pubDate>Sun, 02 Jun 2019 19:05:03 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-task-lifecycle/</guid>
      <description>一个 Flink Job 提交到集群中运行时，会被调度为不同的 Task。在前面的文章中，我们已经介绍了 Flink 如何根据用户的编写的程序生成调度用的执行图，如何为 Task 分</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（8）- Task 之间的数据传输</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-data-exchange/</link>
      <pubDate>Sat, 25 May 2019 20:03:00 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-data-exchange/</guid>
      <description>在这篇文章中，我们将探讨一个 Flink 作业在实际运行时，不同的 Task 之间是如何进行数据交换的。由于不同的 Task 可能并非运行在同一个 TaskManager 中，因而数据传输的过程中</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（7）- 内存管理</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-memory-management/</link>
      <pubDate>Sun, 19 May 2019 14:20:53 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-memory-management/</guid>
      <description>基于 JVM 的大数据处理分析引擎面临的一个问题是，为了高效地处理数据，有大量的数据需要保存在内存中。直接使用 JVM 堆内存来管理这些数据对象是最简单的实</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（6）- 计算资源管理</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-resource-manager/</link>
      <pubDate>Sat, 11 May 2019 19:01:10 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-resource-manager/</guid>
      <description>在 Flink 中，计算资源的是以 Slot 作为基本单位进行分配的。本文将对 Flink 中计算资源的管理机制加以分析。 Task Slot 的基本概念 我们在前面的文章中了解了 Flink 集群的启动流</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（5）- 集群启动流程</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-bootstarp/</link>
      <pubDate>Sun, 05 May 2019 21:42:38 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-bootstarp/</guid>
      <description>在 Flink 1.5.0 版本发布的时候，Flink 迎来了一个重要的改进：根据 FLIP-6 重构了 Flink 集群部署和任务处理模型，以便更好地和管理资源和调度任务，更优雅地和 Yar</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（4）- RPC</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-rpc/</link>
      <pubDate>Fri, 03 May 2019 20:42:38 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-rpc/</guid>
      <description>作为一个分布式系统，Flink 内部不同组件之间通信依赖于 RPC 机制。这篇文章将对 Flink 的 RPC 框架加以分析。 例子 先来看一个简单的例子，了解 Flink 内部的 RPC 框架</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（3）- ExecutionGraph 的生成</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-executiongraph/</link>
      <pubDate>Sat, 23 Feb 2019 19:38:53 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-executiongraph/</guid>
      <description>我们前面已经分析过 StreamGraph, JobGraph 的生成过程，这两个执行图都是在 client 端生成的。接下来我们将把目光头投向 Flink Job 运行时调度层核心的执行图 - ExecutionGr</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（2）- JobGraph 的生成</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-jobgraph/</link>
      <pubDate>Sun, 17 Feb 2019 16:35:45 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-jobgraph/</guid>
      <description>前面的文章我们介绍了 StreamGraph 的生成，这个实际上只对应 Flink 作业在逻辑上的执行计划图。Flink 会进一步对 StreamGraph 进行转换，得到另一个执行计划图，即 JobGr</description>
    </item>
    
    <item>
      <title>Flink 源码阅读笔记（1）- StreamGraph 的生成</title>
      <link>https://blog.jrwang.me/2019/flink-source-code-streamgraph/</link>
      <pubDate>Sat, 16 Feb 2019 20:42:38 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2019/flink-source-code-streamgraph/</guid>
      <description>在编写 Flink 的程序的时候，核心的要点是构造出数据处理的拓扑结构，即任务执行逻辑的 DAG。我们先来看一下 Flink 任务的拓扑在逻辑上是怎么保存的。 StreamExecutionEnvironment StreamExecutionEnvironment 是 Flink</description>
    </item>
    
    <item>
      <title>关于容器技术的小抄</title>
      <link>https://blog.jrwang.me/2018/container-and-kubernetes/</link>
      <pubDate>Sat, 29 Dec 2018 20:08:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2018/container-and-kubernetes/</guid>
      <description>Docker 最初风靡一时的 Paas 项目提供的“应用托管”，其最核心的组件就是一套应用的打包和分发机制。为了对多用户的应用环境进行隔离，会调用操作系统的 Cgroups 和 Namespace</description>
    </item>
    
    <item>
      <title>DynamicVariable in Scala</title>
      <link>https://blog.jrwang.me/2018/dynamic-variable-in-scala/</link>
      <pubDate>Thu, 07 Jun 2018 21:05:51 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2018/dynamic-variable-in-scala/</guid>
      <description>scala.util.DynamicVariable，这个类有点类似于 java 里面 ThreadLocal，适合用来保存和传递上下文（Context</description>
    </item>
    
    <item>
      <title>从 SQL 语句中解析出源表和结果表</title>
      <link>https://blog.jrwang.me/2018/parse-table-in-sql/</link>
      <pubDate>Wed, 30 May 2018 15:15:57 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2018/parse-table-in-sql/</guid>
      <description>SQL 解析器可以将 SQL 语句解析成一棵抽象语法树(AST)。遍历 AST，从所有的叶子节点中可以找到本条SQL 语句中需要的所有表。 在 Calcite 中，解析出的 AST 是</description>
    </item>
    
    <item>
      <title>Partial Function in Scala</title>
      <link>https://blog.jrwang.me/2018/partial-function-in-scala/</link>
      <pubDate>Thu, 01 Mar 2018 20:35:18 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2018/partial-function-in-scala/</guid>
      <description>模式匹配和匿名函数 Scala 的模式匹配可能是最常用到的代码片段，match 和 case 配合使用，应该是 Scala 程序员最常写的代码片段： 1 2 3 4 v match { case Some(str) =&amp;gt; ... case None =&amp;gt;</description>
    </item>
    
    <item>
      <title>Flink 的状态管理和检查点机制</title>
      <link>https://blog.jrwang.me/2017/flink-state-checkpoint/</link>
      <pubDate>Wed, 20 Sep 2017 20:18:16 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2017/flink-state-checkpoint/</guid>
      <description>从状态说起 状态 (State) 是 Flink 程序中构建复杂逻辑的基本组件。流处理中的状态可以视作算子上的记忆能力，可以保留和已经处理完的输入相关的信息，并对后续输入</description>
    </item>
    
    <item>
      <title>Google 开源 RPC 框架 gRPC 初探</title>
      <link>https://blog.jrwang.me/2016/grpc-at-first-view/</link>
      <pubDate>Thu, 25 Aug 2016 18:10:35 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/grpc-at-first-view/</guid>
      <description>gRPC 是 Google 开源的一款高性能 RPC 框架，前两天发布了 1.0 版本。RPC (Remote Procedure Call) 即远程过程调用，通过 RPC ，客户端的应用程序可以方便地调用另外一台机器上的服务端程</description>
    </item>
    
    <item>
      <title>谈谈 Java 线程状态相关的几个方法</title>
      <link>https://blog.jrwang.me/2016/java-thread-states/</link>
      <pubDate>Sat, 23 Jul 2016 19:44:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-thread-states/</guid>
      <description>在 Java 多线程编程中，sleep(), interrupt(), wait(), notify() 等方法是非常基本也很常用的方法。这些方法会改变运行中的 Java 线程的状态，正确地认识这些方法是掌握 Java 并发编</description>
    </item>
    
    <item>
      <title>SimpleDateFormat 的线程安全问题与 ThreadLocal</title>
      <link>https://blog.jrwang.me/2016/java-simpledateformat-multithread-threadlocal/</link>
      <pubDate>Sat, 09 Jul 2016 23:14:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-simpledateformat-multithread-threadlocal/</guid>
      <description>从 SimpleDateFormat 的线程安全说起 SimpleDateFormat 是 Java 中非常常用的一个类，用于解析和格式化日期字符串。这个类想必大家都有用过，但是 SimpleDateFormat 在多线程环境中并不是线程安全的。我刚知</description>
    </item>
    
    <item>
      <title>记一次使用 PutSortReducer 时 OOM 错误的排查过程</title>
      <link>https://blog.jrwang.me/2016/gc-overhead-limit-in-putsortreducer/</link>
      <pubDate>Fri, 22 Apr 2016 15:44:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/gc-overhead-limit-in-putsortreducer/</guid>
      <description>之前写过一篇文章介绍如何使用 Bulk Load 的方式向 HBase 中批量导入数据。前两天在运行导入任务时总是会有一个 Reduce 出现 GC overhead limit exceeded 的错误从而导致任务失败，这一度让我</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 Set</title>
      <link>https://blog.jrwang.me/2016/java-collections-set/</link>
      <pubDate>Sun, 10 Apr 2016 20:26:22 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-set/</guid>
      <description>Set 表示由无重复对象组成的集合，也是集合框架中重要的一种集合类型，直接扩展自 Collection 接口。在一个 Set 中，不能有两个引用指向同一个对象，或两个指向 null 的引</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 TreeMap</title>
      <link>https://blog.jrwang.me/2016/java-collections-treemap/</link>
      <pubDate>Sat, 09 Apr 2016 20:00:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-treemap/</guid>
      <description>TreeMap 是一种基于红黑树实现的 Key-Value 结构。在使用集合视图在 HashMap 中迭代时，是不能保证迭代顺序的； LinkedHashMap 使用了双向链表，保证按照插入顺序或者访问顺序进行迭代。但</description>
    </item>
    
    <item>
      <title>Java 枚举源码分析</title>
      <link>https://blog.jrwang.me/2016/java-enum/</link>
      <pubDate>Fri, 01 Apr 2016 20:06:19 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-enum/</guid>
      <description>引言 枚举类型是 JDK 5 之后引进的一种非常重要的引用类型，可以用来定义一系列枚举常量。 在没有引入 enum 关键字之前，要表示可枚举的变量，只能使用 public static final 的</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 LinkedHashMap</title>
      <link>https://blog.jrwang.me/2016/java-collections-linkedhashmap/</link>
      <pubDate>Sun, 27 Mar 2016 20:21:06 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-linkedhashmap/</guid>
      <description>同 HashMap 一样，LinkedHashMap 也是对 Map 接口的一种基于链表和哈希表的实现。实际上， LinkedHashMap 是 HashMap 的子类，其扩展了 HashMap 增加了双向链表的实现。相较于 HashMap</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 LinkedList</title>
      <link>https://blog.jrwang.me/2016/java-collections-linkedlist/</link>
      <pubDate>Mon, 21 Mar 2016 19:03:52 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-linkedlist/</guid>
      <description>概览 同 ArrayList 一样，LinkedList 也是对 List 接口的一种具体实现。不同的是，ArrayList 是基于数组来实现的，而 LinkedList 是基于双向链表实现的。Li</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 Deque 与 ArrayDeque</title>
      <link>https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</link>
      <pubDate>Wed, 16 Mar 2016 20:32:07 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</guid>
      <description>Queue 也是 Java 集合框架中定义的一种接口，直接继承自 Collection 接口。除了基本的 Collection 接口规定测操作外，Queue 接口还定义一组针对队列的特殊操作。通常来说，Qu</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 Vector 与 Stack</title>
      <link>https://blog.jrwang.me/2016/java-collections-vector-stack/</link>
      <pubDate>Tue, 15 Mar 2016 22:06:19 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-vector-stack/</guid>
      <description>JDK 文档中对Vector的描述是这样的：Vector 类实现了一个可增长的对象数组。像数组一样，可以通过整型索引来获取内容，但是 Vector 的大小可以按照</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 HashMap</title>
      <link>https://blog.jrwang.me/2016/java-collections-hashmap/</link>
      <pubDate>Tue, 15 Mar 2016 09:00:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-hashmap/</guid>
      <description>HashMap 是对 Map 接口的一种基于哈希表的实现。所谓 Map，就是映射，存储一系列 Key-Value 对，一个键对应一个值，通过键来查找对应的值。HashMap 是一种高效的</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 ArrayList</title>
      <link>https://blog.jrwang.me/2016/java-collections-arraylist/</link>
      <pubDate>Mon, 14 Mar 2016 20:00:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-arraylist/</guid>
      <description>概览 ArrayList是最常使用的集合类之一了。在JDK文档中对ArrayList的描述是：ArrayList是对list接口的一种基于可变</description>
    </item>
    
    <item>
      <title>关于 Java 内部类的小抄</title>
      <link>https://blog.jrwang.me/2016/java-inner-class/</link>
      <pubDate>Sat, 30 Jan 2016 22:35:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-inner-class/</guid>
      <description>为什么使用内部类？ 在 『Effective Java』中提到了一条建议，尽量使类和成员的可访问性最小化。这个原则其实是面向对象的程序设计的基本原</description>
    </item>
    
    <item>
      <title>使用 Bulk Load 快速向 HBase 中导入数据</title>
      <link>https://blog.jrwang.me/2015/import-data-to-hbase-using-bulk-loding/</link>
      <pubDate>Sun, 06 Dec 2015 19:20:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/import-data-to-hbase-using-bulk-loding/</guid>
      <description>前言 Apache HBase 是目前大数据系统中应用最为广泛的分布式数据库之一。我们经常面临向 HBase 中导入大量数据的情景，通常会选择使用标准的客户端 API 对 HBase 进行直接的操</description>
    </item>
    
    <item>
      <title>Java 基础之注解</title>
      <link>https://blog.jrwang.me/2015/java-annotation/</link>
      <pubDate>Thu, 26 Nov 2015 19:24:35 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-annotation/</guid>
      <description>概览 注解(Annotation)，是从 Java 5 开始引入的一项新特性。所谓注解，就是一种元数据，可以藉此为程序添加非功能性的数据。注解对它们所标注</description>
    </item>
    
    <item>
      <title>Java 中的动态代理与反射</title>
      <link>https://blog.jrwang.me/2015/java-dynamic-proxy-and-java-reflection/</link>
      <pubDate>Fri, 20 Nov 2015 20:40:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-dynamic-proxy-and-java-reflection/</guid>
      <description>代理， 是一种十分常见的设计模式，即为其他对象提供一个代理从而控制对这个对象的访问。使用代理模式的场景有很多，比如控制对远程对象的访问；对象实</description>
    </item>
    
    <item>
      <title>Java 基础之反射</title>
      <link>https://blog.jrwang.me/2015/java-reflection/</link>
      <pubDate>Fri, 13 Nov 2015 21:20:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-reflection/</guid>
      <description>反射能够让运行在JVM中的程序检测和修改运行时的行为。在Java中使用反射API可以在运行时获取对象的内部结构信息，就仿佛相应的Java类的</description>
    </item>
    
    <item>
      <title>Java 基础之泛型</title>
      <link>https://blog.jrwang.me/2015/java-generics/</link>
      <pubDate>Tue, 03 Nov 2015 20:18:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-generics/</guid>
      <description>Java平台在JDK 5中引入了一个重要的特性 —— 泛型（generics），允许在定义类和接口的时候使用 句法表示的类型参数（type param</description>
    </item>
    
    <item>
      <title>Java 中的变长参数</title>
      <link>https://blog.jrwang.me/2015/java-varargs/</link>
      <pubDate>Thu, 29 Oct 2015 21:30:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-varargs/</guid>
      <description>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是Java的一个语法糖，本质上还是基于数组的实现。 1 2 void foo(String... args); void foo(String[] args); 1 2 /</description>
    </item>
    
    <item>
      <title>Java成员变量的初始化</title>
      <link>https://blog.jrwang.me/2015/java-field-init-note/</link>
      <pubDate>Sat, 03 Oct 2015 18:37:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-field-init-note/</guid>
      <description>Java中的成员变量（Member Variable or Field）根据是否有static修饰可分为两类，分别是： - static field (class variable): 类所有，所有类的实例在内存中共享一</description>
    </item>
    
  </channel>
</rss>