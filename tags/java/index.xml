<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Java on JR&#39;s Blog</title>
    <link>https://blog.jrwang.me/tags/java/</link>
    <description>Recent content in Java on JR&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 10 Apr 2016 20:26:22 +0000</lastBuildDate>
    
	<atom:link href="https://blog.jrwang.me/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 容器源码分析之 Set</title>
      <link>https://blog.jrwang.me/2016/java-collections-set/</link>
      <pubDate>Sun, 10 Apr 2016 20:26:22 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-set/</guid>
      <description>Set 表示由无重复对象组成的集合，也是集合框架中重要的一种集合类型，直接扩展自 Collection 接口。在一个 Set 中，不能有两个引用指向同一个对象，或两个指向 null 的引</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 TreeMap</title>
      <link>https://blog.jrwang.me/2016/java-collections-treemap/</link>
      <pubDate>Sat, 09 Apr 2016 20:00:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-treemap/</guid>
      <description>TreeMap 是一种基于红黑树实现的 Key-Value 结构。在使用集合视图在 HashMap 中迭代时，是不能保证迭代顺序的； LinkedHashMap 使用了双向链表，保证按照插入顺序或者访问顺序进行迭代。但</description>
    </item>
    
    <item>
      <title>Java 枚举源码分析</title>
      <link>https://blog.jrwang.me/2016/java-enum/</link>
      <pubDate>Fri, 01 Apr 2016 20:06:19 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-enum/</guid>
      <description>引言 枚举类型是 JDK 5 之后引进的一种非常重要的引用类型，可以用来定义一系列枚举常量。 在没有引入 enum 关键字之前，要表示可枚举的变量，只能使用 public static final 的</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 LinkedHashMap</title>
      <link>https://blog.jrwang.me/2016/java-collections-linkedhashmap/</link>
      <pubDate>Sun, 27 Mar 2016 20:21:06 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-linkedhashmap/</guid>
      <description>同 HashMap 一样，LinkedHashMap 也是对 Map 接口的一种基于链表和哈希表的实现。实际上， LinkedHashMap 是 HashMap 的子类，其扩展了 HashMap 增加了双向链表的实现。相较于 HashMap</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 LinkedList</title>
      <link>https://blog.jrwang.me/2016/java-collections-linkedlist/</link>
      <pubDate>Mon, 21 Mar 2016 19:03:52 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-linkedlist/</guid>
      <description>概览 同 ArrayList 一样，LinkedList 也是对 List 接口的一种具体实现。不同的是，ArrayList 是基于数组来实现的，而 LinkedList 是基于双向链表实现的。Li</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 Deque 与 ArrayDeque</title>
      <link>https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</link>
      <pubDate>Wed, 16 Mar 2016 20:32:07 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-deque-arraydeque/</guid>
      <description>Queue 也是 Java 集合框架中定义的一种接口，直接继承自 Collection 接口。除了基本的 Collection 接口规定测操作外，Queue 接口还定义一组针对队列的特殊操作。通常来说，Qu</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 Vector 与 Stack</title>
      <link>https://blog.jrwang.me/2016/java-collections-vector-stack/</link>
      <pubDate>Tue, 15 Mar 2016 22:06:19 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-vector-stack/</guid>
      <description>JDK 文档中对Vector的描述是这样的：Vector 类实现了一个可增长的对象数组。像数组一样，可以通过整型索引来获取内容，但是 Vector 的大小可以按照</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 HashMap</title>
      <link>https://blog.jrwang.me/2016/java-collections-hashmap/</link>
      <pubDate>Tue, 15 Mar 2016 09:00:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-hashmap/</guid>
      <description>HashMap 是对 Map 接口的一种基于哈希表的实现。所谓 Map，就是映射，存储一系列 Key-Value 对，一个键对应一个值，通过键来查找对应的值。HashMap 是一种高效的</description>
    </item>
    
    <item>
      <title>Java 容器源码分析之 ArrayList</title>
      <link>https://blog.jrwang.me/2016/java-collections-arraylist/</link>
      <pubDate>Mon, 14 Mar 2016 20:00:21 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-collections-arraylist/</guid>
      <description>概览 ArrayList是最常使用的集合类之一了。在JDK文档中对ArrayList的描述是：ArrayList是对list接口的一种基于可变</description>
    </item>
    
    <item>
      <title>关于 Java 内部类的小抄</title>
      <link>https://blog.jrwang.me/2016/java-inner-class/</link>
      <pubDate>Sat, 30 Jan 2016 22:35:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2016/java-inner-class/</guid>
      <description>为什么使用内部类？ 在 『Effective Java』中提到了一条建议，尽量使类和成员的可访问性最小化。这个原则其实是面向对象的程序设计的基本原</description>
    </item>
    
    <item>
      <title>Java 基础之注解</title>
      <link>https://blog.jrwang.me/2015/java-annotation/</link>
      <pubDate>Thu, 26 Nov 2015 19:24:35 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-annotation/</guid>
      <description>概览 注解(Annotation)，是从 Java 5 开始引入的一项新特性。所谓注解，就是一种元数据，可以藉此为程序添加非功能性的数据。注解对它们所标注</description>
    </item>
    
    <item>
      <title>Java 中的动态代理与反射</title>
      <link>https://blog.jrwang.me/2015/java-dynamic-proxy-and-java-reflection/</link>
      <pubDate>Fri, 20 Nov 2015 20:40:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-dynamic-proxy-and-java-reflection/</guid>
      <description>代理， 是一种十分常见的设计模式，即为其他对象提供一个代理从而控制对这个对象的访问。使用代理模式的场景有很多，比如控制对远程对象的访问；对象实</description>
    </item>
    
    <item>
      <title>Java 基础之反射</title>
      <link>https://blog.jrwang.me/2015/java-reflection/</link>
      <pubDate>Fri, 13 Nov 2015 21:20:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-reflection/</guid>
      <description>反射能够让运行在JVM中的程序检测和修改运行时的行为。在Java中使用反射API可以在运行时获取对象的内部结构信息，就仿佛相应的Java类的</description>
    </item>
    
    <item>
      <title>Java 基础之泛型</title>
      <link>https://blog.jrwang.me/2015/java-generics/</link>
      <pubDate>Tue, 03 Nov 2015 20:18:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-generics/</guid>
      <description>Java平台在JDK 5中引入了一个重要的特性 —— 泛型（generics），允许在定义类和接口的时候使用 句法表示的类型参数（type param</description>
    </item>
    
    <item>
      <title>Java 中的变长参数</title>
      <link>https://blog.jrwang.me/2015/java-varargs/</link>
      <pubDate>Thu, 29 Oct 2015 21:30:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-varargs/</guid>
      <description>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是Java的一个语法糖，本质上还是基于数组的实现。 1 2 void foo(String... args); void foo(String[] args); 1 2 /</description>
    </item>
    
    <item>
      <title>Java成员变量的初始化</title>
      <link>https://blog.jrwang.me/2015/java-field-init-note/</link>
      <pubDate>Sat, 03 Oct 2015 18:37:11 +0000</pubDate>
      
      <guid>https://blog.jrwang.me/2015/java-field-init-note/</guid>
      <description>Java中的成员变量（Member Variable or Field）根据是否有static修饰可分为两类，分别是： - static field (class variable): 类所有，所有类的实例在内存中共享一</description>
    </item>
    
  </channel>
</rss>